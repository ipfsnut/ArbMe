<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>ArbMe - Liquidity Pools</title>
  <style>
    :root {
      --bg-primary: #0a0a0f;
      --bg-secondary: #0f0f18;
      --bg-card: #12121c;
      --border: #1f1f2f;
      --border-active: #2a2a3f;
      --text-primary: #e8e8f2;
      --text-secondary: #7a7a8f;
      --text-muted: #5a5a6f;
      --accent: #10b981;
      --accent-dim: #0d9668;
      --accent-glow: rgba(16, 185, 129, 0.15);
      --warning: #f59e0b;
      --positive: #22c55e;
      --negative: #ef4444;
      --purple: #8b5cf6;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { background: var(--bg-primary); min-height: 100%; }
    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      min-height: 100vh;
      min-height: 100dvh;
      padding: 0 1rem 2rem;
      padding-top: max(0.75rem, env(safe-area-inset-top));
      padding-bottom: max(2rem, calc(env(safe-area-inset-bottom) + 1rem));
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0 0.75rem;
    }
    .logo-section { display: flex; align-items: center; gap: 0.5rem; }
    .logo-icon { width: 32px; height: 32px; }
    .logo {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 1.375rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent) 0%, var(--warning) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .wallet-btn {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text-primary);
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.6875rem;
      font-weight: 500;
      cursor: pointer;
    }
    .wallet-btn.connected { border-color: var(--accent); }
    .wallet-btn svg { width: 14px; height: 14px; }
    .wallet-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent); animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    /* Price banner */
    .price-banner {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.5rem 0;
    }
    .price {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 1.125rem;
      color: var(--accent);
      font-weight: 600;
    }
    .price-change {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.75rem;
      padding: 0.125rem 0.375rem;
      border-radius: 4px;
      font-weight: 500;
    }
    .price-change.positive { background: rgba(34, 197, 94, 0.15); color: var(--positive); }
    .price-change.negative { background: rgba(239, 68, 68, 0.15); color: var(--negative); }

    /* Stats Grid */
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
      margin: 0.75rem 0;
    }
    .stat {
      text-align: center;
      background: var(--bg-secondary);
      padding: 0.75rem 0.5rem;
      border-radius: 12px;
      border: 1px solid var(--border);
    }
    .stat-value {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }
    .stat-value.accent { color: var(--accent); }
    .stat-label {
      font-size: 0.625rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-top: 0.125rem;
    }

    /* Section Header */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 1.25rem 0 0.5rem;
    }
    .section-label {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.6875rem;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 600;
    }
    .section-label.purple { color: var(--purple); }
    .icon-btn {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      padding: 0.375rem;
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.75rem;
    }
    .icon-btn:active { background: var(--bg-secondary); color: var(--accent); }
    .icon-btn.loading { opacity: 0.5; }
    .icon-btn.loading svg { animation: spin 1s linear infinite; }
    .icon-btn svg { width: 14px; height: 14px; }
    .icon-btn.small { padding: 0.25rem; }
    .icon-btn.small svg { width: 12px; height: 12px; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* Your Positions */
    .positions-section { display: none; }
    .positions-section.visible { display: block; }
    .position-card {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(16, 185, 129, 0.1) 100%);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 14px;
      padding: 1rem;
      margin-bottom: 0.625rem;
      min-height: 50px; /* DEBUG: ensure minimum height */
    }
    .position-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .position-pair {
      display: flex;
      align-items: center;
      gap: 0.625rem;
    }
    .position-icons { display: flex; position: relative; width: 44px; }
    .position-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid var(--bg-card);
      background: var(--bg-secondary);
    }
    .position-icon:last-child { margin-left: -10px; }
    .position-name {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-weight: 600;
      font-size: 0.9375rem;
    }
    .position-badge {
      font-size: 0.5625rem;
      padding: 0.125rem 0.375rem;
      border-radius: 4px;
      font-weight: 600;
      background: rgba(139, 92, 246, 0.2);
      color: var(--purple);
      margin-left: 0.375rem;
    }
    .position-badge.v2 { background: rgba(99, 102, 241, 0.15); color: #818cf8; }
    .position-badge.v3 { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
    .position-badge.v4 { background: rgba(16, 185, 129, 0.15); color: var(--accent); }
    .position-badge.closed { background: rgba(107, 114, 128, 0.15); color: #9ca3af; margin-left: 0.25rem; }
    .position-badge.in-range { background: rgba(16, 185, 129, 0.15); color: #10b981; margin-left: 0.25rem; font-size: 0.6rem; }
    .position-badge.out-of-range { background: rgba(239, 68, 68, 0.15); color: #ef4444; margin-left: 0.25rem; font-size: 0.6rem; }
    .position-card.out-of-range { border-left: 2px solid rgba(239, 68, 68, 0.5); }
    .position-card.closed { opacity: 0.6; display: none; }
    .show-closed .position-card.closed { display: block; }
    .positions-filter { margin-bottom: 0.75rem; }
    .filter-toggle { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.75rem; color: #9ca3af; }
    .filter-toggle input { width: 14px; height: 14px; accent-color: var(--accent); }
    .active-count { font-size: 0.6875rem; color: var(--accent); font-weight: 500; }
    .position-value {
      text-align: right;
    }
    .position-value-amount {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
    }
    .position-value-amount.usd-value {
      color: #10b981;
    }
    .position-detail-value.fees {
      color: #f59e0b;
      font-size: 0.75rem;
    }
    .position-value-label {
      font-size: 0.625rem;
      color: var(--text-secondary);
    }
    .position-details {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(139, 92, 246, 0.2);
    }
    .position-detail {
      text-align: center;
    }
    .position-detail-value {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.8125rem;
      font-weight: 600;
    }
    .position-detail-label {
      font-size: 0.5625rem;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    .position-pool-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      margin-top: 0.75rem;
      padding: 0.5rem;
      background: rgba(139, 92, 246, 0.08);
      border-radius: 8px;
    }
    .position-pool-stats .pool-stat {
      text-align: center;
    }
    .position-pool-stats .pool-stat-label {
      font-size: 0.5rem;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 0.125rem;
    }
    .position-pool-stats .pool-stat-value {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.6875rem;
      font-weight: 600;
    }
    .position-pool-stats .pool-stat-value.tvl { color: var(--accent); }
    .position-pool-stats .pool-stat-value.apr { color: #10b981; }
    .position-pool-stats .pool-stat-value.apr-high { color: #f59e0b; }
    .position-pool-stats .pool-stat-value.apr-medium { color: #10b981; }
    .position-pool-stats .pool-stat-value.change.positive { color: #10b981; }
    .position-pool-stats .pool-stat-value.change.negative { color: #ef4444; }
    .pending-fees-row {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
      margin-top: 0.75rem;
      padding: 0.625rem;
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(16, 185, 129, 0.15) 100%);
      border-radius: 8px;
      border: 1px solid rgba(245, 158, 11, 0.3);
    }
    .pending-fees-label {
      font-size: 0.5625rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .pending-fees-amounts {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.8125rem;
      font-weight: 600;
      color: #f59e0b;
    }
    .pending-fees-usd {
      font-size: 0.6875rem;
      color: #10b981;
      font-weight: 500;
    }
    .position-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .position-btn {
      flex: 1;
      padding: 0.625rem;
      border-radius: 8px;
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 0.15s;
    }
    .position-btn.add {
      background: var(--accent);
      color: #fff;
    }
    .position-btn.remove {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }
    .position-btn.collect {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #fff;
    }
    .position-btn:active { transform: scale(0.98); opacity: 0.9; }
    .position-btn.info {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 4px 8px;
      font-size: 11px;
    }
    .position-btn.info:hover { border-color: var(--accent); color: var(--accent); }

    /* No positions state */
    .no-positions {
      text-align: center;
      padding: 1.5rem;
      background: var(--bg-secondary);
      border-radius: 14px;
      border: 1px dashed var(--border);
    }
    .no-positions-text {
      color: var(--text-secondary);
      font-size: 0.875rem;
      margin-bottom: 0.75rem;
    }
    .no-positions-hint {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    /* Pool Cards */
    .pools { display: flex; flex-direction: column; gap: 0.625rem; }
    .pool {
      background: var(--bg-card);
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 1rem;
      transition: all 0.15s;
    }
    .pool-top {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .pool-icons { display: flex; position: relative; width: 48px; flex-shrink: 0; }
    .pool-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid var(--bg-card);
      background: var(--bg-secondary);
    }
    .pool-icon:last-child { margin-left: -12px; }
    .pool-info { flex: 1; min-width: 0; }
    .pool-name {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-weight: 600;
      font-size: 1rem;
      color: var(--text-primary);
    }
    .pool-meta {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.125rem;
    }
    .pool-dex { font-size: 0.75rem; color: var(--text-secondary); }
    .pool-badge {
      font-size: 0.5625rem;
      padding: 0.125rem 0.375rem;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .pool-badge.v2 { background: rgba(99, 102, 241, 0.15); color: #818cf8; }
    .pool-badge.v3 { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
    .pool-badge.v4 { background: rgba(16, 185, 129, 0.15); color: var(--accent); }
    .pool-badge.low-liq { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
    .pool-fee-badge {
      font-size: 0.5625rem;
      padding: 0.125rem 0.375rem;
      border-radius: 4px;
      font-weight: 600;
      background: rgba(245, 158, 11, 0.15);
      color: #f59e0b;
    }
    .pool-add-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: #fff;
      font-size: 1.25rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.15s;
    }
    .pool-add-btn:active { transform: scale(0.95); background: var(--accent-dim); }
    .pool-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 0.75rem;
      padding-top: 0.625rem;
      border-top: 1px solid var(--border);
    }
    .pool-stat { text-align: left; }
    .pool-stat:last-child { text-align: right; }
    .pool-stat-label {
      font-size: 0.5625rem;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    .pool-stat-value {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.875rem;
      font-weight: 600;
      margin-top: 0.0625rem;
    }
    .pool-stat-value.tvl { color: var(--accent); }
    .pool-stat-value.change.positive { color: var(--positive); }
    .pool-stat-value.change.negative { color: var(--negative); }
    .pool-stat-value.apr { color: #10b981; }
    .pool-stat-value.apr.apr-high { color: #f59e0b; font-weight: 700; }
    .pool-stat-value.apr.apr-medium { color: #22c55e; }

    /* Loading */
    .loading { text-align: center; padding: 2rem 1rem; color: var(--text-secondary); }
    .loading-spinner {
      width: 28px;
      height: 28px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 0.75rem;
    }
    .loading-text { font-size: 0.8125rem; }
    .error-text { color: var(--negative); font-size: 0.8125rem; }

    /* Buttons */
    .buttons { display: flex; gap: 0.5rem; margin-top: 1.25rem; }
    .btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
      padding: 0.875rem;
      border: none;
      border-radius: 12px;
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-weight: 600;
      font-size: 0.875rem;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.15s;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dim) 100%);
      color: #fff;
    }
    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }
    .btn:active { transform: scale(0.98); }
    .btn svg { width: 16px; height: 16px; }

    /* Footer */
    .footer {
      text-align: center;
      margin-top: 1.25rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border);
    }
    .footer-text { font-size: 0.625rem; color: var(--text-muted); }
    .footer-text a { color: var(--text-secondary); text-decoration: none; }

    /* Tip Jar */
    .tip-jar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .tip-jar-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }
    .tip-btn {
      padding: 0.25rem 0.5rem;
      font-size: 0.65rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.15s;
    }
    .tip-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }
    .tip-btn:active { transform: scale(0.95); }
    .tip-btn.tipping {
      opacity: 0.6;
      pointer-events: none;
    }
    /* Transaction Preview */
    .tx-preview {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .tx-preview-header {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .tx-preview-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      padding: 0.25rem 0;
    }
    .tx-preview-row.total {
      border-top: 1px solid var(--border);
      margin-top: 0.25rem;
      padding-top: 0.5rem;
      font-weight: 600;
    }
    .tx-preview-label { color: var(--text-secondary); }
    .tx-preview-value { color: var(--text-primary); font-weight: 500; }
    .tx-preview-usd { color: var(--text-muted); font-size: 0.65rem; margin-left: 0.25rem; }
    .tx-preview-price {
      background: var(--background);
      border-radius: 0.375rem;
      padding: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.7rem;
      text-align: center;
    }
    .tx-preview-price-label { color: var(--text-muted); }
    .tx-preview-price-value { color: var(--primary); font-weight: 600; }
    .tx-preview-warning {
      color: var(--warning, #f59e0b);
      font-size: 0.65rem;
      margin-top: 0.5rem;
      padding: 0.375rem;
      background: rgba(245, 158, 11, 0.1);
      border-radius: 0.25rem;
    }
    .auto-balance-hint {
      color: var(--text-secondary, #a1a1aa);
      font-size: 0.65rem;
      margin-top: 0.25rem;
      padding: 0.375rem;
      background: rgba(161, 161, 170, 0.1);
      border-radius: 0.25rem;
      text-align: center;
    }
    /* Manual Price Input */
    .manual-price-input {
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid var(--warning, #f59e0b);
      border-radius: 0.375rem;
    }
    .manual-price-label {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.65rem;
      color: var(--warning, #f59e0b);
      margin-bottom: 0.375rem;
    }
    .manual-price-label svg {
      width: 12px;
      height: 12px;
    }
    .manual-price-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .manual-price-field {
      flex: 1;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      background: var(--background);
      border: 1px solid var(--border);
      border-radius: 0.25rem;
      color: var(--text-primary);
    }
    .manual-price-field:focus {
      outline: none;
      border-color: var(--warning, #f59e0b);
    }
    .manual-price-suffix {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }
    .price-source-badge {
      display: inline-block;
      font-size: 0.55rem;
      padding: 0.125rem 0.25rem;
      border-radius: 0.25rem;
      margin-left: 0.25rem;
    }
    .price-source-badge.verified {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }
    .price-source-badge.manual {
      background: rgba(245, 158, 11, 0.2);
      color: #f59e0b;
    }

    /* Token Dropdown */
    .token-dropdown-container {
      position: relative;
      margin-bottom: 0.5rem;
    }
    .token-dropdown-toggle {
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: var(--bg-secondary, #111);
      border: 1px solid var(--border, #333);
      border-radius: 0.375rem;
      color: var(--text, #fff);
      font-size: 0.75rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .token-dropdown-toggle:hover {
      border-color: var(--accent, #10b981);
    }
    .token-dropdown-toggle .token-preview {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
      min-width: 0;
    }
    .token-dropdown-toggle .token-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--bg-tertiary, #222);
      flex-shrink: 0;
    }
    .token-dropdown-toggle .token-symbol {
      font-weight: 600;
      color: var(--accent, #10b981);
    }
    .token-dropdown-toggle .token-balance {
      color: var(--text-secondary, #888);
      font-size: 0.65rem;
      margin-left: auto;
    }
    .token-dropdown-toggle .chevron {
      width: 14px;
      height: 14px;
      color: var(--text-secondary, #888);
      transition: transform 0.2s;
      flex-shrink: 0;
    }
    .token-dropdown-toggle.open .chevron {
      transform: rotate(180deg);
    }
    .token-dropdown-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-card, #0f0f18);
      border: 1px solid var(--border, #333);
      border-radius: 0.375rem;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .token-dropdown-list.open {
      display: block;
    }
    .token-dropdown-item {
      padding: 0.5rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      border-bottom: 1px solid var(--border, #222);
    }
    .token-dropdown-item:last-child {
      border-bottom: none;
    }
    .token-dropdown-item:hover {
      background: var(--bg-secondary, #111);
    }
    .token-dropdown-item .token-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--bg-tertiary, #222);
      flex-shrink: 0;
      object-fit: cover;
    }
    .token-dropdown-item .token-info {
      flex: 1;
      min-width: 0;
    }
    .token-dropdown-item .token-symbol {
      font-weight: 600;
      font-size: 0.75rem;
      color: var(--text, #fff);
    }
    .token-dropdown-item .token-name {
      font-size: 0.6rem;
      color: var(--text-secondary, #888);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .token-dropdown-item .token-amounts {
      text-align: right;
      flex-shrink: 0;
    }
    .token-dropdown-item .token-balance {
      font-size: 0.7rem;
      color: var(--text, #fff);
    }
    .token-dropdown-item .token-value {
      font-size: 0.6rem;
      color: var(--text-secondary, #888);
    }
    .token-dropdown-item .no-price {
      color: var(--warning, #f59e0b);
      font-size: 0.55rem;
    }
    .token-dropdown-item.custom-entry {
      color: var(--text-secondary, #888);
      font-size: 0.7rem;
      justify-content: center;
      padding: 0.75rem;
    }
    .token-dropdown-item.custom-entry:hover {
      color: var(--accent, #10b981);
    }
    .token-dropdown-loading {
      padding: 1rem;
      text-align: center;
      color: var(--text-secondary, #888);
      font-size: 0.7rem;
    }
    .token-dropdown-empty {
      padding: 1rem;
      text-align: center;
      color: var(--text-secondary, #888);
      font-size: 0.7rem;
    }
    .token-dropdown-search {
      padding: 0.5rem;
      border-bottom: 1px solid var(--border, #333);
      position: sticky;
      top: 0;
      background: var(--surface, #1a1a2e);
      z-index: 1;
    }
    .token-dropdown-search input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: var(--bg, #0a0a0f);
      border: 1px solid var(--border, #333);
      border-radius: 6px;
      color: var(--text, #fff);
      font-size: 0.75rem;
      outline: none;
    }
    .token-dropdown-search input:focus {
      border-color: var(--accent, #10b981);
    }
    .token-dropdown-search input::placeholder {
      color: var(--text-secondary, #888);
    }
    .token-dropdown-items {
      max-height: 250px;
      overflow-y: auto;
    }
    .custom-address-toggle {
      font-size: 0.65rem;
      color: var(--text-secondary, #888);
      cursor: pointer;
      margin-top: 0.25rem;
      display: inline-block;
    }
    .custom-address-toggle:hover {
      color: var(--accent, #10b981);
    }

    /* Collapsible */
    .collapsible-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 0.5rem 0;
    }
    .collapsible-header .chevron {
      width: 16px;
      height: 16px;
      color: var(--text-secondary);
      transition: transform 0.2s;
    }
    .collapsible-header.collapsed .chevron { transform: rotate(-90deg); }
    .collapsible-content { overflow: hidden; transition: max-height 0.3s ease; }
    .collapsible-content.collapsed { max-height: 0 !important; }
    .portfolio-value-display { display: flex; align-items: center; gap: 0.5rem; }
    .portfolio-value { font-size: 0.875rem; font-weight: 600; color: var(--accent); }

    /* Show more button */
    .show-more-btn {
      width: 100%;
      padding: 0.75rem;
      margin-top: 0.5rem;
      background: var(--bg-secondary);
      border: 1px dashed var(--border);
      border-radius: 10px;
      color: var(--text-secondary);
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.15s;
    }
    .show-more-btn:active { background: var(--bg-card); color: var(--accent); }

    /* Pool price */
    .pool-price {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.6875rem;
      color: var(--warning);
      margin-top: 0.125rem;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .modal-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 360px;
      max-height: 90vh;
      overflow-y: auto;
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }
    .modal-title {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 1rem;
      font-weight: 600;
    }
    .modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }
    .modal-body {
      padding: 1rem;
    }
    .input-group {
      margin-bottom: 1rem;
    }
    .input-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .input-balance {
      color: var(--text-muted);
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      cursor: pointer;
    }
    .input-balance:hover { color: var(--accent); }
    .input-wrapper {
      display: flex;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }
    .input-wrapper:focus-within { border-color: var(--accent); }
    .amount-input {
      flex: 1;
      background: none;
      border: none;
      color: var(--text-primary);
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 1rem;
      padding: 0.75rem;
      outline: none;
    }
    .amount-input::placeholder { color: var(--text-muted); }
    .input-token {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0 0.75rem;
      color: var(--text-secondary);
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.875rem;
      font-weight: 500;
    }
    .input-token img {
      width: 20px;
      height: 20px;
      border-radius: 50%;
    }
    .tx-status {
      padding: 0.75rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      font-size: 0.8125rem;
      display: none;
    }
    .tx-status.pending {
      display: block;
      background: rgba(245, 158, 11, 0.15);
      color: var(--warning);
    }
    .tx-status.success {
      display: block;
      background: rgba(34, 197, 94, 0.15);
      color: var(--positive);
    }
    .tx-status.error {
      display: block;
      background: rgba(239, 68, 68, 0.15);
      color: var(--negative);
    }
    .modal-actions {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .modal-btn {
      padding: 0.875rem;
      border-radius: 10px;
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 0.15s;
    }
    .modal-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .modal-btn.primary {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dim) 100%);
      color: #fff;
    }
    .modal-btn.secondary {
      background: var(--bg-card);
      border: 1px solid var(--border);
      color: var(--text-primary);
    }
    .modal-btn:active:not(:disabled) { transform: scale(0.98); }
    .approval-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0;
      font-size: 0.8125rem;
    }
    .approval-status {
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }
    .approval-check {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.625rem;
    }
    .approval-check.approved { background: var(--accent); color: #fff; }
    .approval-check.pending { background: var(--border); color: var(--text-muted); }

    /* Confirmation Modal */
    .confirm-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      padding: 1rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .confirm-modal-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .confirm-modal {
      background: var(--bg-secondary);
      border: 2px solid var(--warning);
      border-radius: 16px;
      width: 100%;
      max-width: 380px;
      box-shadow: 0 0 30px rgba(251, 191, 36, 0.2);
    }
    .confirm-modal-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 1rem;
      border-bottom: 1px solid var(--border);
      color: var(--warning);
    }
    .confirm-modal-header svg {
      width: 24px;
      height: 24px;
    }
    .confirm-modal-title {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 1rem;
      font-weight: 600;
    }
    .confirm-modal-body {
      padding: 1rem;
    }
    .confirm-summary {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
    .confirm-summary-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
    }
    .confirm-token-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    .confirm-token-amount {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.875rem;
      font-weight: 600;
    }
    .confirm-token-value {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
    .confirm-price-info {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
    .confirm-checkbox-container {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 1rem;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-radius: 12px;
      margin-bottom: 1rem;
      cursor: pointer;
    }
    .confirm-checkbox-container:hover {
      background: rgba(251, 191, 36, 0.15);
    }
    .confirm-checkbox {
      width: 20px;
      height: 20px;
      min-width: 20px;
      border: 2px solid var(--warning);
      border-radius: 4px;
      margin-top: 2px;
      cursor: pointer;
      accent-color: var(--warning);
    }
    .confirm-checkbox-label {
      font-size: 0.8125rem;
      color: var(--text-primary);
      line-height: 1.4;
    }
    .confirm-modal-actions {
      display: flex;
      gap: 0.75rem;
    }
    .confirm-modal-btn {
      flex: 1;
      padding: 0.875rem;
      border-radius: 10px;
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.8125rem;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 0.15s;
    }
    .confirm-modal-btn.cancel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      color: var(--text-primary);
    }
    .confirm-modal-btn.proceed {
      background: linear-gradient(135deg, var(--warning) 0%, #f59e0b 100%);
      color: #000;
    }
    .confirm-modal-btn.proceed:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .confirm-modal-btn:active:not(:disabled) { transform: scale(0.98); }

    /* Remove Liquidity Modal */
    .modal-btn.danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: #fff;
    }
    .remove-pool-info {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
    .remove-pool-pair {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }
    .remove-pool-balance {
      display: flex;
      justify-content: space-between;
      font-size: 0.8125rem;
      color: var(--text-secondary);
    }
    .remove-pool-balance span:last-child {
      color: var(--accent);
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
    }
    .percentage-selector {
      margin-bottom: 1rem;
    }
    .percentage-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }
    .percentage-options {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    .percentage-btn {
      flex: 1;
      padding: 0.5rem;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 0.8125rem;
      cursor: pointer;
      transition: all 0.15s;
    }
    .percentage-btn:hover { border-color: var(--accent); }
    .percentage-btn.selected {
      border-color: var(--accent);
      background: var(--accent-glow);
      color: var(--accent);
    }
    .percentage-slider-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .percentage-slider {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      background: var(--border);
      border-radius: 3px;
      outline: none;
    }
    .percentage-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
    }
    .percentage-value {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.875rem;
      color: var(--accent);
      min-width: 40px;
      text-align: right;
    }
    .remove-output-preview {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
    .remove-output-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }
    .remove-output-row {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.875rem;
      padding: 0.25rem 0;
    }
    .v3-position-amounts {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
    }
    .v3-amount-row {
      display: flex;
      justify-content: space-between;
      padding: 0.25rem 0;
      font-size: 0.8125rem;
    }
    .v3-amount-label {
      color: var(--text-secondary);
    }
    .v3-amount-value {
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      color: var(--text-primary);
    }
    .v4-add-info {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
    .v4-add-info p {
      margin: 0;
      font-size: 0.875rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* Token/Version Selector */
    .selector-group {
      margin-bottom: 1rem;
    }
    .selector-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.375rem;
    }
    .selector-options {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .selector-option {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }
    .selector-option:hover { border-color: var(--accent); }
    .selector-option.selected {
      border-color: var(--accent);
      background: var(--accent-glow);
      color: var(--accent);
    }
    .selector-option img {
      width: 18px;
      height: 18px;
      border-radius: 50%;
    }
    .version-badge {
      padding: 0.25rem 0.5rem;
      border-radius: 6px;
      font-weight: 600;
    }
    .version-badge.v2 { background: rgba(99, 102, 241, 0.15); color: #818cf8; }
    .version-badge.v3 { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
    .version-badge.v4 { background: rgba(16, 185, 129, 0.15); color: var(--accent); }

    .token-address-group {
      margin-bottom: 1rem;
    }
    .token-address-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.375rem;
      font-weight: 500;
    }
    .token-address-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    .token-address-input {
      flex: 1;
      padding: 0.625rem 0.75rem;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.7rem;
      color: var(--text-primary);
    }
    .token-address-input:focus {
      border-color: var(--accent);
      outline: none;
    }
    .token-address-input::placeholder {
      color: var(--text-muted);
    }
    .token-resolved {
      padding: 0.5rem 0.75rem;
      background: var(--accent-glow);
      border: 1px solid var(--accent);
      border-radius: 8px;
      min-width: 60px;
      text-align: center;
    }
    .token-resolved .token-symbol {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--accent);
    }
    .token-resolved.loading .token-symbol {
      color: var(--text-muted);
    }
    .token-resolved.error {
      border-color: var(--red);
      background: rgba(239, 68, 68, 0.1);
    }
    .token-resolved.error .token-symbol {
      color: var(--red);
    }

    /* Create Position Button */
    .create-position-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
      width: 100%;
      padding: 0.75rem;
      margin-top: 0.5rem;
      background: linear-gradient(135deg, var(--purple) 0%, var(--accent) 100%);
      border: none;
      border-radius: 10px;
      color: #fff;
      font-family: ui-monospace, 'SF Mono', Monaco, monospace;
      font-size: 0.8125rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .create-position-btn:active { transform: scale(0.98); opacity: 0.9; }
    .create-position-btn svg { width: 16px; height: 16px; }

    /* Toast notifications */
    #toast-container {
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      pointer-events: none;
    }
    .toast {
      background: rgba(10, 10, 15, 0.95);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.625rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(12px);
      animation: toastSlideIn 0.3s ease-out;
      pointer-events: auto;
      max-width: 90vw;
    }
    .toast.success { border-color: #10b981; }
    .toast.error { border-color: #ef4444; }
    .toast.info { border-color: var(--accent); }
    .toast-icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
    }
    .toast.success .toast-icon { color: #10b981; }
    .toast.error .toast-icon { color: #ef4444; }
    .toast.info .toast-icon { color: var(--accent); }
    .toast-content {
      flex: 1;
    }
    .toast-title {
      font-size: 0.8125rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    .toast-message {
      font-size: 0.6875rem;
      color: var(--text-secondary);
      margin-top: 0.125rem;
    }
    .toast-message a {
      color: var(--accent);
      text-decoration: none;
    }
    .toast.hiding {
      animation: toastSlideOut 0.2s ease-in forwards;
    }
    @keyframes toastSlideIn {
      from { opacity: 0; transform: translateY(-1rem); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes toastSlideOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-1rem); }
    }
  </style>
</head>
<body>
  <!-- Toast notification container -->
  <div id="toast-container"></div>

  <div class="header">
    <div class="logo-section">
      <svg class="logo-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <rect width="32" height="32" rx="8" fill="#0a0a0f"/>
        <rect x="5" y="3" width="22" height="24" rx="5" fill="#10b981"/>
        <rect x="7" y="5" width="18" height="20" rx="4" fill="#0a0a0f"/>
        <circle cx="12" cy="13" r="3" fill="#10b981"/>
        <circle cx="20" cy="13" r="3" fill="#10b981"/>
        <rect x="9" y="18" width="14" height="5" rx="2" fill="#10b981"/>
      </svg>
      <div class="logo">$ARBME</div>
    </div>
    <button class="wallet-btn" id="wallet-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="2" y="4" width="20" height="16" rx="2"/>
        <path d="M16 12h.01"/>
      </svg>
      <span id="wallet-text">Connect</span>
    </button>
  </div>

  <div class="price-banner">
    <span class="price" id="price">--</span>
    <span class="price-change positive" id="price-change" style="display:none">+0.00%</span>
  </div>

  <div class="stats">
    <div class="stat">
      <div class="stat-value" id="pool-count">--</div>
      <div class="stat-label">Pools</div>
    </div>
    <div class="stat">
      <div class="stat-value accent" id="total-tvl">--</div>
      <div class="stat-label">Total TVL</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="total-vol">--</div>
      <div class="stat-label">24h Vol</div>
    </div>
  </div>

  <!-- Your Positions Section (Collapsible) -->
  <div class="positions-section" id="positions-section">
    <div class="collapsible-header" id="positions-header">
      <div class="section-label purple">Your Positions <span id="positions-count"></span> <span id="active-count" class="active-count"></span></div>
      <div class="portfolio-value-display">
        <span id="portfolio-value" class="portfolio-value"></span>
        <button class="icon-btn small" id="refresh-positions-btn" title="Refresh positions" onclick="event.stopPropagation(); loadPositions();">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
            <path d="M21 3v5h-5"/>
          </svg>
        </button>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="6 9 12 15 18 9"/>
        </svg>
      </div>
    </div>
    <div class="collapsible-content" id="positions-content">
      <div class="positions-filter">
        <label class="filter-toggle">
          <input type="checkbox" id="show-closed-toggle" onchange="toggleClosedPositions()">
          <span class="filter-label">Show closed positions</span>
        </label>
      </div>
      <button class="create-position-btn" onclick="openCreatePositionModal()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        Create New Position
      </button>
      <div id="positions-list">
        <div class="loading">
          <div class="loading-spinner"></div>
          <div class="loading-text">Loading positions...</div>
        </div>
      </div>
    </div>
  </div>

  <div class="section-header">
    <div class="section-label">All Pools</div>
    <button class="icon-btn" id="refresh-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
        <path d="M21 3v5h-5"/>
      </svg>
    </button>
  </div>

  <div class="pools" id="pools">
    <div class="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading pools...</div>
    </div>
  </div>
  <button class="show-more-btn" id="show-more-btn" style="display:none">Show all pools</button>

  <div class="buttons">
    <button class="btn btn-primary" id="buy-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
      </svg>
      Buy $ARBME
    </button>
    <a href="https://arbme.epicdylan.com" target="_blank" class="btn btn-secondary">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"/>
        <path d="M12 16v-4M12 8h.01"/>
      </svg>
      Info
    </a>
  </div>

  <div class="footer">
    <div class="tip-jar">
      <span class="tip-jar-label">Support ArbMe:</span>
      <button class="tip-btn" onclick="sendTip('0.0001')">$0.25</button>
      <button class="tip-btn" onclick="sendTip('0.0004')">$1</button>
      <button class="tip-btn" onclick="sendTip('0.002')">$5</button>
    </div>
    <div class="footer-text">Built by <a href="https://warpcast.com/epicdylan.eth" target="_blank">epicdylan</a> Â· Powered by <a href="https://dexscreener.com/base/0xC647421C5Dc78D1c3960faA7A33f9aEFDF4B7B07" target="_blank">DexScreener</a> & Alchemy</div>
  </div>

  <!-- Add Liquidity Modal -->
  <div class="modal-overlay" id="liquidity-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title" id="modal-title">Add Liquidity</span>
        <button class="modal-close" onclick="closeModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="tx-status" class="tx-status"></div>

        <div class="input-group">
          <div class="input-label">
            <span id="token0-label">PAGE Amount</span>
            <span class="input-balance" id="token0-balance" onclick="setMaxToken0()">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="token0-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="token0-icon" src="https://arbme.epicdylan.com/pagedaologo.png" alt="">
              <span id="token0-symbol">PAGE</span>
            </div>
          </div>
        </div>

        <div class="input-group">
          <div class="input-label">
            <span id="token1-label">ARBME Amount</span>
            <span class="input-balance" id="token1-balance" onclick="setMaxToken1()">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="token1-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="token1-icon" src="https://arbme.epicdylan.com/arbie.png" alt="">
              <span id="token1-symbol">ARBME</span>
            </div>
          </div>
        </div>

        <div id="approval-section" style="margin-bottom: 1rem; display: none;">
          <div class="approval-row">
            <span id="token0-symbol-approval">PAGE</span>
            <div class="approval-status">
              <span class="approval-check pending" id="token0-approval-check">?</span>
              <span id="token0-approval-text">Checking...</span>
            </div>
          </div>
          <div class="approval-row">
            <span id="token1-symbol-approval">ARBME</span>
            <div class="approval-status">
              <span class="approval-check pending" id="token1-approval-check">?</span>
              <span id="token1-approval-text">Checking...</span>
            </div>
          </div>
        </div>

        <div class="modal-actions">
          <button class="modal-btn primary" id="approve-btn" style="display: none;" onclick="approveTokens()">Approve Tokens</button>
          <button class="modal-btn primary" id="add-liquidity-btn" onclick="executeLiquidity()">Add Liquidity</button>
          <button class="modal-btn secondary" onclick="closeModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Create Position Modal -->
  <div class="modal-overlay" id="create-position-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title">Create New Position</span>
        <button class="modal-close" onclick="closeCreateModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="create-tx-status" class="tx-status"></div>
        <div id="create-success-tip" class="tip-jar" style="display: none; margin-top: 0.5rem;">
          <span class="tip-jar-label">Enjoying ArbMe?</span>
          <button class="tip-btn" onclick="sendTip('0.0001')">$0.25</button>
          <button class="tip-btn" onclick="sendTip('0.0004')">$1</button>
          <button class="tip-btn" onclick="sendTip('0.002')">$5</button>
        </div>

        <div class="token-address-group">
          <div class="token-address-label">Token A <span class="price-source-badge verified" id="tokenA-price-badge" style="display: none;">DexScreener</span></div>
          <!-- Token Dropdown -->
          <div class="token-dropdown-container" id="tokenA-dropdown-container">
            <div class="token-dropdown-toggle" id="tokenA-dropdown-toggle" onclick="toggleTokenDropdown('A')">
              <div class="token-preview">
                <span style="color: var(--text-secondary);">Select from wallet...</span>
              </div>
              <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
            </div>
            <div class="token-dropdown-list" id="tokenA-dropdown-list">
              <div class="token-dropdown-loading" id="tokenA-dropdown-loading">Loading wallet tokens...</div>
            </div>
          </div>
          <span class="custom-address-toggle" id="tokenA-custom-toggle" onclick="toggleCustomAddress('A')">or enter address manually</span>
          <!-- Custom address input (hidden by default) -->
          <div class="token-address-row" id="tokenA-address-row" style="display: none;">
            <input type="text" id="tokenA-address" placeholder="Contract address (0x...)" class="token-address-input" value="">
            <div class="token-resolved" id="tokenA-resolved">
              <span class="token-symbol" id="tokenA-symbol-display"></span>
            </div>
          </div>
          <div class="manual-price-input" id="tokenA-manual-price" style="display: none;">
            <div class="manual-price-label">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>
              <span>Price not found - enter manually</span>
            </div>
            <div class="manual-price-row">
              <span class="manual-price-suffix">1 <span id="tokenA-manual-symbol">TOKEN</span> =</span>
              <input type="number" class="manual-price-field" id="tokenA-price-input" placeholder="0.00" step="any">
              <span class="manual-price-suffix">USD</span>
            </div>
          </div>
        </div>

        <div class="token-address-group">
          <div class="token-address-label">Token B <span class="price-source-badge verified" id="tokenB-price-badge" style="display: none;">DexScreener</span></div>
          <!-- Token Dropdown -->
          <div class="token-dropdown-container" id="tokenB-dropdown-container">
            <div class="token-dropdown-toggle" id="tokenB-dropdown-toggle" onclick="toggleTokenDropdown('B')">
              <div class="token-preview">
                <span style="color: var(--text-secondary);">Select from wallet...</span>
              </div>
              <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
            </div>
            <div class="token-dropdown-list" id="tokenB-dropdown-list">
              <div class="token-dropdown-loading" id="tokenB-dropdown-loading">Loading wallet tokens...</div>
            </div>
          </div>
          <span class="custom-address-toggle" id="tokenB-custom-toggle" onclick="toggleCustomAddress('B')">or enter address manually</span>
          <!-- Custom address input (hidden by default) -->
          <div class="token-address-row" id="tokenB-address-row" style="display: none;">
            <input type="text" id="tokenB-address" placeholder="Contract address (0x...)" class="token-address-input" value="">
            <div class="token-resolved" id="tokenB-resolved">
              <span class="token-symbol" id="tokenB-symbol-display"></span>
            </div>
          </div>
          <div class="manual-price-input" id="tokenB-manual-price" style="display: none;">
            <div class="manual-price-label">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>
              <span>Price not found - enter manually</span>
            </div>
            <div class="manual-price-row">
              <span class="manual-price-suffix">1 <span id="tokenB-manual-symbol">TOKEN</span> =</span>
              <input type="number" class="manual-price-field" id="tokenB-price-input" placeholder="0.00" step="any">
              <span class="manual-price-suffix">USD</span>
            </div>
          </div>
        </div>

        <div class="selector-group">
          <div class="selector-label">Pool Version</div>
          <div class="selector-options" id="version-selector">
            <div class="selector-option selected" data-version="v2">
              <span class="version-badge v2">V2</span>
              <span>Simple</span>
            </div>
            <div class="selector-option" data-version="v3">
              <span class="version-badge v3">V3</span>
              <span>Concentrated</span>
            </div>
            <div class="selector-option" data-version="v4">
              <span class="version-badge v4">V4</span>
              <span>Hooks</span>
            </div>
          </div>
        </div>

        <div class="selector-group" id="create-fee-group" style="display: none;">
          <div class="selector-label">Fee Tier</div>
          <div class="selector-options" id="create-fee-selector">
            <div class="selector-option" data-fee="100">
              <span class="version-badge">0.01%</span>
              <span>Stable</span>
            </div>
            <div class="selector-option" data-fee="500">
              <span class="version-badge">0.05%</span>
              <span>Low</span>
            </div>
            <div class="selector-option selected" data-fee="3000">
              <span class="version-badge">0.3%</span>
              <span>Standard</span>
            </div>
            <div class="selector-option" data-fee="10000">
              <span class="version-badge">1%</span>
              <span>Exotic</span>
            </div>
            <div class="selector-option" data-fee="30000">
              <span class="version-badge">3%</span>
              <span>High</span>
            </div>
            <div class="selector-option" data-fee="50000">
              <span class="version-badge">5%</span>
              <span>Very High</span>
            </div>
            <div class="selector-option" data-fee="100000">
              <span class="version-badge">10%</span>
              <span>Extreme</span>
            </div>
            <div class="selector-option" data-fee="250000">
              <span class="version-badge">25%</span>
              <span>Max</span>
            </div>
            <div class="selector-option" data-fee="500000">
              <span class="version-badge">50%</span>
              <span>Ultra</span>
            </div>
          </div>
        </div>

        <div class="input-group">
          <div class="input-label">
            <span id="create-tokenA-label">USDC Amount</span>
            <span class="input-balance" id="create-tokenA-balance">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="create-tokenA-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="create-tokenA-icon" src="https://assets.coingecko.com/coins/images/6319/small/usdc.png" alt="">
              <span id="create-tokenA-symbol">USDC</span>
            </div>
          </div>
        </div>

        <div class="input-group">
          <div class="input-label">
            <span id="create-tokenB-label">ARBME Amount</span>
            <span class="input-balance" id="create-tokenB-balance">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="create-tokenB-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="create-tokenB-icon" src="https://arbme.epicdylan.com/arbie.png" alt="">
              <span id="create-tokenB-symbol">ARBME</span>
            </div>
          </div>
        </div>

        <!-- Auto-balance hint -->
        <div id="auto-balance-hint" class="auto-balance-hint" style="display: none;"></div>

        <!-- Transaction Preview -->
        <div class="tx-preview" id="create-tx-preview" style="display: none;">
          <div class="tx-preview-header">Transaction Preview</div>
          <div class="tx-preview-row">
            <span class="tx-preview-label" id="preview-tokenA-label">Token A:</span>
            <span><span class="tx-preview-value" id="preview-tokenA-amount">0</span><span class="tx-preview-usd" id="preview-tokenA-usd"></span></span>
          </div>
          <div class="tx-preview-row">
            <span class="tx-preview-label" id="preview-tokenB-label">Token B:</span>
            <span><span class="tx-preview-value" id="preview-tokenB-amount">0</span><span class="tx-preview-usd" id="preview-tokenB-usd"></span></span>
          </div>
          <div class="tx-preview-row total">
            <span class="tx-preview-label">Total Value:</span>
            <span class="tx-preview-value" id="preview-total-value">$0.00</span>
          </div>
          <div class="tx-preview-price" id="preview-price-section" style="display: none;">
            <span class="tx-preview-price-label">Initial Pool Price: </span>
            <span class="tx-preview-price-value" id="preview-initial-price">--</span>
          </div>
          <div class="tx-preview-warning" id="preview-warning" style="display: none;"></div>
        </div>

        <div class="modal-actions">
          <button class="modal-btn primary" id="create-position-submit" onclick="createNewPosition()">Create Position</button>
          <button class="modal-btn secondary" onclick="closeCreateModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Remove Liquidity Modal -->
  <div class="modal-overlay" id="remove-liquidity-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title">Remove Liquidity</span>
        <button class="modal-close" onclick="closeRemoveModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="remove-tx-status" class="tx-status"></div>

        <div class="remove-pool-info">
          <div class="remove-pool-pair" id="remove-pool-pair">PAGE / ARBME</div>
          <div class="remove-pool-balance">
            <span>Your LP Balance:</span>
            <span id="remove-lp-balance">--</span>
          </div>
        </div>

        <div class="percentage-selector">
          <div class="percentage-label">Amount to Remove</div>
          <div class="percentage-options">
            <button class="percentage-btn" onclick="setRemovePercentage(25)">25%</button>
            <button class="percentage-btn" onclick="setRemovePercentage(50)">50%</button>
            <button class="percentage-btn" onclick="setRemovePercentage(75)">75%</button>
            <button class="percentage-btn selected" onclick="setRemovePercentage(100)">100%</button>
          </div>
          <div class="percentage-slider-row">
            <input type="range" min="1" max="100" value="100" class="percentage-slider" id="remove-percentage-slider" oninput="onRemoveSliderChange(this.value)">
            <span class="percentage-value" id="remove-percentage-value">100%</span>
          </div>
        </div>

        <div class="remove-output-preview">
          <div class="remove-output-label">You will receive (estimated)</div>
          <div class="remove-output-row">
            <span id="remove-output-token0">-- PAGE</span>
          </div>
          <div class="remove-output-row">
            <span id="remove-output-token1">-- ARBME</span>
          </div>
        </div>

        <div id="remove-approval-section" style="margin-bottom: 1rem;">
          <div class="approval-row">
            <span>LP Token</span>
            <div class="approval-status">
              <span class="approval-check pending" id="remove-lp-approval-check">?</span>
              <span id="remove-lp-approval-text">Checking...</span>
            </div>
          </div>
        </div>

        <div class="modal-actions">
          <button class="modal-btn primary" id="remove-approve-btn" style="display: none;" onclick="approveRemoveLiquidity()">Approve LP Token</button>
          <button class="modal-btn danger" id="remove-liquidity-btn" onclick="executeRemoveLiquidity()">Remove Liquidity</button>
          <button class="modal-btn secondary" onclick="closeRemoveModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- V3 Remove Liquidity Modal -->
  <div class="modal-overlay" id="v3-remove-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title">Remove V3 Liquidity</span>
        <button class="modal-close" onclick="closeV3RemoveModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="v3-remove-tx-status" class="tx-status"></div>

        <div class="remove-pool-info">
          <div class="remove-pool-pair" id="v3-remove-pair">WETH / ARBME</div>
          <div class="remove-pool-balance">
            <span>Position ID:</span>
            <span id="v3-remove-token-id">#--</span>
          </div>
          <div class="remove-pool-balance">
            <span>Fee Tier:</span>
            <span id="v3-remove-fee">--%</span>
          </div>
        </div>

        <div class="v3-position-amounts">
          <div class="v3-amount-row">
            <span class="v3-amount-label" id="v3-remove-token0-label">Token 0</span>
            <span class="v3-amount-value" id="v3-remove-token0-amount">--</span>
          </div>
          <div class="v3-amount-row">
            <span class="v3-amount-label" id="v3-remove-token1-label">Token 1</span>
            <span class="v3-amount-value" id="v3-remove-token1-amount">--</span>
          </div>
        </div>

        <div class="percentage-selector">
          <div class="percentage-label">Amount to Remove</div>
          <div class="percentage-options">
            <button class="percentage-btn v3-pct" onclick="setV3RemovePercentage(25)">25%</button>
            <button class="percentage-btn v3-pct" onclick="setV3RemovePercentage(50)">50%</button>
            <button class="percentage-btn v3-pct" onclick="setV3RemovePercentage(75)">75%</button>
            <button class="percentage-btn v3-pct selected" onclick="setV3RemovePercentage(100)">100%</button>
          </div>
          <div class="percentage-slider-row">
            <input type="range" min="1" max="100" value="100" class="percentage-slider" id="v3-remove-percentage-slider" oninput="onV3RemoveSliderChange(this.value)">
            <span class="percentage-value" id="v3-remove-percentage-value">100%</span>
          </div>
        </div>

        <div class="remove-output-preview">
          <div class="remove-output-label">You will receive (estimated)</div>
          <div class="remove-output-row">
            <span id="v3-remove-output-token0">-- TOKEN0</span>
          </div>
          <div class="remove-output-row">
            <span id="v3-remove-output-token1">-- TOKEN1</span>
          </div>
        </div>

        <div class="modal-actions">
          <button class="modal-btn danger" id="v3-remove-btn" onclick="executeV3RemoveLiquidity()">Remove Liquidity</button>
          <button class="modal-btn secondary" onclick="closeV3RemoveModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- V4 Remove Liquidity Modal -->
  <div class="modal-overlay" id="v4-remove-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title">Remove V4 Liquidity</span>
        <button class="modal-close" onclick="closeV4RemoveModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="v4-remove-tx-status" class="tx-status"></div>

        <div class="remove-pool-info">
          <div class="remove-pool-pair" id="v4-remove-pair">WETH / ARBME</div>
          <div class="remove-pool-balance">
            <span>Position ID:</span>
            <span id="v4-remove-token-id">#--</span>
          </div>
          <div class="remove-pool-balance">
            <span>Fee Tier:</span>
            <span id="v4-remove-fee">--%</span>
          </div>
        </div>

        <div class="v3-position-amounts">
          <div class="v3-amount-row">
            <span class="v3-amount-label" id="v4-remove-token0-label">Token 0</span>
            <span class="v3-amount-value" id="v4-remove-token0-amount">--</span>
          </div>
          <div class="v3-amount-row">
            <span class="v3-amount-label" id="v4-remove-token1-label">Token 1</span>
            <span class="v3-amount-value" id="v4-remove-token1-amount">--</span>
          </div>
        </div>

        <div class="percentage-selector">
          <div class="percentage-label">Amount to Remove</div>
          <div class="percentage-options">
            <button class="percentage-btn v4-pct" onclick="setV4RemovePercentage(25)">25%</button>
            <button class="percentage-btn v4-pct" onclick="setV4RemovePercentage(50)">50%</button>
            <button class="percentage-btn v4-pct" onclick="setV4RemovePercentage(75)">75%</button>
            <button class="percentage-btn v4-pct selected" onclick="setV4RemovePercentage(100)">100%</button>
          </div>
          <div class="percentage-slider-row">
            <input type="range" min="1" max="100" value="100" class="percentage-slider" id="v4-remove-percentage-slider" oninput="onV4RemoveSliderChange(this.value)">
            <span class="percentage-value" id="v4-remove-percentage-value">100%</span>
          </div>
        </div>

        <div class="remove-output-preview">
          <div class="remove-output-label">You will receive (estimated)</div>
          <div class="remove-output-row">
            <span id="v4-remove-output-token0">-- TOKEN0</span>
          </div>
          <div class="remove-output-row">
            <span id="v4-remove-output-token1">-- TOKEN1</span>
          </div>
        </div>

        <div class="modal-actions">
          <button class="modal-btn danger" id="v4-remove-btn" onclick="executeV4RemoveLiquidity()">Remove Liquidity</button>
          <button class="modal-btn secondary" onclick="closeV4RemoveModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- V3 Add Liquidity Modal -->
  <div class="modal-overlay" id="v3-add-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title" id="v3-add-title">Add V3 Liquidity</span>
        <button class="modal-close" onclick="closeV3AddModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="v3-add-tx-status" class="tx-status"></div>

        <!-- Fee tier selector - hidden when adding to existing pool -->
        <div class="selector-group" id="v3-fee-selector-group" style="display: none;">
          <div class="selector-label">Fee Tier</div>
          <div class="selector-options" id="v3-fee-selector">
            <div class="selector-option" data-fee="100">
              <span class="version-badge">0.01%</span>
              <span>Stable</span>
            </div>
            <div class="selector-option" data-fee="500">
              <span class="version-badge">0.05%</span>
              <span>Low</span>
            </div>
            <div class="selector-option selected" data-fee="3000">
              <span class="version-badge">0.3%</span>
              <span>Standard</span>
            </div>
            <div class="selector-option" data-fee="10000">
              <span class="version-badge">1%</span>
              <span>Exotic</span>
            </div>
            <div class="selector-option" data-fee="30000">
              <span class="version-badge">3%</span>
              <span>High</span>
            </div>
            <div class="selector-option" data-fee="50000">
              <span class="version-badge">5%</span>
              <span>Very High</span>
            </div>
            <div class="selector-option" data-fee="100000">
              <span class="version-badge">10%</span>
              <span>Extreme</span>
            </div>
            <div class="selector-option" data-fee="250000">
              <span class="version-badge">25%</span>
              <span>Max</span>
            </div>
            <div class="selector-option" data-fee="500000">
              <span class="version-badge">50%</span>
              <span>Ultra</span>
            </div>
          </div>
        </div>

        <!-- Fee tier display - shown when fee is locked (existing pool) -->
        <div class="input-group" id="v3-fee-display" style="display: none;">
          <div class="input-label">
            <span>Pool Fee Tier</span>
          </div>
          <div class="input-wrapper" style="background: rgba(236, 72, 153, 0.1); border-color: rgba(236, 72, 153, 0.3);">
            <span id="v3-fee-display-value" style="color: #f472b6; font-weight: 600;">0.3%</span>
          </div>
        </div>

        <div class="input-group">
          <div class="input-label">
            <span id="v3-add-token0-label">Token 0 Amount</span>
            <span class="input-balance" id="v3-add-token0-balance" onclick="setV3MaxToken0()">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="v3-add-token0-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="v3-add-token0-icon" src="" alt="">
              <span id="v3-add-token0-symbol">TOKEN0</span>
            </div>
          </div>
        </div>

        <div class="input-group">
          <div class="input-label">
            <span id="v3-add-token1-label">Token 1 Amount</span>
            <span class="input-balance" id="v3-add-token1-balance" onclick="setV3MaxToken1()">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="v3-add-token1-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="v3-add-token1-icon" src="" alt="">
              <span id="v3-add-token1-symbol">TOKEN1</span>
            </div>
          </div>
        </div>

        <div id="v3-add-approval-section" style="margin-bottom: 1rem;">
          <div class="approval-row">
            <span id="v3-add-token0-symbol-approval">Token 0</span>
            <div class="approval-status">
              <span class="approval-check pending" id="v3-add-token0-approval-check">?</span>
              <span id="v3-add-token0-approval-text">Checking...</span>
            </div>
          </div>
          <div class="approval-row">
            <span id="v3-add-token1-symbol-approval">Token 1</span>
            <div class="approval-status">
              <span class="approval-check pending" id="v3-add-token1-approval-check">?</span>
              <span id="v3-add-token1-approval-text">Checking...</span>
            </div>
          </div>
        </div>

        <div class="modal-actions">
          <button class="modal-btn primary" id="v3-add-approve-btn" style="display: none;" onclick="approveV3Tokens()">Approve Tokens</button>
          <button class="modal-btn primary" id="v3-add-liquidity-btn" onclick="executeV3AddLiquidity()">Add Liquidity</button>
          <button class="modal-btn secondary" onclick="closeV3AddModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- V4 Add Liquidity Modal -->
  <div class="modal-overlay" id="v4-add-modal">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title" id="v4-add-title">Add V4 Liquidity</span>
        <button class="modal-close" onclick="closeV4AddModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="v4-add-tx-status" class="tx-status"></div>

        <!-- Fee tier selector - hidden when adding to existing pool -->
        <div class="selector-group" id="v4-fee-selector-group" style="display: none;">
          <div class="selector-label">Fee Tier</div>
          <div class="selector-options" id="v4-fee-selector">
            <div class="selector-option" data-fee="100">
              <span class="version-badge">0.01%</span>
              <span>Stable</span>
            </div>
            <div class="selector-option" data-fee="500">
              <span class="version-badge">0.05%</span>
              <span>Low</span>
            </div>
            <div class="selector-option selected" data-fee="3000">
              <span class="version-badge">0.3%</span>
              <span>Standard</span>
            </div>
            <div class="selector-option" data-fee="10000">
              <span class="version-badge">1%</span>
              <span>Exotic</span>
            </div>
            <div class="selector-option" data-fee="30000">
              <span class="version-badge">3%</span>
              <span>High</span>
            </div>
            <div class="selector-option" data-fee="50000">
              <span class="version-badge">5%</span>
              <span>Very High</span>
            </div>
            <div class="selector-option" data-fee="100000">
              <span class="version-badge">10%</span>
              <span>Extreme</span>
            </div>
            <div class="selector-option" data-fee="250000">
              <span class="version-badge">25%</span>
              <span>Max</span>
            </div>
            <div class="selector-option" data-fee="500000">
              <span class="version-badge">50%</span>
              <span>Ultra</span>
            </div>
          </div>
        </div>

        <!-- Fee tier display - shown when fee is locked (existing pool) -->
        <div class="input-group" id="v4-fee-display" style="display: none;">
          <div class="input-label">
            <span>Pool Fee Tier</span>
          </div>
          <div class="input-wrapper" style="background: rgba(139, 92, 246, 0.1); border-color: rgba(139, 92, 246, 0.3);">
            <span id="v4-fee-display-value" style="color: #a78bfa; font-weight: 600;">1%</span>
          </div>
        </div>

        <div class="input-group">
          <div class="input-label">
            <span id="v4-add-token0-label">Token 0 Amount</span>
            <span class="input-balance" id="v4-add-token0-balance" onclick="setV4MaxToken0()">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="v4-add-token0-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="v4-add-token0-icon" src="" alt="">
              <span id="v4-add-token0-symbol">TOKEN0</span>
            </div>
          </div>
        </div>

        <div class="input-group">
          <div class="input-label">
            <span id="v4-add-token1-label">Token 1 Amount</span>
            <span class="input-balance" id="v4-add-token1-balance" onclick="setV4MaxToken1()">Balance: --</span>
          </div>
          <div class="input-wrapper">
            <input type="number" class="amount-input" id="v4-add-token1-input" placeholder="0.0" step="any">
            <div class="input-token">
              <img id="v4-add-token1-icon" src="" alt="">
              <span id="v4-add-token1-symbol">TOKEN1</span>
            </div>
          </div>
        </div>

        <div id="v4-add-approval-section" style="margin-bottom: 1rem;">
          <div class="approval-row">
            <span id="v4-add-token0-symbol-approval">Token 0</span>
            <div class="approval-status">
              <span class="approval-check pending" id="v4-add-token0-approval-check">?</span>
              <span id="v4-add-token0-approval-text">Checking...</span>
            </div>
          </div>
          <div class="approval-row">
            <span id="v4-add-token1-symbol-approval">Token 1</span>
            <div class="approval-status">
              <span class="approval-check pending" id="v4-add-token1-approval-check">?</span>
              <span id="v4-add-token1-approval-text">Checking...</span>
            </div>
          </div>
        </div>

        <div class="modal-actions">
          <button class="modal-btn primary" id="v4-add-approve-btn" style="display: none;" onclick="approveV4Tokens()">Approve Tokens</button>
          <button class="modal-btn primary" id="v4-add-liquidity-btn" onclick="executeV4AddLiquidity()">Add Liquidity</button>
          <button class="modal-btn secondary" onclick="closeV4AddModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Confirmation Modal for Pool Creation -->
  <div class="confirm-modal-overlay" id="create-confirm-modal">
    <div class="confirm-modal">
      <div class="confirm-modal-header">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
        </svg>
        <span class="confirm-modal-title">Confirm Pool Creation</span>
      </div>
      <div class="confirm-modal-body">
        <div class="confirm-summary">
          <div class="confirm-summary-label">You are about to create a pool with:</div>
          <div class="confirm-token-row">
            <span class="confirm-token-amount" id="confirm-tokenA-amount">-- TOKEN</span>
            <span class="confirm-token-value" id="confirm-tokenA-value">(~$--)</span>
          </div>
          <div class="confirm-token-row">
            <span class="confirm-token-amount" id="confirm-tokenB-amount">-- TOKEN</span>
            <span class="confirm-token-value" id="confirm-tokenB-value">(~$--)</span>
          </div>
          <div class="confirm-price-info" id="confirm-price-info">
            Initial price: 1 TOKEN = -- TOKEN
          </div>
          <div class="confirm-decimals-info" id="confirm-decimals-info" style="font-size: 0.7rem; color: var(--text-secondary, #888); margin-top: 0.5rem;">
            Decimals: -- / --
          </div>
        </div>

        <label class="confirm-checkbox-container" for="confirm-risk-checkbox">
          <input type="checkbox" class="confirm-checkbox" id="confirm-risk-checkbox">
          <span class="confirm-checkbox-label">I understand that if I place unequal dollar amounts of these tokens into this pool, I may lose money to arbitrage.</span>
        </label>

        <div class="confirm-modal-actions">
          <button class="confirm-modal-btn cancel" onclick="closeCreateConfirmationModal()">Cancel</button>
          <button class="confirm-modal-btn proceed" id="confirm-create-btn" disabled onclick="proceedWithPoolCreation()">Create Pool</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    import { ethers } from 'https://esm.sh/ethers@6.11.1';

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P3.19: JSDoc Type Definitions
     * Type definitions for complex objects used throughout the app.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * @typedef {Object} TokenInfo
     * @property {string} address - Token contract address
     * @property {string} symbol - Token symbol (e.g., "USDC")
     * @property {number} decimals - Token decimals (e.g., 6, 18)
     * @property {string|null} icon - Icon URL or null
     * @property {number} priceUsd - USD price
     * @property {boolean} [decimalsVerified] - Whether decimals were verified on-chain
     */

    /**
     * @typedef {Object} PoolInfo
     * @property {string} address - Pool contract address
     * @property {string} token0 - Token0 address
     * @property {string} token1 - Token1 address
     * @property {string} token0Symbol - Token0 symbol
     * @property {string} token1Symbol - Token1 symbol
     * @property {number} token0Decimals - Token0 decimals
     * @property {number} token1Decimals - Token1 decimals
     * @property {number} [fee] - Fee tier in basis points (V3/V4)
     * @property {number} [tickSpacing] - Tick spacing (V4)
     * @property {string} [hooks] - Hooks address (V4)
     */

    /**
     * @typedef {Object} V3Position
     * @property {number} tokenId - NFT token ID
     * @property {string} token0 - Token0 symbol
     * @property {string} token1 - Token1 symbol
     * @property {string} token0Address - Token0 address
     * @property {string} token1Address - Token1 address
     * @property {string} liquidity - Liquidity amount as string
     * @property {number} fee - Fee tier
     * @property {number} tickLower - Lower tick
     * @property {number} tickUpper - Upper tick
     * @property {number} token0Amount - Token0 amount
     * @property {number} token1Amount - Token1 amount
     * @property {boolean} inRange - Whether position is in range
     */

    /**
     * @typedef {Object} V4Position
     * @property {number} tokenId - NFT token ID
     * @property {string} currency0 - Currency0 address
     * @property {string} currency1 - Currency1 address
     * @property {string} liquidity - Liquidity amount as string
     * @property {number} fee - Fee tier
     * @property {number} tickSpacing - Tick spacing
     * @property {string} hooks - Hooks address
     * @property {number} tickLower - Lower tick
     * @property {number} tickUpper - Upper tick
     */

    /**
     * @typedef {Object} ModalPoolState
     * @property {string|null} pool - Pool address or null
     * @property {number} token0Balance - Token0 balance
     * @property {number} token1Balance - Token1 balance
     * @property {boolean} token0Approved - Token0 approval status
     * @property {boolean} token1Approved - Token1 approval status
     */

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P3.17: Centralized Application State
     * Groups all state variables into a single AppState object to prevent
     * window scope pollution and provide clear state organization.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /** @type {{ core: Object, v2Modal: ModalPoolState, createModal: Object, removeModal: Object, v3Remove: Object, v4Remove: Object, v3Add: ModalPoolState, v4Add: ModalPoolState }} */
    const AppState = {
      // Core app state
      core: {
        connectedWallet: null,
        poolsData: null,
        showAllPools: false,
        positionsExpanded: true,
      },

      // V2 Modal state (add liquidity)
      v2Modal: {
        pool: null,
        token0Balance: 0,
        token1Balance: 0,
        token0Approved: false,
        token1Approved: false,
      },

      // Create position modal state
      createModal: {
        tokenA: {
          address: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913',
          symbol: 'USDC',
          decimals: 6,
          icon: 'https://assets.coingecko.com/coins/images/6319/small/usdc.png',
          priceUsd: 1,
          decimalsVerified: true,
        },
        tokenB: {
          address: '0xC647421C5Dc78D1c3960faA7A33f9aEFDF4B7B07',
          symbol: 'ARBME',
          decimals: 18,
          icon: 'https://arbme.epicdylan.com/arbie.png',
          priceUsd: 0,
          decimalsVerified: true,
        },
        selectedVersion: 'v2',
        selectedFee: 3000,
        tokenABalance: 0,
        tokenBBalance: 0,
        isAutoBalancing: false,
      },

      // Remove liquidity modal state (V2)
      removeModal: {
        pool: null,
        lpBalance: 0,
        lpBalanceRaw: BigInt(0),
        percentage: 100,
        lpApproved: false,
        estimatedToken0: 0,
        estimatedToken1: 0,
      },

      // V3 Remove liquidity state
      v3Remove: {
        position: null,
        percentage: 100,
      },

      // V4 Remove liquidity state
      v4Remove: {
        position: null,
        percentage: 100,
      },

      // V3 Add liquidity modal state
      v3Add: {
        pool: null,
        token0Balance: 0,
        token1Balance: 0,
        token0Approved: false,
        token1Approved: false,
        selectedFee: 3000,
        token0Price: 0,
        token1Price: 0,
        poolPriceRatio: 0,
        isAutoBalancing: false,
      },

      // V4 Add liquidity modal state
      v4Add: {
        pool: null,
        token0Balance: 0,
        token1Balance: 0,
        token0Approved: false,
        token1Approved: false,
        selectedFee: 3000,
        token0Price: 0,
        token1Price: 0,
        poolPriceRatio: 0,
        isAutoBalancing: false,
      },

      // Reset methods for modal cleanup
      resetV2Modal() {
        this.v2Modal.pool = null;
        this.v2Modal.token0Balance = 0;
        this.v2Modal.token1Balance = 0;
        this.v2Modal.token0Approved = false;
        this.v2Modal.token1Approved = false;
      },
      resetRemoveModal() {
        this.removeModal.pool = null;
        this.removeModal.lpBalance = 0;
        this.removeModal.lpBalanceRaw = BigInt(0);
        this.removeModal.percentage = 100;
        this.removeModal.lpApproved = false;
      },
      resetV3Add() {
        this.v3Add.pool = null;
        this.v3Add.token0Balance = 0;
        this.v3Add.token1Balance = 0;
        this.v3Add.token0Approved = false;
        this.v3Add.token1Approved = false;
        this.v3Add.poolPriceRatio = 0;
      },
      resetV4Add() {
        this.v4Add.pool = null;
        this.v4Add.token0Balance = 0;
        this.v4Add.token1Balance = 0;
        this.v4Add.token0Approved = false;
        this.v4Add.token1Approved = false;
        this.v4Add.poolPriceRatio = 0;
      },
    };

    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    // Legacy variable aliases for backwards compatibility
    // These reference AppState properties to allow gradual migration
    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    let connectedWallet = null;  // Alias: AppState.core.connectedWallet
    let poolsData = null;        // Alias: AppState.core.poolsData
    let showAllPools = false;
    let positionsExpanded = true;
    const POOLS_PREVIEW_COUNT = 3;

    // Constants (not state)
    const ARBME_ADDRESS = '0xC647421C5Dc78D1c3960faA7A33f9aEFDF4B7B07';
    const PAGE_ADDRESS = '0xc4730f86d1F86cE0712a7b17EE919Db7dEFad7FE';
    const PAGE_ARBME_POOL = '0x11FD4947bE07E721B57622df3ef1E1C773ED5655';
    const V2_ROUTER = '0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24';
    const BASE_CHAIN_ID = 8453;
    const MAX_UINT256 = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';

    // Modal state aliases (V2 add liquidity)
    let modalPool = null;
    let token0Balance = 0;
    let token1Balance = 0;
    let token0Approved = false;
    let token1Approved = false;

    // Create position modal state aliases
    let createTokenA = AppState.createModal.tokenA;
    let createTokenB = AppState.createModal.tokenB;
    let createSelectedVersion = 'v2';
    let createSelectedFee = 3000;
    let createTokenABalance = 0;
    let createTokenBBalance = 0;
    let isAutoBalancing = false;

    // Remove liquidity modal state aliases
    let removePool = null;
    let removeLpBalance = 0;
    let removeLpBalanceRaw = BigInt(0);
    let removePercentage = 100;
    let removeLpApproved = false;
    let removeEstimatedToken0 = 0;
    let removeEstimatedToken1 = 0;

    // V3 Remove liquidity modal state aliases
    let v3RemovePosition = null;
    let v3RemovePercentage = 100;

    // V4 Remove liquidity modal state aliases
    let v4RemovePosition = null;
    let v4RemovePercentage = 100;

    // V3 Add liquidity modal state aliases
    let v3AddPool = null;
    let v3AddToken0Balance = 0;
    let v3AddToken1Balance = 0;
    let v3AddToken0Approved = false;
    let v3AddToken1Approved = false;
    let v3AddSelectedFee = 3000;
    let v3AddToken0Price = 0;
    let v3AddToken1Price = 0;
    let v3AddPoolPriceRatio = 0;
    let v3AddIsAutoBalancing = false;
    const V3_POSITION_MANAGER_JS = '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1';

    // V4 Add liquidity modal state aliases
    let v4AddPool = null;
    let v4AddToken0Balance = 0;
    let v4AddToken1Balance = 0;
    let v4AddToken0Approved = false;
    let v4AddToken1Approved = false;
    let v4AddSelectedFee = 3000;
    let v4AddToken0Price = 0;
    let v4AddToken1Price = 0;
    let v4AddPoolPriceRatio = 0;
    let v4AddIsAutoBalancing = false;
    const V4_POSITION_MANAGER_JS = '0x7c5f5a4bbd8fd63184577525326123b519429bdc';
    const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';

    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    // TOKEN METADATA - Injected from backend single source of truth
    // All token data (decimals, icons, colors) comes from here
    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    const TOKEN_METADATA = ${JSON.stringify(TOKEN_METADATA, null, 2)};

    // Build lookup tables from the single source of truth
    const TOKEN_BY_ADDRESS = Object.fromEntries(
      Object.values(TOKEN_METADATA).map(t => [t.address.toLowerCase(), t])
    );

    // KNOWN_TOKENS for backwards compatibility
    const KNOWN_TOKENS = Object.fromEntries(
      Object.entries(TOKEN_METADATA).map(([symbol, data]) => [
        symbol, { address: data.address, decimals: data.decimals }
      ])
    );

    function getTokenAddressFromSymbol(symbol) {
      const token = TOKEN_METADATA[symbol.toUpperCase()];
      return token ? token.address : null;
    }

    function getTokenDecimalsFromSymbol(symbol) {
      const token = TOKEN_METADATA[symbol.toUpperCase()];
      return token ? token.decimals : null; // Return null, not 18!
    }

    function getTokenDecimalsByAddress(address) {
      if (!address) return null;
      const token = TOKEN_BY_ADDRESS[address.toLowerCase()];
      if (token) return token.decimals;
      console.warn('[ArbMe] Unknown token decimals for:', address);
      return null; // Return null, not 18 - caller must handle!
    }

    // Safe decimal getter that logs warnings
    function getSafeDecimals(address, fallbackDecimals = null) {
      const decimals = getTokenDecimalsByAddress(address);
      if (decimals === null) {
        console.warn('[ArbMe] No decimals found for', address, '- using fallback:', fallbackDecimals);
        return fallbackDecimals;
      }
      return decimals;
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P1.5: Token Address Validation
     * Validates that an address is a valid Ethereum address format.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */
    const ETHEREUM_ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/;

    /**
     * Check if a string is a valid Ethereum address format.
     * @param address - The address to validate
     * @returns true if valid format, false otherwise
     */
    function isValidAddress(address) {
      if (!address || typeof address !== 'string') return false;
      return ETHEREUM_ADDRESS_REGEX.test(address);
    }

    /**
     * Validate and normalize an Ethereum address.
     * @param address - The address to validate
     * @returns { valid: boolean, normalized: string|null, error: string|null }
     */
    function validateTokenAddress(address) {
      if (!address || typeof address !== 'string') {
        return { valid: false, normalized: null, error: 'Address is required' };
      }

      const trimmed = address.trim();
      if (trimmed === '') {
        return { valid: false, normalized: null, error: 'Address is required' };
      }

      if (!trimmed.startsWith('0x')) {
        return { valid: false, normalized: null, error: 'Address must start with 0x' };
      }

      if (trimmed.length !== 42) {
        return { valid: false, normalized: null, error: 'Address must be 42 characters (0x + 40 hex chars)' };
      }

      if (!ETHEREUM_ADDRESS_REGEX.test(trimmed)) {
        return { valid: false, normalized: null, error: 'Address contains invalid characters' };
      }

      // Normalize to lowercase
      return { valid: true, normalized: trimmed.toLowerCase(), error: null };
    }

    /**
     * Safely parse decimals from various input types.
     * Handles: number, hex string ("0x12"), decimal string ("18"), null, undefined
     * @returns Parsed decimals (0-24 range) or null if invalid
     */
    function toSafeDecimals(val) {
      if (val === null || val === undefined) return null;

      if (typeof val === 'number') {
        if (!Number.isFinite(val) || val < 0 || val > 24 || !Number.isInteger(val)) {
          return null;
        }
        return val;
      }

      if (typeof val === 'string') {
        const trimmed = val.trim();
        if (trimmed === '') return null;

        let parsed;
        if (trimmed.toLowerCase().startsWith('0x')) {
          parsed = parseInt(trimmed, 16);
        } else {
          parsed = parseInt(trimmed, 10);
        }

        if (!Number.isFinite(parsed) || Number.isNaN(parsed) || parsed < 0 || parsed > 24) {
          return null;
        }
        return parsed;
      }

      return null;
    }

    /**
     * Convert raw token amount to human-readable number.
     * @param raw - Raw amount (BigInt, number, or hex string)
     * @param decimals - Token decimals
     * @returns Human-readable number
     */
    function formatFromRaw(raw, decimals) {
      if (raw === null || raw === undefined) return 0;
      // CRITICAL: null check before numeric comparison (null < 0 is false!)
      if (decimals === null || decimals === undefined || decimals < 0 || decimals > 24) return 0;
      try {
        let rawNum;
        if (typeof raw === 'bigint') {
          rawNum = Number(raw);
        } else if (typeof raw === 'number') {
          rawNum = raw;
        } else if (typeof raw === 'string') {
          if (raw.toLowerCase().startsWith('0x')) {
            rawNum = Number(BigInt(raw));
          } else {
            rawNum = Number(raw);
          }
        } else {
          return 0;
        }
        if (!Number.isFinite(rawNum)) return 0;
        return rawNum / Math.pow(10, decimals);
      } catch {
        return 0;
      }
    }

    /**
     * Convert human-readable amount to raw token amount (BigInt).
     * @param amount - Human-readable amount
     * @param decimals - Token decimals
     * @returns Raw amount as BigInt
     */
    function toRawAmount(amount, decimals) {
      if (amount === null || amount === undefined) return BigInt(0);
      // CRITICAL: null check before numeric comparison (null < 0 is false!)
      if (decimals === null || decimals === undefined || decimals < 0 || decimals > 24) return BigInt(0);
      try {
        const amountNum = typeof amount === 'string' ? parseFloat(amount) : amount;
        if (!Number.isFinite(amountNum) || amountNum < 0) return BigInt(0);
        return BigInt(Math.floor(amountNum * Math.pow(10, decimals)));
      } catch {
        return BigInt(0);
      }
    }

    /**
     * Convert human-readable amount to raw with buffer multiplier.
     * @param amount - Human-readable amount
     * @param decimals - Token decimals
     * @param buffer - Multiplier (e.g., 1.1 for 10% extra)
     */
    function toRawAmountWithBuffer(amount, decimals, buffer = 1.0) {
      if (buffer <= 0) buffer = 1.0;
      const amountNum = typeof amount === 'string' ? parseFloat(amount) : amount;
      if (!Number.isFinite(amountNum)) return BigInt(0);
      return toRawAmount(amountNum * buffer, decimals);
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P1.6: Amount Input Validation
     * Validates that amounts are within safe bounds.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */
    const AMOUNT_VALIDATION = {
      MIN_AMOUNT: 0.000001,         // Minimum meaningful amount (dust threshold)
      MAX_AMOUNT: 1e15,             // Max amount to prevent overflow (quadrillion)
      MAX_RAW_UINT256: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),
    };

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P1.7: Standardized Buffer/Slippage Constants
     * Used consistently across all liquidity operations.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */
    const TX_CONSTANTS = {
      // Approval buffer: Approve 10% more than needed to handle rounding and small price changes
      // This prevents "insufficient allowance" errors due to fee calculations or price movement
      APPROVAL_BUFFER: 1.10,
      APPROVAL_BUFFER_BPS: BigInt(110),  // For BigInt math: amount * 110n / 100n
      APPROVAL_DIVISOR: BigInt(100),

      // Slippage tolerance: Accept 5% less than expected output
      // Protects against front-running while allowing normal price movement
      SLIPPAGE_TOLERANCE: 0.05,
      SLIPPAGE_MULTIPLIER: 0.95,         // 1 - SLIPPAGE_TOLERANCE
      SLIPPAGE_NUMERATOR: BigInt(95),    // For BigInt math: amount * 95n / 100n
      SLIPPAGE_DIVISOR: BigInt(100),

      // Transaction deadline: 20 minutes from now
      DEADLINE_SECONDS: 1200,

      // Gas limits by operation type (hex strings for eth_sendTransaction)
      GAS_LIMITS: {
        APPROVE: '0x15F90',           // 90,000 - ERC20 approve
        SIMPLE_TRANSFER: '0x5208',    // 21,000 - ETH transfer
        ADD_LIQUIDITY_V2: '0x7A120',  // 500,000 - V2 add liquidity
        ADD_LIQUIDITY_V3: '0x7A120',  // 500,000 - V3 add liquidity
        ADD_LIQUIDITY_V4: '0x7A120',  // 500,000 - V4 add to existing
        CREATE_POOL_V4: '0xF4240',    // 1,000,000 - V4 new pool creation
        REMOVE_LIQUIDITY_V2: '0x7A120', // 500,000 - V2 remove liquidity
        REMOVE_LIQUIDITY_V3: '0x61A80', // 400,000 - V3 remove liquidity
        REMOVE_LIQUIDITY_V4: '0x61A80', // 400,000 - V4 remove liquidity
        COLLECT_FEES: '0x30D40',      // 200,000 - V3/V4 collect fees
      },

      // Cache settings
      CACHE_TTL_MS: 60000,           // 60 seconds for price cache
      BALANCE_CACHE_TTL_MS: 30000,   // 30 seconds for balance cache
      TOKEN_INFO_CACHE_TTL_MS: 120000, // 120 seconds for token info (rarely changes)
    };

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P4.25: Token Info Cache
     * Caches token info fetched from RPC to avoid redundant calls.
     * Token info (decimals, symbol) rarely changes so we cache for 2 mins.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */
    const tokenInfoCache = new Map(); // address -> { data, timestamp }

    /**
     * Fetch token info with caching.
     * @param {string} address - Token address
     * @returns {Promise<Object|null>} Token info or null on failure
     */
    async function fetchTokenInfoCached(address) {
      if (!address) return null;
      const normalizedAddr = address.toLowerCase();

      // Check cache first
      const cached = tokenInfoCache.get(normalizedAddr);
      const now = Date.now();
      if (cached && (now - cached.timestamp) < TX_CONSTANTS.TOKEN_INFO_CACHE_TTL_MS) {
        return cached.data;
      }

      // Fetch from RPC
      try {
        const res = await fetch('/test/rpc?action=tokenInfo&token=' + address);
        const data = await res.json();
        if (data && !data.error) {
          tokenInfoCache.set(normalizedAddr, { data, timestamp: now });
          return data;
        }
        return null;
      } catch (e) {
        console.warn('[ArbMe] Failed to fetch token info for', address, e);
        return null;
      }
    }

    /**
     * Clear token info cache. Call on wallet change or when data may be stale.
     */
    function clearTokenInfoCache() {
      tokenInfoCache.clear();
      console.log('[ArbMe] Token info cache cleared');
    }

    // Helper functions for consistent buffer/slippage application
    function applyApprovalBuffer(amount) {
      if (typeof amount === 'bigint') {
        return (amount * TX_CONSTANTS.APPROVAL_BUFFER_BPS) / TX_CONSTANTS.APPROVAL_DIVISOR;
      }
      return amount * TX_CONSTANTS.APPROVAL_BUFFER;
    }

    function applySlippage(amount) {
      if (typeof amount === 'bigint') {
        return (amount * TX_CONSTANTS.SLIPPAGE_NUMERATOR) / TX_CONSTANTS.SLIPPAGE_DIVISOR;
      }
      return amount * TX_CONSTANTS.SLIPPAGE_MULTIPLIER;
    }

    function getDeadline() {
      return Math.floor(Date.now() / 1000) + TX_CONSTANTS.DEADLINE_SECONDS;
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P2.11: Pool Price Calculation Utilities
     * Consolidates sqrtPriceX96 â price conversions used across V3/V4.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    // Core constants for sqrtPriceX96 math (avoid recomputing)
    const Q96 = BigInt(2) ** BigInt(96);              // 2^96 for sqrtPriceX96 scaling
    const Q192 = Q96 * Q96;                           // 2^192 for price scaling
    const PRICE_SCALE = BigInt(10) ** BigInt(18);     // 18 decimals for scaled integer math

    /**
     * Convert sqrtPriceX96 to raw price (token1/token0 in raw units).
     * This is the unscaled price ratio without decimal adjustment.
     *
     * @param sqrtPriceX96 - The square root price as BigInt or hex string
     * @returns Raw price as number (token1 per token0 in raw units)
     */
    function sqrtPriceX96ToRawPrice(sqrtPriceX96) {
      const sqrtP = typeof sqrtPriceX96 === 'bigint' ? sqrtPriceX96 : BigInt(sqrtPriceX96);
      if (sqrtP === BigInt(0)) return 0;

      // price = (sqrtPriceX96 / 2^96)^2
      const sqrtPrice = Number(sqrtP) / Number(Q96);
      return sqrtPrice * sqrtPrice;
    }

    /**
     * Convert sqrtPriceX96 to scaled price (for BigInt math without floating point).
     * Returns (sqrtPriceX96^2 * PRICE_SCALE) / Q192 as BigInt.
     *
     * @param sqrtPriceX96 - The square root price as BigInt or hex string
     * @returns Scaled price as BigInt (multiply by 10^-18 to get actual ratio)
     */
    function sqrtPriceX96ToScaledPrice(sqrtPriceX96) {
      const sqrtP = typeof sqrtPriceX96 === 'bigint' ? sqrtPriceX96 : BigInt(sqrtPriceX96);
      if (sqrtP === BigInt(0)) return BigInt(0);
      return (sqrtP * sqrtP * PRICE_SCALE) / Q192;
    }

    /**
     * Convert sqrtPriceX96 to human-readable price, adjusted for decimals.
     * price = rawPrice * 10^(decimals0 - decimals1)
     *
     * @param sqrtPriceX96 - The square root price as BigInt or hex string
     * @param decimals0 - Decimals of token0
     * @param decimals1 - Decimals of token1
     * @returns Human-readable price (token1 per token0 in human units)
     */
    function sqrtPriceX96ToPrice(sqrtPriceX96, decimals0, decimals1) {
      const rawPrice = sqrtPriceX96ToRawPrice(sqrtPriceX96);
      if (rawPrice === 0) return 0;

      // CRITICAL: null check for decimals to prevent NaN results
      if (decimals0 === null || decimals0 === undefined || decimals1 === null || decimals1 === undefined) {
        console.warn('[ArbMe] sqrtPriceX96ToPrice: Missing decimals, cannot calculate price');
        return 0;
      }

      // Adjust for decimal difference
      const decimalAdjust = Math.pow(10, decimals0 - decimals1);
      return rawPrice * decimalAdjust;
    }

    /**
     * Convert human-readable price to sqrtPriceX96.
     * sqrtPriceX96 = sqrt(price) * 2^96
     *
     * @param price - The price (token1 per token0 in raw units)
     * @returns sqrtPriceX96 as BigInt
     */
    function priceToSqrtPriceX96(price) {
      if (price <= 0) return BigInt(0);
      const sqrtPrice = Math.sqrt(price);
      return BigInt(Math.floor(sqrtPrice * Math.pow(2, 96)));
    }

    /**
     * Convert sqrtPriceX96 to tick.
     * tick = floor(log(price) / log(1.0001))
     *
     * @param sqrtPriceX96 - The square root price as BigInt, number, or hex string
     * @returns tick as integer
     */
    function sqrtPriceX96ToTick(sqrtPriceX96) {
      const sqrtP = typeof sqrtPriceX96 === 'bigint' ? sqrtPriceX96 :
                    typeof sqrtPriceX96 === 'number' ? BigInt(Math.floor(sqrtPriceX96)) :
                    BigInt(sqrtPriceX96);
      const sqrtPFloat = Number(sqrtP) / Math.pow(2, 96);
      return Math.floor(Math.log(sqrtPFloat * sqrtPFloat) / Math.log(1.0001));
    }

    /**
     * Convert tick to sqrtPriceX96.
     * sqrtPriceX96 = sqrt(1.0001^tick) * 2^96
     *
     * @param tick - The tick value
     * @returns sqrtPriceX96 as BigInt
     */
    function tickToSqrtPriceX96(tick) {
      const sqrtRatio = Math.sqrt(Math.pow(1.0001, tick));
      return BigInt(Math.floor(sqrtRatio * Math.pow(2, 96)));
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P2.12: Consolidated Approval Checking Utilities
     * Used by V2, V3, and V4 liquidity flows.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * Check token allowance for a specific spender.
     * @param wallet - User's wallet address
     * @param token - Token address to check
     * @param spender - Spender address (router/position manager/permit2)
     * @returns Promise<{ isApproved: boolean, allowance: string | null, error: string | null }>
     */
    async function checkTokenAllowance(wallet, token, spender) {
      if (!wallet || !token || !spender) {
        return { isApproved: false, allowance: null, error: 'Missing required parameters' };
      }

      try {
        const res = await fetch(\`/test/rpc?action=checkAllowance&wallet=\${wallet}&token=\${token}&spender=\${spender}\`);
        const data = await res.json();

        if (data.error) {
          console.error('[ArbMe] checkTokenAllowance error:', data.error);
          return { isApproved: false, allowance: null, error: data.error };
        }

        return {
          isApproved: data.isApproved || false,
          allowance: data.allowance || null,
          error: null
        };
      } catch (e) {
        console.error('[ArbMe] checkTokenAllowance fetch error:', e);
        return { isApproved: false, allowance: null, error: e.message || 'Network error' };
      }
    }

    /**
     * Check allowances for a token pair.
     * @param wallet - User's wallet address
     * @param token0 - First token address
     * @param token1 - Second token address
     * @param spender - Spender address
     * @returns Promise<{ token0Approved: boolean, token1Approved: boolean, error: string | null }>
     */
    async function checkPairAllowances(wallet, token0, token1, spender) {
      if (!wallet || !token0 || !token1 || !spender) {
        return { token0Approved: false, token1Approved: false, error: 'Missing required parameters' };
      }

      try {
        const [result0, result1] = await Promise.all([
          checkTokenAllowance(wallet, token0, spender),
          checkTokenAllowance(wallet, token1, spender)
        ]);

        // If either check had an error, report it but still return the approval statuses
        const error = result0.error || result1.error || null;

        return {
          token0Approved: result0.isApproved,
          token1Approved: result1.isApproved,
          allowance0: result0.allowance,
          allowance1: result1.allowance,
          error
        };
      } catch (e) {
        console.error('[ArbMe] checkPairAllowances error:', e);
        return { token0Approved: false, token1Approved: false, error: e.message || 'Unknown error' };
      }
    }

    /**
     * Update approval UI elements with consistent styling.
     * @param checkElement - The checkmark/icon element
     * @param textElement - The text element showing approval status
     * @param isApproved - Whether the token is approved
     */
    function updateApprovalElement(checkElement, textElement, isApproved) {
      if (!checkElement || !textElement) return;

      if (isApproved) {
        checkElement.className = 'approval-check approved';
        checkElement.textContent = 'â';
        textElement.textContent = 'Approved';
      } else {
        checkElement.className = 'approval-check pending';
        checkElement.textContent = '!';
        textElement.textContent = 'Needs approval';
      }
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P2.13: Position Processing Utilities
     * Common helpers for V3/V4 position calculations.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * Calculate pool share as a percentage.
     * @param positionLiquidity - Position's liquidity (BigInt or string)
     * @param totalLiquidity - Pool's total liquidity (BigInt or string)
     * @returns Pool share percentage (0-100)
     */
    function calculatePoolShare(positionLiquidity, totalLiquidity) {
      if (!positionLiquidity || !totalLiquidity) return 0;

      try {
        const posLiq = typeof positionLiquidity === 'bigint' ? positionLiquidity : BigInt(positionLiquidity);
        const totalLiq = typeof totalLiquidity === 'bigint' ? totalLiquidity : BigInt(totalLiquidity);

        if (totalLiq === BigInt(0)) return 0;

        // Use high precision to avoid truncation for small positions in large pools
        // Result is percentage * 100 (e.g., 1.5% = 1.5)
        return Number(posLiq * BigInt(10)**BigInt(18) / totalLiq) / Math.pow(10, 16);
      } catch (e) {
        console.error('[ArbMe] calculatePoolShare error:', e);
        return 0;
      }
    }

    /**
     * Check if position is in range based on current tick.
     * @param currentTick - Current pool tick
     * @param tickLower - Position's lower tick
     * @param tickUpper - Position's upper tick
     * @returns true if position is in range
     */
    function isPositionInRange(currentTick, tickLower, tickUpper) {
      return currentTick >= tickLower && currentTick < tickUpper;
    }

    /**
     * Parse raw token amount from position data.
     * @param rawAmount - Raw amount as string, BigInt, or hex
     * @param decimals - Token decimals
     * @returns Parsed amount as number
     */
    function parsePositionAmount(rawAmount, decimals) {
      if (!rawAmount) return 0;

      // CRITICAL: If decimals is null/undefined, we cannot safely format the amount
      // Math.pow(10, null) = 1, which would show raw values as if they were formatted!
      if (decimals === null || decimals === undefined) {
        console.warn('[ArbMe] parsePositionAmount: Missing decimals, returning 0');
        return 0;
      }

      try {
        const raw = typeof rawAmount === 'bigint' ? rawAmount : BigInt(rawAmount);
        return Number(raw) / Math.pow(10, decimals);
      } catch (e) {
        return 0;
      }
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P3.21: Address Comparison Utilities
     * Consistent address comparison and sorting.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * Compare two Ethereum addresses (case-insensitive).
     * @param a - First address
     * @param b - Second address
     * @returns -1 if a < b, 0 if equal, 1 if a > b
     */
    function compareAddresses(a, b) {
      if (!a || !b) return 0;
      const aLower = a.toLowerCase();
      const bLower = b.toLowerCase();
      if (aLower < bLower) return -1;
      if (aLower > bLower) return 1;
      return 0;
    }

    /**
     * Sort two addresses in ascending order (for pool key construction).
     * @param addr0 - First address
     * @param addr1 - Second address
     * @returns [lowerAddress, higherAddress]
     */
    function sortAddresses(addr0, addr1) {
      if (!addr0 || !addr1) return [addr0, addr1];
      return compareAddresses(addr0, addr1) <= 0
        ? [addr0, addr1]
        : [addr1, addr0];
    }

    /**
     * Check if address A comes before address B (for V3/V4 token ordering).
     * @param a - First address
     * @param b - Second address
     * @returns true if a < b (case-insensitive)
     */
    function isAddressLessThan(a, b) {
      return compareAddresses(a, b) < 0;
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P3.23: Fee Tier Validation Utilities
     * Validates fee tiers for V3/V4 pool operations.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    // Standard V3 fee tiers (in basis points)
    const V3_VALID_FEES = [100, 500, 3000, 10000];

    // Standard V4 fee tiers (V4 allows custom fees via hooks)
    const V4_VALID_FEES = [100, 500, 3000, 10000, 30000, 50000];

    // Maximum fee allowed (100% = 1,000,000 basis points)
    const MAX_FEE = 1000000;

    // Fee to tick spacing mapping (shared for V3/V4)
    const FEE_TICK_SPACINGS = {
      100: 1,
      500: 10,
      3000: 60,
      10000: 200,
      30000: 200,
      50000: 200,
    };

    /**
     * Validate fee tier for pool operations.
     * @param fee - Fee in basis points (e.g., 3000 = 0.30%)
     * @param version - 'v3' or 'v4'
     * @returns { valid: boolean, error?: string, tickSpacing?: number }
     */
    function validateFeeTier(fee, version = 'v4') {
      // Ensure fee is a number
      const feeNum = typeof fee === 'string' ? parseInt(fee, 10) : fee;

      if (!Number.isFinite(feeNum) || Number.isNaN(feeNum)) {
        return { valid: false, error: 'Fee must be a valid number' };
      }

      if (feeNum < 0) {
        return { valid: false, error: 'Fee cannot be negative' };
      }

      if (feeNum > MAX_FEE) {
        return { valid: false, error: 'Fee cannot exceed 100% (1000000 basis points)' };
      }

      // V3 has strict fee tiers
      if (version === 'v3' && !V3_VALID_FEES.includes(feeNum)) {
        return {
          valid: false,
          error: \`V3 only supports fees: \${V3_VALID_FEES.join(', ')} basis points\`
        };
      }

      // Get tick spacing (default 200 for custom fees)
      const tickSpacing = FEE_TICK_SPACINGS[feeNum] ?? 200;

      return { valid: true, tickSpacing };
    }

    /**
     * Get tick spacing for a fee tier.
     * @param fee - Fee in basis points
     * @returns Tick spacing (defaults to 200 for custom fees)
     */
    function getTickSpacingForFee(fee) {
      const feeNum = typeof fee === 'string' ? parseInt(fee, 10) : fee;
      return FEE_TICK_SPACINGS[feeNum] ?? 200;
    }

    /**
     * Format fee for display (e.g., 3000 â "0.30%")
     * @param fee - Fee in basis points
     * @returns Formatted string
     */
    function formatFeeTier(fee) {
      const feeNum = typeof fee === 'string' ? parseInt(fee, 10) : fee;
      if (!Number.isFinite(feeNum)) return '?%';
      const percent = feeNum / 10000;
      if (percent >= 1) return percent.toFixed(0) + '%';
      if (percent >= 0.1) return percent.toFixed(1) + '%';
      return percent.toFixed(2) + '%';
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P3.18: Error Handling Utilities
     * Consistent error classification and user-friendly messages.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    // Error type constants
    const ErrorType = {
      USER: 'user',           // User input error (fixable by user)
      NETWORK: 'network',     // Network/RPC error (retry may help)
      CONTRACT: 'contract',   // Smart contract revert (check params)
      WALLET: 'wallet',       // Wallet rejection or connection issue
      UNKNOWN: 'unknown',     // Unclassified error
    };

    // Common error patterns for classification
    const ERROR_PATTERNS = {
      // User errors
      userRejected: /user (rejected|denied|cancelled)/i,
      insufficientFunds: /insufficient funds/i,
      insufficientAllowance: /insufficient allowance/i,
      invalidAmount: /invalid (amount|value)/i,

      // Network errors
      networkError: /network|fetch|timeout|ECONNREFUSED|502|503|504/i,
      rpcError: /rpc|jsonrpc|eth_/i,
      rateLimited: /rate limit|too many requests|429/i,

      // Contract errors
      revert: /revert|execution reverted/i,
      outOfGas: /out of gas|gas required exceeds/i,
      nonce: /nonce|replacement transaction/i,

      // Wallet errors
      walletNotConnected: /wallet not connected|no provider/i,
      wrongNetwork: /wrong (chain|network)|chain.*mismatch/i,
    };

    /**
     * Classify an error into a type for appropriate handling.
     * @param error - Error object or string
     * @returns { type: ErrorType, message: string, retryable: boolean }
     */
    function classifyError(error) {
      const message = error?.message || error?.reason || String(error);
      const lowerMessage = message.toLowerCase();

      // Check for user rejection (not an error, just cancelled)
      if (ERROR_PATTERNS.userRejected.test(message)) {
        return { type: ErrorType.WALLET, message: 'Transaction cancelled', retryable: false };
      }

      // Check for wallet errors
      if (ERROR_PATTERNS.walletNotConnected.test(message)) {
        return { type: ErrorType.WALLET, message: 'Please connect your wallet', retryable: false };
      }
      if (ERROR_PATTERNS.wrongNetwork.test(message)) {
        return { type: ErrorType.WALLET, message: 'Please switch to Base network', retryable: false };
      }

      // Check for user input errors
      if (ERROR_PATTERNS.insufficientFunds.test(message)) {
        return { type: ErrorType.USER, message: 'Insufficient balance for this transaction', retryable: false };
      }
      if (ERROR_PATTERNS.insufficientAllowance.test(message)) {
        return { type: ErrorType.USER, message: 'Token approval required', retryable: false };
      }

      // Check for network errors (retryable)
      if (ERROR_PATTERNS.networkError.test(message) || ERROR_PATTERNS.rpcError.test(message)) {
        return { type: ErrorType.NETWORK, message: 'Network error - please try again', retryable: true };
      }
      if (ERROR_PATTERNS.rateLimited.test(message)) {
        return { type: ErrorType.NETWORK, message: 'Too many requests - please wait and try again', retryable: true };
      }

      // Check for contract errors
      if (ERROR_PATTERNS.revert.test(message)) {
        // Try to extract revert reason
        const reasonMatch = message.match(/reason:?\s*["']?([^"']+)["']?/i);
        const reason = reasonMatch ? reasonMatch[1] : 'Transaction would fail';
        return { type: ErrorType.CONTRACT, message: reason, retryable: false };
      }
      if (ERROR_PATTERNS.outOfGas.test(message)) {
        return { type: ErrorType.CONTRACT, message: 'Transaction requires more gas', retryable: false };
      }
      if (ERROR_PATTERNS.nonce.test(message)) {
        return { type: ErrorType.CONTRACT, message: 'Transaction conflict - please try again', retryable: true };
      }

      // Unknown error
      return { type: ErrorType.UNKNOWN, message: message.slice(0, 100), retryable: false };
    }

    /**
     * Get a user-friendly error message with suggested action.
     * @param error - Error object or string
     * @returns User-friendly message string
     */
    function getUserFriendlyError(error) {
      const classified = classifyError(error);

      switch (classified.type) {
        case ErrorType.WALLET:
          return classified.message;
        case ErrorType.USER:
          return classified.message;
        case ErrorType.NETWORK:
          return classified.message + (classified.retryable ? '' : '');
        case ErrorType.CONTRACT:
          return 'Transaction failed: ' + classified.message;
        default:
          return 'Something went wrong. Please try again.';
      }
    }

    /**
     * Execute a function with automatic retry for transient failures.
     * @param fn - Async function to execute
     * @param maxRetries - Maximum retry attempts (default 3)
     * @param delayMs - Delay between retries in ms (default 1000)
     * @returns Promise with result or throws after all retries fail
     */
    async function withRetry(fn, maxRetries = 3, delayMs = 1000) {
      let lastError;

      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          return await fn();
        } catch (error) {
          lastError = error;
          const classified = classifyError(error);

          // Don't retry non-retryable errors
          if (!classified.retryable) {
            throw error;
          }

          // Don't retry on last attempt
          if (attempt < maxRetries) {
            console.log(\`[ArbMe] Retry \${attempt}/\${maxRetries} after error:\`, classified.message);
            await new Promise(resolve => setTimeout(resolve, delayMs * attempt));
          }
        }
      }

      throw lastError;
    }

    /**
     * Log error with context for debugging.
     * @param context - Where the error occurred (e.g., 'addLiquidityV4')
     * @param error - The error object
     * @param extra - Optional extra context data
     */
    function logError(context, error, extra = {}) {
      const classified = classifyError(error);
      console.error(\`[ArbMe] [\${context}] \${classified.type.toUpperCase()} error:\`, {
        message: classified.message,
        retryable: classified.retryable,
        originalError: error?.message || error,
        ...extra,
      });
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P3.20: Promise.allSettled Utilities
     * Handles partial failures in parallel operations gracefully.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * Execute promises in parallel, handling partial failures gracefully.
     * Unlike Promise.all, this doesn't reject on first failure.
     * @param promises - Array of promises to execute
     * @param names - Optional array of names for logging
     * @returns Array of results (fulfilled values or null for rejected)
     */
    async function settleAll(promises, names = []) {
      const results = await Promise.allSettled(promises);
      return results.map((result, i) => {
        if (result.status === 'fulfilled') {
          return result.value;
        } else {
          const name = names[i] || \`operation[\${i}]\`;
          console.warn(\`[ArbMe] \${name} failed:\`, result.reason);
          return null;
        }
      });
    }

    /**
     * Execute promises in parallel with detailed error tracking.
     * @param tasks - Array of { name, promise } objects
     * @returns { results: any[], errors: { name, error }[] }
     */
    async function settleAllWithErrors(tasks) {
      const results = await Promise.allSettled(tasks.map(t => t.promise));
      const values = [];
      const errors = [];

      results.forEach((result, i) => {
        if (result.status === 'fulfilled') {
          values.push(result.value);
        } else {
          values.push(null);
          errors.push({ name: tasks[i].name, error: result.reason });
        }
      });

      if (errors.length > 0) {
        console.warn('[ArbMe] Some operations failed:', errors);
      }

      return { results: values, errors };
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P2.15: Transaction Status Utilities
     * Consolidated status update functions for all modals.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * Create a status update function for a specific element.
     * @param elementId - The ID of the status element
     * @returns Function that takes (message, type) and updates the element
     */
    function createTxStatusUpdater(elementId) {
      return function(message, type) {
        const el = document.getElementById(elementId);
        if (!el) {
          console.warn('[ArbMe] Status element not found:', elementId);
          return;
        }
        el.textContent = message;
        el.className = 'tx-status ' + (type || '');
      };
    }

    /**
     * Create a status clear function for a specific element.
     * @param elementId - The ID of the status element
     * @returns Function that clears the status
     */
    function createTxStatusClearer(elementId) {
      return function() {
        const el = document.getElementById(elementId);
        if (!el) return;
        el.className = 'tx-status';
        el.textContent = '';
      };
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P2.14: Auto-Balance Utilities
     * Common auto-balance setup for V2/V3/V4 liquidity input pairs.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * P3.22: Debounce utility for input handlers.
     * Delays execution until wait milliseconds have passed without another call.
     * @param func - Function to debounce
     * @param wait - Milliseconds to wait (default 100ms)
     * @returns Debounced function
     */
    function debounce(func, wait = 100) {
      let timeoutId = null;
      return function(...args) {
        if (timeoutId) clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          timeoutId = null;
          func.apply(this, args);
        }, wait);
      };
    }

    /**
     * Create auto-balance handler for a single input.
     * Uses debouncing to prevent race conditions and excessive updates.
     * @param sourceInput - The input element that changed
     * @param targetInput - The input element to update
     * @param priceRatioGetter - Function that returns current price ratio
     * @param isToken0Source - Whether the source is token0 (affects ratio direction)
     * @param isBalancingRef - Ref object with .value property to prevent recursion
     */
    function createAutoBalanceHandler(sourceInput, targetInput, priceRatioGetter, isToken0Source, isBalancingRef) {
      const handler = function() {
        if (isBalancingRef.value) return;

        const amount = parseFloat(sourceInput.value) || 0;
        const priceRatio = priceRatioGetter();

        if (amount > 0 && priceRatio > 0) {
          isBalancingRef.value = true;
          // priceRatio = token1 per token0
          const targetAmount = isToken0Source
            ? amount * priceRatio      // token0 â token1: multiply
            : amount / priceRatio;     // token1 â token0: divide
          targetInput.value = targetAmount.toFixed(6);
          isBalancingRef.value = false;
        }
      };
      // Debounce to prevent race conditions during rapid typing
      return debounce(handler, 100);
    }

    /**
     * Setup auto-balance for a token pair input.
     * @param config - { input0Id, input1Id, priceRatioGetter }
     * @returns { isBalancing: { value: boolean }, cleanup: () => void }
     */
    function setupAutoBalanceInputs(config) {
      const input0 = document.getElementById(config.input0Id);
      const input1 = document.getElementById(config.input1Id);

      if (!input0 || !input1) {
        console.warn('[ArbMe] Auto-balance inputs not found:', config.input0Id, config.input1Id);
        return { isBalancing: { value: false }, cleanup: () => {} };
      }

      const isBalancing = { value: false };

      const handler0 = createAutoBalanceHandler(input0, input1, config.priceRatioGetter, true, isBalancing);
      const handler1 = createAutoBalanceHandler(input1, input0, config.priceRatioGetter, false, isBalancing);

      input0.oninput = handler0;
      input1.oninput = handler1;

      return {
        isBalancing,
        cleanup: () => {
          input0.oninput = null;
          input1.oninput = null;
        }
      };
    }

    /**
     * Calculate position token amounts from liquidity and slot0 data.
     * @param slot0 - Slot0 data with sqrtPriceX96
     * @param position - Position with tickLower, tickUpper, liquidity
     * @param decimals0 - Token0 decimals
     * @param decimals1 - Token1 decimals
     * @returns { token0Amount, token1Amount, inRange, currentTick }
     */
    function calculatePositionAmounts(slot0, position, decimals0, decimals1) {
      const result = {
        token0Amount: 0,
        token1Amount: 0,
        inRange: true,
        currentTick: 0,
        decimalsUnknown: false
      };

      if (!slot0 || !slot0.sqrtPriceX96 || !position.liquidity || position.liquidity === '0') {
        return result;
      }

      // CRITICAL: If decimals are null/undefined, we cannot safely calculate amounts
      // Math.pow(10, null) = 1, which would show raw values as if they were formatted!
      if (decimals0 === null || decimals0 === undefined || decimals1 === null || decimals1 === undefined) {
        console.warn('[ArbMe] calculatePositionAmounts: Missing decimals, cannot calculate amounts safely');
        result.decimalsUnknown = true;
        // Still calculate in-range status
        try {
          const sqrtPriceX96 = BigInt(slot0.sqrtPriceX96);
          result.currentTick = slot0.tick || sqrtPriceX96ToTick(sqrtPriceX96);
          result.inRange = isPositionInRange(result.currentTick, position.tickLower, position.tickUpper);
        } catch (e) {
          console.error('[ArbMe] calculatePositionAmounts tick error:', e);
        }
        return result;
      }

      try {
        const sqrtPriceX96 = BigInt(slot0.sqrtPriceX96);
        result.currentTick = slot0.tick || sqrtPriceX96ToTick(sqrtPriceX96);
        result.inRange = isPositionInRange(result.currentTick, position.tickLower, position.tickUpper);

        const sqrtPriceLower = tickToSqrtPriceX96(position.tickLower);
        const sqrtPriceUpper = tickToSqrtPriceX96(position.tickUpper);
        const amounts = calculateAmountsFromLiquidity(sqrtPriceX96, sqrtPriceLower, sqrtPriceUpper, position.liquidity);

        result.token0Amount = Number(amounts.amount0) / Math.pow(10, decimals0);
        result.token1Amount = Number(amounts.amount1) / Math.pow(10, decimals1);
      } catch (e) {
        console.error('[ArbMe] calculatePositionAmounts error:', e);
      }

      return result;
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * P1.8: Modal State Validation
     * Ensures pool objects have all required fields before operations.
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */

    /**
     * Validate V2 modal pool state.
     * @returns { valid: boolean, errors: string[] }
     */
    function validateV2PoolState(pool) {
      const errors = [];
      if (!pool) {
        return { valid: false, errors: ['Pool not loaded'] };
      }
      if (!pool.token0 || !isValidAddress(pool.token0)) {
        errors.push('Invalid token0 address');
      }
      if (!pool.token1 || !isValidAddress(pool.token1)) {
        errors.push('Invalid token1 address');
      }
      if (pool.token0Decimals === null || pool.token0Decimals === undefined) {
        errors.push('Token0 decimals not verified');
      }
      if (pool.token1Decimals === null || pool.token1Decimals === undefined) {
        errors.push('Token1 decimals not verified');
      }
      return { valid: errors.length === 0, errors };
    }

    /**
     * Validate V3 add liquidity pool state.
     * @returns { valid: boolean, errors: string[] }
     */
    function validateV3PoolState(pool) {
      const errors = [];
      if (!pool) {
        return { valid: false, errors: ['Pool not loaded'] };
      }
      if (!pool.token0 || !isValidAddress(pool.token0)) {
        errors.push('Invalid token0 address');
      }
      if (!pool.token1 || !isValidAddress(pool.token1)) {
        errors.push('Invalid token1 address');
      }
      if (pool.token0Decimals === null || pool.token0Decimals === undefined) {
        errors.push('Token0 decimals not verified');
      }
      if (pool.token1Decimals === null || pool.token1Decimals === undefined) {
        errors.push('Token1 decimals not verified');
      }
      if (!pool.fee || pool.fee <= 0) {
        errors.push('Invalid fee tier');
      }
      return { valid: errors.length === 0, errors };
    }

    /**
     * Validate V4 add liquidity pool state.
     * @returns { valid: boolean, errors: string[] }
     */
    function validateV4PoolState(pool) {
      const errors = [];
      if (!pool) {
        return { valid: false, errors: ['Pool not loaded'] };
      }
      if (!pool.token0 || !isValidAddress(pool.token0)) {
        errors.push('Invalid token0 address');
      }
      if (!pool.token1 || !isValidAddress(pool.token1)) {
        errors.push('Invalid token1 address');
      }
      if (pool.token0Decimals === null || pool.token0Decimals === undefined) {
        errors.push('Token0 decimals not verified');
      }
      if (pool.token1Decimals === null || pool.token1Decimals === undefined) {
        errors.push('Token1 decimals not verified');
      }
      if (!pool.fee || pool.fee <= 0) {
        errors.push('Invalid fee tier');
      }
      if (!pool.tickSpacing || pool.tickSpacing <= 0) {
        errors.push('Invalid tick spacing');
      }
      return { valid: errors.length === 0, errors };
    }

    /**
     * Validate a token amount for liquidity operations.
     * @param amount - Human-readable amount
     * @param decimals - Token decimals
     * @param balance - Optional user balance to check against
     * @returns { valid: boolean, error: string|null }
     */
    function validateAmount(amount, decimals, balance = null) {
      // Check for valid number
      if (amount === null || amount === undefined || isNaN(amount)) {
        return { valid: false, error: 'Invalid amount' };
      }

      // Must be positive
      if (amount <= 0) {
        return { valid: false, error: 'Amount must be greater than 0' };
      }

      // Check dust threshold
      if (amount < AMOUNT_VALIDATION.MIN_AMOUNT) {
        return { valid: false, error: 'Amount too small (min: ' + AMOUNT_VALIDATION.MIN_AMOUNT + ')' };
      }

      // Check max to prevent overflow
      if (amount > AMOUNT_VALIDATION.MAX_AMOUNT) {
        return { valid: false, error: 'Amount too large' };
      }

      // Check that raw amount fits in uint256
      if (decimals !== null && decimals >= 0) {
        const rawAmount = toRawAmount(amount, decimals);
        if (rawAmount > AMOUNT_VALIDATION.MAX_RAW_UINT256) {
          return { valid: false, error: 'Amount would overflow uint256' };
        }
      }

      // Check against balance if provided
      if (balance !== null && amount > balance) {
        return { valid: false, error: 'Insufficient balance' };
      }

      return { valid: true, error: null };
    }

    /**
     * Validate both amounts for a liquidity pair.
     * @returns { valid: boolean, errors: string[] }
     */
    function validatePairAmounts(amount0, amount1, dec0, dec1, balance0 = null, balance1 = null) {
      const errors = [];

      const result0 = validateAmount(amount0, dec0, balance0);
      if (!result0.valid) errors.push('Token 0: ' + result0.error);

      const result1 = validateAmount(amount1, dec1, balance1);
      if (!result1.valid) errors.push('Token 1: ' + result1.error);

      return { valid: errors.length === 0, errors };
    }

    /**
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     * CRITICAL: On-chain decimal verification
     * Fetches token decimals from chain and compares to expected value.
     * Returns { verified: boolean, onChainDecimals: number|null, error: string|null }
     * âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
     */
    async function verifyTokenDecimalsOnChain(tokenAddress, expectedDecimals, tokenSymbol = '') {
      try {
        const data = await fetchTokenInfoCached(tokenAddress);

        if (!data || data.error) {
          console.error('[ArbMe] Failed to fetch on-chain decimals for', tokenSymbol || tokenAddress, ':', data.error);
          return { verified: false, onChainDecimals: null, error: 'Could not verify decimals: ' + data.error };
        }

        const onChainDecimals = toSafeDecimals(data.decimals);
        if (onChainDecimals === null) {
          console.error('[ArbMe] Invalid on-chain decimals for', tokenSymbol || tokenAddress, ':', data.decimals);
          return { verified: false, onChainDecimals: null, error: 'Invalid decimals returned from chain' };
        }

        if (onChainDecimals !== expectedDecimals) {
          console.error('[ArbMe] DECIMAL MISMATCH for', tokenSymbol || tokenAddress,
            '- Expected:', expectedDecimals, 'On-chain:', onChainDecimals);
          return {
            verified: false,
            onChainDecimals,
            error: \`Decimal mismatch for \${tokenSymbol || tokenAddress}: UI shows \${expectedDecimals} but chain says \${onChainDecimals}\`
          };
        }

        console.log('[ArbMe] Decimals verified for', tokenSymbol || tokenAddress, ':', onChainDecimals);
        return { verified: true, onChainDecimals, error: null };
      } catch (e) {
        console.error('[ArbMe] Error verifying decimals for', tokenSymbol || tokenAddress, ':', e);
        return { verified: false, onChainDecimals: null, error: 'Network error verifying decimals' };
      }
    }

    /**
     * Verify decimals for both tokens in a pair before liquidity operations.
     * Returns { verified: boolean, errors: string[] }
     */
    async function verifyPairDecimalsOnChain(token0, token1, dec0, dec1, sym0 = '', sym1 = '') {
      const [result0, result1] = await Promise.all([
        verifyTokenDecimalsOnChain(token0, dec0, sym0),
        verifyTokenDecimalsOnChain(token1, dec1, sym1)
      ]);

      const errors = [];
      if (!result0.verified) errors.push(result0.error);
      if (!result1.verified) errors.push(result1.error);

      return {
        verified: result0.verified && result1.verified,
        errors,
        token0Decimals: result0.onChainDecimals,
        token1Decimals: result1.onChainDecimals
      };
    }

    // V4 Position Manager ABI fragments for encoding
    const V4_POSITION_MANAGER_ABI = [
      'function initializePool((address currency0, address currency1, uint24 fee, int24 tickSpacing, address hooks) key, uint160 sqrtPriceX96) external returns (int24 tick)',
      'function modifyLiquidities(bytes calldata unlockData, uint256 deadline) external payable',
      'function multicall(bytes[] calldata data) external payable returns (bytes[] memory results)',
    ];

    // Create ethers Interface for encoding
    const positionManagerInterface = new ethers.Interface(V4_POSITION_MANAGER_ABI);

    // Helper to encode initializePool call
    function encodeInitializePool(currency0, currency1, fee, tickSpacing, hooks, sqrtPriceX96) {
      const poolKey = {
        currency0,
        currency1,
        fee,
        tickSpacing,
        hooks
      };
      return positionManagerInterface.encodeFunctionData('initializePool', [poolKey, sqrtPriceX96]);
    }

    // Helper to encode multicall with array of encoded calls
    function encodeMulticall(encodedCalls) {
      return positionManagerInterface.encodeFunctionData('multicall', [encodedCalls]);
    }

    // Toast notification helper
    function showToast(type, title, message, duration = 5000) {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'toast ' + type;

      const iconSvg = type === 'success'
        ? '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>'
        : type === 'error'
        ? '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>'
        : '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>';

      toast.innerHTML = iconSvg + '<div class="toast-content"><div class="toast-title">' + title + '</div>' + (message ? '<div class="toast-message">' + message + '</div>' : '') + '</div>';

      container.appendChild(toast);

      // Auto-remove after duration
      setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => toast.remove(), 200);
      }, duration);

      return toast;
    }

    // Format helpers
    function formatUsd(val) {
      if (val >= 1000000) return '$' + (val / 1000000).toFixed(2) + 'M';
      if (val >= 1000) return '$' + (val / 1000).toFixed(1) + 'K';
      if (val >= 1) return '$' + val.toFixed(2);
      return '$' + val.toFixed(4);
    }

    function formatPrice(val) {
      const num = parseFloat(val);
      if (num >= 1) return '$' + num.toFixed(4);
      if (num >= 0.0001) return '$' + num.toFixed(6);
      if (num >= 0.0000001) return '$' + num.toFixed(9);
      return '$' + num.toExponential(2);
    }

    function formatChange(val) {
      const num = parseFloat(val) || 0;
      const sign = num >= 0 ? '+' : '';
      return sign + num.toFixed(2) + '%';
    }

    function formatNumber(val) {
      if (val >= 1000000) return (val / 1000000).toFixed(2) + 'M';
      if (val >= 1000) return (val / 1000).toFixed(1) + 'K';
      if (val >= 1) return val.toFixed(2);
      return val.toFixed(6);
    }

    // Token icons and colors - derived from TOKEN_METADATA
    const TOKEN_ICONS = Object.fromEntries(
      Object.entries(TOKEN_METADATA)
        .filter(([, data]) => data.icon)
        .map(([symbol, data]) => [symbol, data.icon])
    );
    // Add ETH alias for WETH icon
    TOKEN_ICONS['ETH'] = TOKEN_METADATA.WETH?.icon || null;

    const TOKEN_COLORS = Object.fromEntries(
      Object.entries(TOKEN_METADATA)
        .filter(([, data]) => data.color)
        .map(([symbol, data]) => [symbol, data.color])
    );
    // Add ETH alias for WETH color
    TOKEN_COLORS['ETH'] = TOKEN_METADATA.WETH?.color || '#627eea';

    function getTokenIcon(symbol) {
      const upper = symbol ? symbol.toUpperCase() : '';
      // Try exact match first
      if (TOKEN_ICONS[upper]) return TOKEN_ICONS[upper];
      // Then try includes
      for (const [key, url] of Object.entries(TOKEN_ICONS)) {
        if (upper.includes(key)) return url;
      }
      return null;
    }

    function getTokenIconByAddress(address) {
      if (!address) return null;
      const token = TOKEN_BY_ADDRESS[address.toLowerCase()];
      return token?.icon || null;
    }

    function getTokenColor(symbol) {
      const upper = symbol.toUpperCase();
      // Try exact match first
      if (TOKEN_COLORS[upper]) return TOKEN_COLORS[upper];
      // Then try includes
      for (const [key, color] of Object.entries(TOKEN_COLORS)) {
        if (upper.includes(key)) return color;
      }
      return '#7a7a8f';
    }

    function tokenIcon(symbol, className = 'pool-icon') {
      const iconUrl = getTokenIcon(symbol);
      if (iconUrl) {
        return \`<img class="\${className}" src="\${iconUrl}" alt="\${symbol}" onerror="this.outerHTML=tokenIconFallback('\${symbol}', '\${className}')"/>\`;
      }
      return tokenIconFallback(symbol, className);
    }

    window.tokenIconFallback = function(symbol, className = 'pool-icon') {
      const color = getTokenColor(symbol);
      const letter = symbol.charAt(0).toUpperCase();
      const size = className === 'position-icon' ? '28' : '24';
      return \`<svg class="\${className}" width="\${size}" height="\${size}" viewBox="0 0 24 24"><circle cx="12" cy="12" r="11" fill="\${color}"/><text x="12" y="16" text-anchor="middle" fill="#fff" font-size="10" font-weight="bold">\${letter}</text></svg>\`;
    }

    function getVersionBadge(dex) {
      if (dex.includes('V4')) return '<span class="pool-badge v4">V4</span>';
      if (dex.includes('V3')) return '<span class="pool-badge v3">V3</span>';
      if (dex.includes('V2')) return '<span class="pool-badge v2">V2</span>';
      return '';
    }

    // Wallet connection
    async function connectWallet() {
      console.log('[ArbMe] Attempting wallet connection...');
      try {
        const context = await sdk.context;
        console.log('[ArbMe] SDK context:', JSON.stringify(context, null, 2));
        let wallet = null;

        // Try verified addresses first
        if (context?.user?.verifiedAddresses?.ethAddresses?.length > 0) {
          wallet = context.user.verifiedAddresses.ethAddresses[0];
          console.log('[ArbMe] Got wallet from verifiedAddresses:', wallet);
        }
        // Then custody address
        else if (context?.user?.custodyAddress) {
          wallet = context.user.custodyAddress;
          console.log('[ArbMe] Got wallet from custodyAddress:', wallet);
        }
        // Finally try eth provider
        else {
          try {
            console.log('[ArbMe] Trying ethProvider...');
            const provider = sdk.wallet.ethProvider;
            const accounts = await provider.request({ method: 'eth_requestAccounts' });
            console.log('[ArbMe] ethProvider accounts:', accounts);
            if (accounts?.length > 0) wallet = accounts[0];
          } catch (e) {
            console.log('[ArbMe] eth_requestAccounts failed:', e);
          }
        }

        if (wallet) {
          connectedWallet = wallet;
          console.log('[ArbMe] Connected wallet:', wallet);
          document.getElementById('wallet-btn').classList.add('connected');
          document.getElementById('wallet-btn').innerHTML = \`
            <span class="wallet-dot"></span>
            <span id="wallet-text">\${wallet.slice(0, 6)}...\${wallet.slice(-4)}</span>
          \`;
          document.getElementById('positions-section').classList.add('visible');
          loadPositions();
        } else {
          console.log('[ArbMe] No wallet found');
        }
      } catch (e) {
        console.error('[ArbMe] Failed to connect wallet:', e);
      }
    }

    // Tip Jar - Send ETH tip to @arbme Farcaster wallet
    const ARBME_TIP_WALLET = '0x2C421b1c21bB88F1418cC525934E62F2c48C19df';

    window.sendTip = async function(ethAmount) {
      console.log('[ArbMe] Sending tip:', ethAmount, 'ETH');

      if (!connectedWallet) {
        await connectWallet();
        if (!connectedWallet) {
          alert('Please connect your wallet to send a tip');
          return;
        }
      }

      // Find the button that was clicked and show loading state
      const buttons = document.querySelectorAll('.tip-btn');
      buttons.forEach(btn => btn.classList.add('tipping'));

      try {
        const provider = sdk.wallet.ethProvider;
        const weiAmount = '0x' + (BigInt(Math.floor(parseFloat(ethAmount) * 1e18))).toString(16);

        const txHash = await provider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: ARBME_TIP_WALLET,
            value: weiAmount,
            gas: '0x5208', // 21000 gas for simple ETH transfer
          }]
        });

        console.log('[ArbMe] Tip sent! TX:', txHash);
        alert('Thank you for your support! ð');
      } catch (e) {
        console.error('[ArbMe] Tip failed:', e);
        if (!e.message?.includes('rejected')) {
          alert('Tip failed: ' + (e.message || 'Unknown error'));
        }
      } finally {
        buttons.forEach(btn => btn.classList.remove('tipping'));
      }
    };

    // Toggle positions section
    function togglePositions() {
      const header = document.getElementById('positions-header');
      const content = document.getElementById('positions-content');
      positionsExpanded = !positionsExpanded;
      if (positionsExpanded) {
        header.classList.remove('collapsed');
        content.classList.remove('collapsed');
        content.style.maxHeight = content.scrollHeight + 'px';
      } else {
        header.classList.add('collapsed');
        content.classList.add('collapsed');
      }
    }

    // Toggle closed positions visibility
    function toggleClosedPositions() {
      const positionsList = document.getElementById('positions-list');
      const checkbox = document.getElementById('show-closed-toggle');
      if (checkbox.checked) {
        positionsList.classList.add('show-closed');
      } else {
        positionsList.classList.remove('show-closed');
      }
      // Update collapsible height
      const content = document.getElementById('positions-content');
      setTimeout(() => {
        content.style.maxHeight = content.scrollHeight + 'px';
      }, 50);
    }

    // Token symbol lookup (basic mapping for common tokens)
    const TOKEN_SYMBOLS = {
      '0xc4730f86d1f86ce0712a7b17ee919db7defad7fe': 'PAGE',
      '0xc647421c5dc78d1c3960faa7a33f9aefdf4b7b07': 'ARBME',
      '0x4200000000000000000000000000000000000006': 'WETH',
      '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913': 'USDC',
      '0x59e058780dd8a6017061596a62288b6438edbe68': 'OINC',
      '0xcbb7c0000ab88b473b1f5afd9ef808440eed33bf': 'cbBTC',
      '0x5c0872b790bb73e2b3a9778db6e7704095624b07': 'ABC',
      '0x1bc0c42215582d5a085795f4badbac3ff36d1bcb': 'CLANKER',
    };

    // Custom pools created by users (not yet indexed by DexScreener)
    let customPools = [
      // ABC/ARBME V2 pool created by user
      {
        pair: 'ABC / ARBME',
        pairAddress: '0xe2f1a6f0b723a062adecee8fd420485a4311ad0b',
        dex: 'Uniswap V2',
        tvl: 0,
        volume24h: 0,
        priceUsd: '0',
        priceChange24h: 0,
        url: 'https://dexscreener.com/base/0xe2f1a6f0b723a062adecee8fd420485a4311ad0b',
        source: 'custom',
        token0: '0x5c0872b790bb73e2b3a9778db6e7704095624b07',
        token1: '0xc647421c5dc78d1c3960faa7a33f9aefdf4b7b07',
      }
    ];

    function getTokenSymbol(address) {
      return TOKEN_SYMBOLS[address.toLowerCase()] || address.slice(0, 6) + '...';
    }

    // Position cache helper functions
    const POSITION_CACHE_KEY = 'arbme_positions_cache_';
    const POSITION_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

    function getCachedPositions(wallet) {
      try {
        const cached = localStorage.getItem(POSITION_CACHE_KEY + wallet.toLowerCase());
        if (cached) {
          const data = JSON.parse(cached);
          if (Date.now() - data.timestamp < POSITION_CACHE_TTL) {
            return data.positions;
          }
        }
      } catch (e) {
        console.log('[ArbMe] Cache read error:', e);
      }
      return null;
    }

    function setCachedPositions(wallet, positions) {
      try {
        localStorage.setItem(POSITION_CACHE_KEY + wallet.toLowerCase(), JSON.stringify({
          timestamp: Date.now(),
          positions: positions
        }));
      } catch (e) {
        console.log('[ArbMe] Cache write error:', e);
      }
    }

    // Load user positions
    async function loadPositions() {
      if (!connectedWallet) {
        console.log('[ArbMe] No wallet, skipping position load');
        return;
      }

      console.log('[ArbMe] Loading positions for:', connectedWallet);
      const positionsEl = document.getElementById('positions-list');

      try {
        // Query V2, V3, and V4 positions in parallel
        const [v2Res, v3Res, v4Res] = await Promise.all([
          fetch(\`/test/rpc?action=v2_allPositions&wallet=\${connectedWallet}\`),
          fetch(\`/test/rpc?action=v3_allPositions&wallet=\${connectedWallet}\`),
          fetch(\`/test/rpc?action=v4_allPositions&wallet=\${connectedWallet}\`)
        ]);
        const v2Data = await v2Res.json();
        const v3Data = await v3Res.json();
        const v4Data = await v4Res.json();
        console.log('[ArbMe] Loaded: V2', v2Data.positions?.length || 0, '| V3', v3Data.positions?.length || 0, '| V4', v4Data.positions?.length || 0);

        const positions = [];

        // Add all V2 positions
        if (v2Data.positions && v2Data.positions.length > 0) {
          for (const v2pos of v2Data.positions) {
            positions.push({
              type: 'V2',
              pair: v2pos.pair,
              token0: v2pos.token0Symbol,
              token1: v2pos.token1Symbol,
              token0Address: v2pos.token0,
              token1Address: v2pos.token1,
              token0Decimals: v2pos.token0Decimals,
              token1Decimals: v2pos.token1Decimals,
              lpBalance: v2pos.lpBalanceFormatted,
              sharePercent: v2pos.shareOfPool * 100,
              token0Amount: v2pos.token0Amount,
              token1Amount: v2pos.token1Amount,
              poolAddress: v2pos.poolAddress,
            });
          }
        }

        // Check custom V2 pools for LP token balances
        for (const customPool of customPools) {
          if (customPool.dex === 'Uniswap V2') {
            try {
              const customBalRes = await fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${customPool.pairAddress}\`);
              const customBalData = await customBalRes.json();
              if (customBalData.balanceFormatted && customBalData.balanceFormatted > 0) {
                const token0Symbol = getTokenSymbol(customPool.token0);
                const token1Symbol = getTokenSymbol(customPool.token1);
                positions.push({
                  type: 'V2',
                  pair: \`\${token0Symbol} / \${token1Symbol}\`,
                  token0: token0Symbol,
                  token1: token1Symbol,
                  token0Address: customPool.token0,
                  token1Address: customPool.token1,
                  lpBalance: customBalData.balanceFormatted,
                  sharePercent: 0, // Would need reserves to calculate
                  token0Amount: 0,
                  token1Amount: 0,
                  poolAddress: customPool.pairAddress,
                  isCustomPool: true,
                });
              }
            } catch (e) {
              console.log('[ArbMe] Failed to check custom pool:', customPool.pairAddress, e);
            }
          }
        }

        // Add each V3 position with full details (show all, including closed)
        if (v3Data.positions && v3Data.positions.length > 0) {
          // Fetch slot0 for unique V3 pools to get current tick
          const v3PoolSlot0Cache = {};
          const uniqueV3Pools = [...new Set(v3Data.positions.map(p => \`\${p.token0}_\${p.token1}_\${p.fee}\`))];
          await Promise.all(uniqueV3Pools.map(async (poolKey) => {
            const [token0, token1, fee] = poolKey.split('_');
            try {
              const res = await fetch(\`/test/rpc?action=v3_slot0&token0=\${token0}&token1=\${token1}&fee=\${fee}\`);
              const data = await res.json();
              if (data.sqrtPriceX96) {
                v3PoolSlot0Cache[poolKey] = data;
              }
            } catch (e) {
              console.log('[ArbMe] Failed to fetch V3 slot0 for', poolKey);
            }
          }));

          for (const v3pos of v3Data.positions) {
            const token0Symbol = getTokenSymbol(v3pos.token0);
            const token1Symbol = getTokenSymbol(v3pos.token1);
            // Get proper decimals for each token
            const decimals0 = getTokenDecimalsByAddress(v3pos.token0);
            const decimals1 = getTokenDecimalsByAddress(v3pos.token1);

            // Parse tokensOwed (uncollected fees) using position utility (P2.13)
            const tokensOwed0Raw = v3pos.tokensOwed0 ? BigInt(v3pos.tokensOwed0) : BigInt(0);
            const tokensOwed1Raw = v3pos.tokensOwed1 ? BigInt(v3pos.tokensOwed1) : BigInt(0);
            const tokensOwed0 = parsePositionAmount(v3pos.tokensOwed0, decimals0);
            const tokensOwed1 = parsePositionAmount(v3pos.tokensOwed1, decimals1);

            // Calculate token amounts and in-range status using position utility (P2.13)
            const poolKey = \`\${v3pos.token0}_\${v3pos.token1}_\${v3pos.fee}\`;
            const slot0 = v3PoolSlot0Cache[poolKey];

            // Use consolidated utility for position amount calculation (P2.13)
            // When slot0 is unavailable, use null for inRange to indicate "unknown" state
            const hasPoolData = !!(slot0 && v3pos.hasLiquidity && v3pos.liquidity !== '0');
            const posAmounts = hasPoolData
              ? calculatePositionAmounts(slot0, v3pos, decimals0, decimals1)
              : { token0Amount: 0, token1Amount: 0, inRange: null, currentTick: 0 };

            // Calculate pool share using consolidated utility (P2.13)
            let poolShare = 0;
            if (slot0 && v3pos.hasLiquidity && v3pos.liquidity !== '0') {
              if (slot0.totalLiquidity && slot0.totalLiquidity !== '0') {
                poolShare = calculatePoolShare(v3pos.liquidity, slot0.totalLiquidity);
                console.log('[ArbMe] V3 pool share:', poolShare);
              } else {
                console.log('[ArbMe] V3 no totalLiquidity for pool', poolKey, slot0?.totalLiquidity);
              }
            }

            positions.push({
              type: 'V3',
              pair: \`\${token0Symbol} / \${token1Symbol}\`,
              token0: token0Symbol,
              token1: token1Symbol,
              token0Address: v3pos.token0,
              token1Address: v3pos.token1,
              token0Decimals: decimals0,
              token1Decimals: decimals1,
              tokenId: v3pos.tokenId,
              fee: v3pos.feePercent,
              feeRaw: v3pos.fee,
              liquidity: v3pos.liquidity,
              tickLower: v3pos.tickLower,
              tickUpper: v3pos.tickUpper,
              currentTick: posAmounts.currentTick,
              inRange: posAmounts.inRange,
              token0Amount: posAmounts.token0Amount,
              token1Amount: posAmounts.token1Amount,
              tokensOwed0: tokensOwed0,
              tokensOwed1: tokensOwed1,
              hasUnclaimedFees: tokensOwed0Raw > BigInt(0) || tokensOwed1Raw > BigInt(0),
              isV3: true,
              isClosed: !v3pos.hasLiquidity || v3pos.liquidity === '0',
              poolShare: poolShare,
              poolAddress: slot0?.poolAddress || '',
              poolDataAvailable: hasPoolData,
            });
          }
        }

        // Add each V4 position with full details (show all, including closed)
        // Also fetch estimated fees and slot0 for active V4 positions
        try {
          if (v4Data.positions && v4Data.positions.length > 0) {
            // Build unique pool keys for V4
            const v4PoolSlot0Cache = {};
            const uniqueV4Pools = [...new Set(v4Data.positions
              .filter(p => p.currency0 !== 'unknown')
              .map(p => \`\${p.currency0}_\${p.currency1}_\${p.fee}_\${p.tickSpacing}_\${p.hooks || '0x0000000000000000000000000000000000000000'}\`))];

            // Fetch slot0 and fees in parallel
            const v4PoolPromises = uniqueV4Pools.map(async (poolKey) => {
              const [c0, c1, fee, tickSpacing, hooks] = poolKey.split('_');
              try {
                const res = await fetch(\`/test/rpc?action=v4_getSlot0&currency0=\${c0}&currency1=\${c1}&fee=\${fee}&tickSpacing=\${tickSpacing}&hooks=\${hooks}\`);
                const data = await res.json();
                if (data.sqrtPriceX96) {
                  v4PoolSlot0Cache[poolKey] = data;
                }
              } catch (e) {
                console.log('[ArbMe] Failed to fetch V4 slot0 for', poolKey);
              }
            });

            const v4FeesPromises = v4Data.positions
              .filter(p => p.hasLiquidity && p.currency0 !== 'unknown')
              .map(async (v4pos) => {
                try {
                  const feesUrl = \`/test/rpc?action=v4_estimateFees&tokenId=\${v4pos.tokenId}&currency0=\${v4pos.currency0}&currency1=\${v4pos.currency1}&fee=\${v4pos.fee}&tickSpacing=\${v4pos.tickSpacing}&hooks=\${v4pos.hooks || '0x0000000000000000000000000000000000000000'}&tickLower=\${v4pos.tickLower}&tickUpper=\${v4pos.tickUpper}&liquidity=\${v4pos.liquidity}\`;
                  const res = await fetch(feesUrl);
                  const data = await res.json();
                  return { tokenId: v4pos.tokenId, fees0: data.fees0 || '0', fees1: data.fees1 || '0' };
                } catch (e) {
                  console.log('[ArbMe] Failed to fetch V4 fees for', v4pos.tokenId, e);
                  return { tokenId: v4pos.tokenId, fees0: '0', fees1: '0' };
                }
              });

            await Promise.all(v4PoolPromises);
            const v4FeesResults = await Promise.all(v4FeesPromises);
            const v4FeesMap = {};
            for (const r of v4FeesResults) {
              v4FeesMap[r.tokenId] = r;
            }

            for (const v4pos of v4Data.positions) {
              const token0Symbol = v4pos.currency0 === 'unknown' ? 'V4' : getTokenSymbol(v4pos.currency0);
              const token1Symbol = v4pos.currency1 === 'unknown' ? 'Position' : getTokenSymbol(v4pos.currency1);
              const decimals0 = getTokenDecimalsByAddress(v4pos.currency0);
              const decimals1 = getTokenDecimalsByAddress(v4pos.currency1);

              // Get estimated fees and parse using position utility (P2.13)
              const feesData = v4FeesMap[v4pos.tokenId] || { fees0: '0', fees1: '0' };
              const tokensOwed0Raw = BigInt(feesData.fees0 || '0');
              const tokensOwed1Raw = BigInt(feesData.fees1 || '0');
              const tokensOwed0 = parsePositionAmount(feesData.fees0, decimals0);
              const tokensOwed1 = parsePositionAmount(feesData.fees1, decimals1);

              // Calculate token amounts and in-range status using position utility (P2.13)
              const poolKey = \`\${v4pos.currency0}_\${v4pos.currency1}_\${v4pos.fee}_\${v4pos.tickSpacing}_\${v4pos.hooks || '0x0000000000000000000000000000000000000000'}\`;
              const slot0 = v4PoolSlot0Cache[poolKey];

              // Use consolidated utility for position amount calculation (P2.13)
              // When slot0 is unavailable, use null for inRange to indicate "unknown" state
              const hasPoolData = !!(slot0 && v4pos.hasLiquidity && v4pos.liquidity !== '0');
              const posAmounts = hasPoolData
                ? calculatePositionAmounts(slot0, v4pos, decimals0, decimals1)
                : { token0Amount: 0, token1Amount: 0, inRange: null, currentTick: 0 };

              // Calculate pool share using consolidated utility (P2.13)
              let poolShare = 0;
              if (slot0 && v4pos.hasLiquidity && v4pos.liquidity !== '0') {
                if (slot0.totalLiquidity && slot0.totalLiquidity !== '0') {
                  poolShare = calculatePoolShare(v4pos.liquidity, slot0.totalLiquidity);
                  console.log('[ArbMe] V4 pool share:', poolShare);
                } else {
                  console.log('[ArbMe] V4 no totalLiquidity for position', v4pos.tokenId, slot0?.totalLiquidity);
                }
              }

              positions.push({
                type: 'V4',
                pair: v4pos.currency0 === 'unknown' ? \`V4 Position #\${v4pos.tokenId}\` : \`\${token0Symbol} / \${token1Symbol}\`,
                token0: token0Symbol,
                token1: token1Symbol,
                token0Address: v4pos.currency0,
                token1Address: v4pos.currency1,
                token0Decimals: decimals0,
                token1Decimals: decimals1,
                tokenId: v4pos.tokenId,
                fee: v4pos.feePercent,
                feeRaw: v4pos.fee,
                liquidity: v4pos.liquidity,
                tickLower: v4pos.tickLower,
                tickUpper: v4pos.tickUpper,
                tickSpacing: v4pos.tickSpacing,
                hooks: v4pos.hooks,
                currentTick: posAmounts.currentTick,
                inRange: posAmounts.inRange,
                token0Amount: posAmounts.token0Amount,
                token1Amount: posAmounts.token1Amount,
                tokensOwed0: tokensOwed0,
                tokensOwed1: tokensOwed1,
                hasUnclaimedFees: tokensOwed0Raw > BigInt(0) || tokensOwed1Raw > BigInt(0),
                isV4: true,
                isClosed: !v4pos.hasLiquidity || v4pos.liquidity === '0',
                poolShare: poolShare,
                poolId: slot0?.poolId || '',
                poolDataAvailable: hasPoolData,
              });
            }
          }
        } catch (v4err) {
          console.error('[ArbMe] Error processing V4 positions:', v4err);
        }

        // Sort positions: active first, then closed
        positions.sort((a, b) => {
          if (a.isClosed === b.isClosed) return 0;
          return a.isClosed ? 1 : -1;
        });

        // Gather unique token addresses and fetch prices
        const tokenAddresses = new Set();
        for (const pos of positions) {
          if (pos.token0Address && pos.token0Address !== 'unknown') tokenAddresses.add(pos.token0Address.toLowerCase());
          if (pos.token1Address && pos.token1Address !== 'unknown') tokenAddresses.add(pos.token1Address.toLowerCase());
        }

        let tokenPrices = {};
        if (tokenAddresses.size > 0) {
          try {
            const pricesRes = await fetch(\`/test/rpc?action=tokenPrices&tokens=\${Array.from(tokenAddresses).join(',')}\`);
            const pricesData = await pricesRes.json();
            tokenPrices = pricesData.prices || {};
            console.log('[ArbMe] Fetched token prices:', Object.keys(tokenPrices).length);
          } catch (e) {
            console.error('[ArbMe] Failed to fetch token prices:', e);
          }
        }

        // Calculate USD values for positions
        for (const pos of positions) {
          const price0 = tokenPrices[pos.token0Address?.toLowerCase()] || 0;
          const price1 = tokenPrices[pos.token1Address?.toLowerCase()] || 0;
          pos.price0 = price0;
          pos.price1 = price1;

          // For V2 positions with token amounts
          if (!pos.isV3 && !pos.isV4 && pos.token0Amount && pos.token1Amount) {
            pos.usdValue = (pos.token0Amount * price0) + (pos.token1Amount * price1);
          }
        }

        // Calculate total portfolio value
        let totalPortfolioValue = 0;
        let totalPendingFees = 0;
        for (const pos of positions) {
          if (pos.isClosed) continue;
          const price0 = tokenPrices[pos.token0Address?.toLowerCase()] || 0;
          const price1 = tokenPrices[pos.token1Address?.toLowerCase()] || 0;
          const posValue = ((pos.token0Amount || 0) * price0) + ((pos.token1Amount || 0) * price1);
          totalPortfolioValue += posValue;
          const feesValue = ((pos.tokensOwed0 || 0) * price0) + ((pos.tokensOwed1 || 0) * price1);
          totalPendingFees += feesValue;
        }

        // Update count badge and portfolio value
        const activeCount = positions.filter(p => !p.isClosed).length;
        const totalCount = positions.length;
        const portfolioDisplay = totalPortfolioValue > 0.01
          ? '$' + totalPortfolioValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })
          : totalPortfolioValue > 0 ? '<$0.01' : '';
        const feesDisplay = totalPendingFees > 0.01
          ? ' (+$' + totalPendingFees.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' fees)'
          : totalPendingFees > 0 ? ' (+<$0.01 fees)' : '';
        document.getElementById('positions-count').textContent = totalCount > 0 ? \`(\${activeCount} active)\` : '';
        document.getElementById('active-count').textContent = totalCount > activeCount ? \`+\${totalCount - activeCount} closed\` : '';
        document.getElementById('portfolio-value').textContent = portfolioDisplay + feesDisplay;

        // Helper to find matching pool from poolsData
        function findMatchingPool(pos) {
          if (!poolsData || !poolsData.pools) return null;
          const posTokens = [pos.token0?.toUpperCase(), pos.token1?.toUpperCase()].sort();

          // Determine the expected dex type based on position type
          const expectedDex = pos.isV4 ? 'V4' : pos.isV3 ? 'V3' : 'V2';

          // First try to match by poolId/poolAddress (most accurate)
          if (pos.poolId) {
            const exactMatch = poolsData.pools.find(p =>
              p.pairAddress && p.pairAddress.toLowerCase() === pos.poolId.toLowerCase()
            );
            if (exactMatch) return exactMatch;
          }
          if (pos.poolAddress) {
            const exactMatch = poolsData.pools.find(p =>
              p.pairAddress && p.pairAddress.toLowerCase() === pos.poolAddress.toLowerCase()
            );
            if (exactMatch) return exactMatch;
          }

          // Then try to match by token symbols AND dex type AND fee tier
          const feeMatch = poolsData.pools.find(p => {
            const poolTokens = p.pair.toUpperCase().split(/\\s*\\/\\s*/).sort();
            if (poolTokens[0] !== posTokens[0] || poolTokens[1] !== posTokens[1]) return false;
            if (!p.dex?.includes(expectedDex)) return false;
            // For V3/V4, also match by fee tier if available
            if ((pos.isV3 || pos.isV4) && pos.feeRaw && p.fee) {
              return p.fee === pos.feeRaw;
            }
            return true;
          });
          if (feeMatch) return feeMatch;

          // Fallback: match by symbols and dex type only
          return poolsData.pools.find(p => {
            const poolTokens = p.pair.toUpperCase().split(/\\s*\\/\\s*/).sort();
            if (poolTokens[0] !== posTokens[0] || poolTokens[1] !== posTokens[1]) return false;
            return p.dex?.includes(expectedDex);
          });
        }

        // Helper to build pool stats HTML
        function buildPoolStats(pool, position) {
          if (!pool) {
            // Check if this is a non-ARBME pool (we only track ARBME pools)
            const isArbmePool = position && (
              position.token0?.toUpperCase() === 'ARBME' ||
              position.token1?.toUpperCase() === 'ARBME'
            );
            const message = isArbmePool
              ? 'Pool data temporarily unavailable'
              : 'Non-ARBME pool - market data not tracked';
            return \`<div class="position-pool-stats"><div class="pool-stat"><div class="pool-stat-label">\${message}</div></div></div>\`;
          }
          // Use actual pool fee rate (convert from basis points like 3000=0.3%, 10000=1%)
          const feeRate = pool.fee ? (pool.fee / 1000000) : (pool.dex?.includes('V3') || pool.dex?.includes('V4') ? 0.003 : 0.003);
          const apr = pool.tvl > 0 && pool.volume24h > 0 ? ((pool.volume24h * feeRate / pool.tvl) * 365 * 100) : 0;
          const aprDisplay = apr > 0 ? apr.toFixed(1) + '%' : '--';
          const aprClass = apr >= 100 ? 'apr-high' : apr >= 20 ? 'apr-medium' : '';
          const change = pool.priceChange24h || 0;
          const changeClass = change >= 0 ? 'positive' : 'negative';
          return \`
            <div class="position-pool-stats">
              <div class="pool-stat">
                <div class="pool-stat-label">TVL</div>
                <div class="pool-stat-value tvl">\${formatUsd(pool.tvl)}</div>
              </div>
              <div class="pool-stat">
                <div class="pool-stat-label">24h Vol</div>
                <div class="pool-stat-value">\${formatUsd(pool.volume24h || 0)}</div>
              </div>
              <div class="pool-stat">
                <div class="pool-stat-label">APR</div>
                <div class="pool-stat-value apr \${aprClass}">\${aprDisplay}</div>
              </div>
              <div class="pool-stat">
                <div class="pool-stat-label">24h</div>
                <div class="pool-stat-value change \${changeClass}">\${formatChange(change)}</div>
              </div>
            </div>
          \`;
        }

        // Helper to build pending fees display with symbols and USD
        function buildFeesDisplay(pos, tokenPrices) {
          const hasFees = pos.hasUnclaimedFees || (pos.tokensOwed0 > 0 || pos.tokensOwed1 > 0);
          if (!hasFees) return { html: '', usdValue: 0 };

          const fee0 = pos.tokensOwed0 || 0;
          const fee1 = pos.tokensOwed1 || 0;
          const price0 = tokenPrices[pos.token0Address?.toLowerCase()] || 0;
          const price1 = tokenPrices[pos.token1Address?.toLowerCase()] || 0;
          const usdValue = (fee0 * price0) + (fee1 * price1);

          // Format individual fees with symbols
          const fee0Display = fee0 > 0 ? \`\${formatNumber(fee0)} \${pos.token0}\` : '';
          const fee1Display = fee1 > 0 ? \`\${formatNumber(fee1)} \${pos.token1}\` : '';
          const feesText = [fee0Display, fee1Display].filter(f => f).join(' + ');
          const usdText = usdValue > 0.01 ? \`(\${formatUsd(usdValue)})\` : usdValue > 0 ? '(<$0.01)' : '';

          return {
            html: \`<div class="pending-fees-row">
              <div class="pending-fees-label">Pending Fees</div>
              <div class="pending-fees-amounts">\${feesText}</div>
              <div class="pending-fees-usd">\${usdText}</div>
            </div>\`,
            usdValue: usdValue
          };
        }

        if (positions.length === 0) {
          positionsEl.innerHTML = \`
            <div class="no-positions">
              <div class="no-positions-text">No active positions</div>
              <div class="no-positions-hint">Tap + on any pool to add liquidity</div>
            </div>
          \`;
        } else {
          positionsEl.innerHTML = positions.map((pos, idx) => {
            const matchingPool = findMatchingPool(pos);
            const feesData = buildFeesDisplay(pos, tokenPrices);

            if (pos.isV3 || pos.isV4) {
              // V3/V4 position card (similar UI)
              const version = pos.isV4 ? 'V4' : 'V3';
              const badgeClass = pos.isV4 ? 'v4' : 'v3';
              const closedBadge = pos.isClosed ? '<span class="position-badge closed">Closed</span>' : '';
              const hasFees = pos.hasUnclaimedFees || (pos.tokensOwed0 > 0 || pos.tokensOwed1 > 0);

              // Calculate USD value from token amounts
              const price0 = tokenPrices[pos.token0Address?.toLowerCase()] || 0;
              const price1 = tokenPrices[pos.token1Address?.toLowerCase()] || 0;
              const hasTokens = (pos.token0Amount || 0) > 0 || (pos.token1Amount || 0) > 0;
              const hasPrices = price0 > 0 || price1 > 0;
              const positionUsdValue = (pos.token0Amount || 0) * price0 + (pos.token1Amount || 0) * price1;
              let usdDisplay;
              if (positionUsdValue > 0.01) {
                usdDisplay = '$' + positionUsdValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
              } else if (positionUsdValue > 0) {
                usdDisplay = '<$0.01';
              } else if (hasTokens && !hasPrices) {
                usdDisplay = 'Price N/A';
              } else {
                usdDisplay = '--';
              }

              // In-range badge - handle null (unknown) state when pool data unavailable
              let rangeBadge = '';
              if (!pos.isClosed) {
                if (pos.inRange === true) {
                  rangeBadge = '<span class="position-badge in-range">In Range</span>';
                } else if (pos.inRange === false) {
                  rangeBadge = '<span class="position-badge out-of-range">Out of Range</span>';
                }
                // When inRange is null, don't show any badge (pool data unavailable)
              }

              return \`
                <div class="position-card \${pos.isClosed ? 'closed' : ''} \${pos.inRange === false && !pos.isClosed ? 'out-of-range' : ''}">
                  <div class="position-top">
                    <div class="position-pair">
                      <div class="position-icons">
                        \${tokenIcon(pos.token0, 'position-icon')}
                        \${tokenIcon(pos.token1, 'position-icon')}
                      </div>
                      <span class="position-name">\${pos.pair}</span>
                      <span class="position-badge \${badgeClass}">\${version}</span>
                      \${closedBadge}
                      \${rangeBadge}
                    </div>
                    <div class="position-value">
                      <div class="position-value-amount usd-value">\${usdDisplay}</div>
                      <div class="position-value-label">My Value</div>
                    </div>
                  </div>
                  \${buildPoolStats(matchingPool, pos)}
                  \${feesData.html}
                  <div class="position-details">
                    <div class="position-detail">
                      <div class="position-detail-value">\${formatNumber(pos.token0Amount || 0)}</div>
                      <div class="position-detail-label">\${pos.token0}</div>
                    </div>
                    <div class="position-detail">
                      <div class="position-detail-value">\${formatNumber(pos.token1Amount || 0)}</div>
                      <div class="position-detail-label">\${pos.token1}</div>
                    </div>
                    <div class="position-detail">
                      <div class="position-detail-value">\${pos.poolShare > 0 ? pos.poolShare.toFixed(4) + '%' : '--'}</div>
                      <div class="position-detail-label">Pool Share</div>
                    </div>
                    <div class="position-detail">
                      <div class="position-detail-value">\${pos.fee}</div>
                      <div class="position-detail-label">Fee Tier</div>
                    </div>
                    <div class="position-detail">
                      <div class="position-detail-value">#\${pos.tokenId}</div>
                      <div class="position-detail-label">ID</div>
                    </div>
                  </div>
                  <div class="position-actions">
                    \${pos.isClosed ? '' : \`<button class="position-btn remove" onclick="\${pos.isV4 ? 'openV4RemoveModal' : 'openV3RemoveModal'}(\${pos.tokenId}, '\${pos.token0}', '\${pos.token1}', '\${pos.token0Address || ''}', '\${pos.token1Address || ''}', '\${pos.liquidity}', '\${pos.fee}')">- Remove</button>\`}
                    \${pos.isV4 && !pos.isClosed && hasFees ? \`<button class="position-btn collect" onclick="collectV4Fees(\${pos.tokenId}, '\${pos.token0Address || ''}', '\${pos.token1Address || ''}')">Collect</button>\` : ''}
                    \${pos.isV3 && hasFees ? \`<button class="position-btn collect" onclick="collectV3Fees(\${pos.tokenId}, '\${pos.token0Address || ''}', '\${pos.token1Address || ''}')">Collect</button>\` : ''}
                    <button class="position-btn add" onclick="addToExistingPosition('\${pos.isV4 ? 'v4' : 'v3'}', '\${pos.poolId || pos.poolAddress || ''}', '\${pos.token0}', '\${pos.token1}', '\${pos.token0Address || ''}', '\${pos.token1Address || ''}', '\${pos.feeRaw || ''}', '\${pos.tickSpacing || ''}')">+ Add</button>
                    <a href="https://dexscreener.com/base/\${pos.poolId || pos.poolAddress || matchingPool?.pairAddress || pos.token1Address || pos.token0Address || ''}" target="_blank" class="position-btn info">Info</a>
                  </div>
                </div>
              \`;
            }

            // V2 position card
            const usdDisplay = pos.usdValue && pos.usdValue > 0.01
              ? '$' + pos.usdValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })
              : pos.usdValue > 0 ? '<$0.01' : '--';
            return \`
              <div class="position-card">
                <div class="position-top">
                  <div class="position-pair">
                    <div class="position-icons">
                      \${tokenIcon(pos.token0, 'position-icon')}
                      \${tokenIcon(pos.token1, 'position-icon')}
                    </div>
                    <span class="position-name">\${pos.pair}</span>
                    <span class="position-badge">\${pos.type}</span>
                  </div>
                  <div class="position-value">
                    <div class="position-value-amount usd-value">\${usdDisplay}</div>
                    <div class="position-value-label">My Value</div>
                  </div>
                </div>
                \${buildPoolStats(matchingPool, pos)}
                <div class="position-details">
                  <div class="position-detail">
                    <div class="position-detail-value">\${formatNumber(pos.token0Amount)}</div>
                    <div class="position-detail-label">\${pos.token0}</div>
                  </div>
                  <div class="position-detail">
                    <div class="position-detail-value">\${formatNumber(pos.token1Amount)}</div>
                    <div class="position-detail-label">\${pos.token1}</div>
                  </div>
                  <div class="position-detail">
                    <div class="position-detail-value">\${pos.sharePercent.toFixed(4)}%</div>
                    <div class="position-detail-label">Pool Share</div>
                  </div>
                </div>
                <div class="position-actions">
                  <button class="position-btn add" onclick="addToPosition('\${pos.poolAddress}')">+ Add</button>
                  <button class="position-btn remove" onclick="removeFromPosition('\${pos.poolAddress}', '\${pos.token0}', '\${pos.token1}', '\${pos.token0Address}', '\${pos.token1Address}', '\${pos.token0Decimals || 18}', '\${pos.token1Decimals || 18}')">- Remove</button>
                  <a href="https://dexscreener.com/base/\${pos.poolAddress}" target="_blank" class="position-btn info">Info</a>
                </div>
              </div>
            \`;
          }).join('');
          console.log('[ArbMe] Rendered', positionsEl.childElementCount, 'position cards');
        }

        // Cache positions for faster loads next time
        setCachedPositions(connectedWallet, positions);
        console.log('[ArbMe] Cached', positions.length, 'positions');

        // Update collapsible height - always update to show all positions
        const content = document.getElementById('positions-content');
        content.classList.remove('collapsed');
        document.getElementById('positions-header').classList.remove('collapsed');
        positionsExpanded = true;
        // Use setTimeout to ensure DOM has updated
        setTimeout(() => {
          content.style.maxHeight = content.scrollHeight + 'px';
          console.log('[ArbMe] Updated max-height to:', content.scrollHeight);
        }, 50);
      } catch (e) {
        console.error('[ArbMe] Failed to load positions:', e);
        positionsEl.innerHTML = '<div class="loading"><div class="error-text">Failed to load positions</div></div>';
      }
    }

    // Render pools
    function renderPools(pools, showAll) {
      const poolsEl = document.getElementById('pools');
      const showMoreBtn = document.getElementById('show-more-btn');
      const displayPools = showAll ? pools : pools.slice(0, POOLS_PREVIEW_COUNT);

      poolsEl.innerHTML = displayPools.map(p => {
        const addr = p.pairAddress || '';
        const tokens = p.pair.split(/\\s*\\/\\s*/);
        const token0 = tokens[0] || '?';
        const token1 = tokens[1] || '?';
        const change = p.priceChange24h || 0;
        const changeClass = change >= 0 ? 'positive' : 'negative';
        const dexType = p.dex.includes('V4') ? 'v4' : p.dex.includes('V3') ? 'v3' : 'v2';
        const priceHtml = p.priceUsd ? \`<div class="pool-price">\${formatPrice(p.priceUsd)}</div>\` : '';

        // Calculate APR from 24h volume and TVL using actual pool fee
        const feeRate = p.fee ? (p.fee / 1000000) : 0.003; // Convert from basis points or use 0.3% default
        const apr = p.tvl > 0 && p.volume24h > 0 ? ((p.volume24h * feeRate / p.tvl) * 365 * 100) : 0;
        const aprDisplay = apr > 0 ? apr.toFixed(1) + '%' : '--';
        const aprClass = apr >= 100 ? 'apr-high' : apr >= 20 ? 'apr-medium' : '';

        // Format fee tier for display (e.g., 10000 -> "1%", 30000 -> "3%")
        const feeDisplay = p.fee ? (p.fee / 10000).toFixed(p.fee % 10000 === 0 ? 0 : 2) + '%' : '';
        const feeBadge = feeDisplay ? '<span class="pool-fee-badge">' + feeDisplay + '</span>' : '';
        // Low liquidity warning for pools with TVL < $1
        const lowLiqBadge = p.tvl < 1 ? '<span class="pool-badge low-liq">Low Liq</span>' : '';

        return \`
        <div class="pool">
          <div class="pool-top">
            <div class="pool-icons">
              \${tokenIcon(token0)}
              \${tokenIcon(token1)}
            </div>
            <div class="pool-info" onclick="openPool('\${p.url || 'https://dexscreener.com/base/' + addr}')">
              <div class="pool-name">\${p.pair}</div>
              <div class="pool-meta">
                <span class="pool-dex">\${p.dex.replace('Uniswap ', '')}</span>
                \${getVersionBadge(p.dex)}
                \${feeBadge}
                \${lowLiqBadge}
              </div>
              \${priceHtml}
            </div>
            <button class="pool-add-btn" onclick="addLiquidityToPool('\${addr}', '\${dexType}', '\${p.pair}')" title="Add Liquidity">+</button>
          </div>
          <div class="pool-stats" onclick="openPool('\${p.url || 'https://dexscreener.com/base/' + addr}')">
            <div class="pool-stat">
              <div class="pool-stat-label">TVL</div>
              <div class="pool-stat-value tvl">\${formatUsd(p.tvl)}</div>
            </div>
            <div class="pool-stat">
              <div class="pool-stat-label">24h Vol</div>
              <div class="pool-stat-value">\${formatUsd(p.volume24h || 0)}</div>
            </div>
            <div class="pool-stat">
              <div class="pool-stat-label">APR</div>
              <div class="pool-stat-value apr \${aprClass}">\${aprDisplay}</div>
            </div>
            <div class="pool-stat">
              <div class="pool-stat-label">24h</div>
              <div class="pool-stat-value change \${changeClass}">\${formatChange(change)}</div>
            </div>
          </div>
        </div>
      \`}).join('');

      // Show/hide "show more" button
      if (pools.length > POOLS_PREVIEW_COUNT) {
        showMoreBtn.style.display = 'block';
        showMoreBtn.textContent = showAll ? 'Show less' : \`Show all \${pools.length} pools\`;
      } else {
        showMoreBtn.style.display = 'none';
      }
    }

    // Load pools
    async function loadPools() {
      const poolsEl = document.getElementById('pools');
      const refreshBtn = document.getElementById('refresh-btn');
      refreshBtn.classList.add('loading');

      try {
        const res = await fetch('/pools');
        const data = await res.json();
        poolsData = data;

        document.getElementById('price').textContent = formatPrice(data.arbmePrice);

        const topPool = data.pools[0];
        if (topPool?.priceChange24h !== undefined) {
          const changeEl = document.getElementById('price-change');
          const change = topPool.priceChange24h;
          changeEl.textContent = formatChange(change);
          changeEl.className = 'price-change ' + (change >= 0 ? 'positive' : 'negative');
          changeEl.style.display = 'inline';
        }

        // Merge API pools with custom pools (custom pools that aren't already in API response)
        const apiPoolAddrs = new Set(data.pools.map(p => p.pairAddress?.toLowerCase()));
        const newCustomPools = customPools.filter(cp => !apiPoolAddrs.has(cp.pairAddress?.toLowerCase()));
        const allPools = [...data.pools, ...newCustomPools];

        document.getElementById('pool-count').textContent = allPools.length;
        document.getElementById('total-tvl').textContent = formatUsd(data.totalTvl);

        const totalVol = allPools.reduce((sum, p) => sum + (p.volume24h || 0), 0);
        document.getElementById('total-vol').textContent = formatUsd(totalVol);

        renderPools(allPools, showAllPools);
      } catch (e) {
        console.error('[ArbMe] Failed to load pools:', e);
        poolsEl.innerHTML = '<div class="loading"><div class="error-text">Failed to load pools</div></div>';
      } finally {
        refreshBtn.classList.remove('loading');
      }
    }

    // Actions using SDK transactions
    window.openPool = async function(url) {
      try {
        await sdk.actions.openUrl({ url });
      } catch (e) {
        window.open(url, '_blank');
      }
    };

    window.managePositions = async function() {
      // Open Uniswap positions page for connected wallet
      const url = 'https://app.uniswap.org/positions?chain=base';
      try {
        await sdk.actions.openUrl({ url });
      } catch (e) {
        window.open(url, '_blank');
      }
    };

    window.addLiquidityToPool = async function(poolAddress, dexType, pair) {
      console.log('[ArbMe] Adding liquidity to:', poolAddress, dexType, pair);

      if (!connectedWallet) {
        setTxStatus('Connect wallet first', 'error');
        await connectWallet();
        return;
      }

      if (dexType === 'v2') {
        // V2: Fetch token addresses from the pair contract
        try {
          const [token0Res, token1Res] = await Promise.all([
            fetch(\`/test/rpc?action=pairToken0&pool=\${poolAddress}\`),
            fetch(\`/test/rpc?action=pairToken1&pool=\${poolAddress}\`)
          ]);
          const token0Data = await token0Res.json();
          const token1Data = await token1Res.json();

          if (token0Data.error || token1Data.error) {
            console.error('[ArbMe] Failed to fetch pair tokens:', token0Data.error, token1Data.error);
            setTxStatus('Failed to fetch pool token info', 'error');
            return;
          }

          // Get token info (symbols and decimals) - uses cache
          const [info0, info1] = await Promise.all([
            fetchTokenInfoCached(token0Data.token),
            fetchTokenInfoCached(token1Data.token)
          ]);

          // Validate decimals - NEVER default to 18
          const dec0 = toSafeDecimals(info0.decimals);
          const dec1 = toSafeDecimals(info1.decimals);
          if (dec0 === null) {
            throw new Error(\`Could not verify decimals for \${info0.symbol || token0Data.token}\`);
          }
          if (dec1 === null) {
            throw new Error(\`Could not verify decimals for \${info1.symbol || token1Data.token}\`);
          }

          modalPool = {
            address: poolAddress,
            dexType: dexType,
            pair: pair,
            token0: token0Data.token,
            token1: token1Data.token,
            token0Symbol: info0.symbol || getTokenSymbol(token0Data.token),
            token1Symbol: info1.symbol || getTokenSymbol(token1Data.token),
            token0Decimals: dec0,
            token1Decimals: dec1,
          };
          await openLiquidityModal();
        } catch (e) {
          console.error('[ArbMe] Failed to setup V2 add liquidity:', e);
          setTxStatus('Failed: ' + (e.message || 'Unknown error'), 'error');
        }
      } else if (dexType === 'v3') {
        // V3: Open V3 add liquidity modal
        await openV3AddLiquidityModal(poolAddress, pair);
      } else if (dexType === 'v4') {
        // V4: Open V4 add liquidity modal
        await openV4AddLiquidityModal(poolAddress, pair);
      }
    };

    // Modal functions
    function setTxStatus(message, type) {
      const el = document.getElementById('tx-status');
      el.textContent = message;
      el.className = 'tx-status ' + type;
    }

    function clearTxStatus() {
      const el = document.getElementById('tx-status');
      el.className = 'tx-status';
      el.textContent = '';
    }

    async function openLiquidityModal() {
      console.log('[ArbMe] Opening liquidity modal for', modalPool);
      const modal = document.getElementById('liquidity-modal');
      modal.classList.add('visible');
      clearTxStatus();

      // Update modal title
      document.getElementById('modal-title').textContent = \`Add Liquidity: \${modalPool.token0Symbol}/\${modalPool.token1Symbol}\`;

      // Update token labels and symbols
      document.getElementById('token0-label').textContent = \`\${modalPool.token0Symbol} Amount\`;
      document.getElementById('token1-label').textContent = \`\${modalPool.token1Symbol} Amount\`;
      document.getElementById('token0-symbol').textContent = modalPool.token0Symbol;
      document.getElementById('token1-symbol').textContent = modalPool.token1Symbol;
      document.getElementById('token0-symbol-approval').textContent = modalPool.token0Symbol;
      document.getElementById('token1-symbol-approval').textContent = modalPool.token1Symbol;

      // Update token icons
      const icon0 = getTokenIcon(modalPool.token0Symbol);
      const icon1 = getTokenIcon(modalPool.token1Symbol);
      if (icon0) document.getElementById('token0-icon').src = icon0;
      if (icon1) document.getElementById('token1-icon').src = icon1;

      // Reset state
      token0Approved = false;
      token1Approved = false;
      token0Balance = 0;
      token1Balance = 0;
      document.getElementById('token0-input').value = '';
      document.getElementById('token1-input').value = '';
      document.getElementById('token0-balance').textContent = 'Balance: Loading...';
      document.getElementById('token1-balance').textContent = 'Balance: Loading...';

      // Reset approval UI to checking state
      document.getElementById('approval-section').style.display = 'block';
      document.getElementById('token0-approval-check').className = 'approval-check pending';
      document.getElementById('token0-approval-check').textContent = '?';
      document.getElementById('token0-approval-text').textContent = 'Checking...';
      document.getElementById('token1-approval-check').className = 'approval-check pending';
      document.getElementById('token1-approval-check').textContent = '?';
      document.getElementById('token1-approval-text').textContent = 'Checking...';
      document.getElementById('approve-btn').style.display = 'none';

      // Load balances and approvals (using settleAll for graceful partial failure handling)
      await settleAll([loadBalances(), checkApprovals()], ['loadBalances', 'checkApprovals']);
    }

    window.closeModal = function() {
      document.getElementById('liquidity-modal').classList.remove('visible');
      modalPool = null;
      clearTxStatus();
    };

    window.setMaxToken0 = function() {
      document.getElementById('token0-input').value = token0Balance.toString();
    };

    window.setMaxToken1 = function() {
      document.getElementById('token1-input').value = token1Balance.toString();
    };

    async function loadBalances() {
      if (!connectedWallet || !modalPool) return;

      try {
        // Fetch token balances via our API
        const [bal0Res, bal1Res] = await Promise.all([
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${modalPool.token0}\`),
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${modalPool.token1}\`)
        ]);
        const bal0 = await bal0Res.json();
        const bal1 = await bal1Res.json();

        token0Balance = bal0.balanceFormatted || 0;
        token1Balance = bal1.balanceFormatted || 0;

        document.getElementById('token0-balance').textContent = \`Balance: \${formatNumber(token0Balance)}\`;
        document.getElementById('token1-balance').textContent = \`Balance: \${formatNumber(token1Balance)}\`;
      } catch (e) {
        console.error('[ArbMe] Failed to load balances:', e);
      }
    }

    async function checkApprovals() {
      if (!connectedWallet || !modalPool) {
        console.log('[ArbMe] checkApprovals: no wallet or modalPool');
        return;
      }

      console.log('[ArbMe] Checking approvals for wallet:', connectedWallet);
      console.log('[ArbMe] Token0:', modalPool.token0, 'Token1:', modalPool.token1);
      console.log('[ArbMe] Spender (V2 Router):', V2_ROUTER);

      // Use consolidated utility (P2.12)
      const result = await checkPairAllowances(
        connectedWallet,
        modalPool.token0,
        modalPool.token1,
        V2_ROUTER
      );

      console.log('[ArbMe] PAGE allowance approved:', result.token0Approved);
      console.log('[ArbMe] ARBME allowance approved:', result.token1Approved);

      token0Approved = result.token0Approved;
      token1Approved = result.token1Approved;

      console.log('[ArbMe] token0Approved:', token0Approved, 'token1Approved:', token1Approved);

      if (result.error) {
        console.error('[ArbMe] Failed to check approvals:', result.error);
        document.getElementById('token0-approval-text').textContent = 'Error checking';
        document.getElementById('token1-approval-text').textContent = 'Error checking';
        return;
      }

      updateApprovalUI();
    }

    function updateApprovalUI() {
      const check0 = document.getElementById('token0-approval-check');
      const text0 = document.getElementById('token0-approval-text');
      const check1 = document.getElementById('token1-approval-check');
      const text1 = document.getElementById('token1-approval-text');
      const approveBtn = document.getElementById('approve-btn');
      const addBtn = document.getElementById('add-liquidity-btn');

      if (token0Approved) {
        check0.className = 'approval-check approved';
        check0.textContent = 'â';
        text0.textContent = 'Approved';
      } else {
        check0.className = 'approval-check pending';
        check0.textContent = 'â';
        text0.textContent = 'Needs approval';
      }

      if (token1Approved) {
        check1.className = 'approval-check approved';
        check1.textContent = 'â';
        text1.textContent = 'Approved';
      } else {
        check1.className = 'approval-check pending';
        check1.textContent = 'â';
        text1.textContent = 'Needs approval';
      }

      // Show approve button if either token needs approval
      if (!token0Approved || !token1Approved) {
        approveBtn.style.display = 'block';
        addBtn.textContent = 'Add Liquidity';
      } else {
        approveBtn.style.display = 'none';
        addBtn.textContent = 'Add Liquidity';
      }
    }

    window.approveTokens = async function() {
      if (!connectedWallet || !modalPool) return;

      const approveBtn = document.getElementById('approve-btn');
      approveBtn.disabled = true;
      approveBtn.textContent = 'Approving...';

      try {
        const provider = sdk.wallet.ethProvider;
        if (!provider) throw new Error('No wallet provider');

        // Get amounts from input fields for exact approval
        const amount0 = parseFloat(document.getElementById('token0-input').value) || 0;
        const amount1 = parseFloat(document.getElementById('token1-input').value) || 0;

        if (amount0 <= 0 && amount1 <= 0) {
          setTxStatus('Enter amounts first', 'error');
          approveBtn.disabled = false;
          approveBtn.textContent = 'Approve Tokens';
          return;
        }

        // Calculate exact approval amounts + 10% buffer
        const amount0Raw = BigInt(Math.floor(amount0 * 1.1 * Math.pow(10, modalPool.token0Decimals || 18)));
        const amount1Raw = BigInt(Math.floor(amount1 * 1.1 * Math.pow(10, modalPool.token1Decimals || 18)));

        // Approve token0 if needed
        if (!token0Approved && amount0 > 0) {
          setTxStatus(\`Approving \${modalPool.token0Symbol}...\`, 'pending');
          const amount0Hex = amount0Raw.toString(16).padStart(64, '0');
          const approveTx0 = await sdk.wallet.ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: connectedWallet,
              to: modalPool.token0,
              data: '0x095ea7b3' + V2_ROUTER.slice(2).padStart(64, '0') + amount0Hex,
              gas: '0x15F90', // 90000
              value: '0x0',
            }]
          });
          console.log('[ArbMe] Approve token0 tx:', approveTx0);
          token0Approved = true;
        }

        // Approve token1 if needed
        if (!token1Approved && amount1 > 0) {
          setTxStatus(\`Approving \${modalPool.token1Symbol}...\`, 'pending');
          const amount1Hex = amount1Raw.toString(16).padStart(64, '0');
          const approveTx1 = await sdk.wallet.ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: connectedWallet,
              to: modalPool.token1,
              data: '0x095ea7b3' + V2_ROUTER.slice(2).padStart(64, '0') + amount1Hex,
              gas: '0x15F90', // 90000
              value: '0x0',
            }]
          });
          console.log('[ArbMe] Approve token1 tx:', approveTx1);
          token1Approved = true;
        }

        setTxStatus('Tokens approved!', 'success');
        updateApprovalUI();
      } catch (e) {
        console.error('[ArbMe] Approval failed:', e);
        setTxStatus('Approval failed: ' + (e.message || 'Unknown error'), 'error');
      } finally {
        approveBtn.disabled = false;
        approveBtn.textContent = 'Approve Tokens';
      }
    };

    window.executeLiquidity = async function() {
      if (!connectedWallet || !modalPool) return;

      const amount0 = parseFloat(document.getElementById('token0-input').value) || 0;
      const amount1 = parseFloat(document.getElementById('token1-input').value) || 0;

      if (amount0 <= 0 || amount1 <= 0) {
        setTxStatus('Enter amounts for both tokens', 'error');
        return;
      }

      if (!token0Approved || !token1Approved) {
        setTxStatus('Please approve tokens first', 'error');
        return;
      }

      const addBtn = document.getElementById('add-liquidity-btn');
      addBtn.disabled = true;
      addBtn.textContent = 'Adding Liquidity...';

      try {
        const provider = sdk.wallet.ethProvider;
        if (!provider) throw new Error('No wallet provider');

        setTxStatus('Verifying token decimals...', 'pending');

        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        // CRITICAL: Verify decimals on-chain before transaction
        // This prevents catastrophic loss from decimal mismatches
        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        const decimalVerification = await verifyPairDecimalsOnChain(
          modalPool.token0,
          modalPool.token1,
          modalPool.token0Decimals,
          modalPool.token1Decimals,
          modalPool.token0Symbol,
          modalPool.token1Symbol
        );

        if (!decimalVerification.verified) {
          setTxStatus('BLOCKED: ' + decimalVerification.errors.join('; '), 'error');
          const addBtn = document.getElementById('add-liquidity-btn');
          addBtn.disabled = false;
          addBtn.textContent = 'Add Liquidity';
          return;
        }

        setTxStatus('Preparing transaction...', 'pending');

        // Convert amounts to raw values
        const amount0Raw = BigInt(Math.floor(amount0 * Math.pow(10, modalPool.token0Decimals)));
        const amount1Raw = BigInt(Math.floor(amount1 * Math.pow(10, modalPool.token1Decimals)));

        // Calculate min amounts (5% slippage)
        const amount0Min = amount0Raw * BigInt(95) / BigInt(100);
        const amount1Min = amount1Raw * BigInt(95) / BigInt(100);

        // Deadline: 20 minutes from now
        const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

        // Encode addLiquidity call
        // addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline)
        const calldata = '0xe8e33700' +
          modalPool.token0.slice(2).padStart(64, '0') +
          modalPool.token1.slice(2).padStart(64, '0') +
          amount0Raw.toString(16).padStart(64, '0') +
          amount1Raw.toString(16).padStart(64, '0') +
          amount0Min.toString(16).padStart(64, '0') +
          amount1Min.toString(16).padStart(64, '0') +
          connectedWallet.slice(2).padStart(64, '0') +
          deadline.toString(16).padStart(64, '0');

        setTxStatus('Confirm in your wallet...', 'pending');

        const tx = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V2_ROUTER,
            data: calldata,
            gas: '0x7A120', // 500000
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Add liquidity tx:', tx);
        setTxStatus('Liquidity added! TX: ' + tx.slice(0, 10) + '...', 'success');

        // Refresh positions after a delay
        setTimeout(() => {
          loadPositions();
          closeModal();
        }, 3000);

      } catch (e) {
        console.error('[ArbMe] Add liquidity failed:', e);
        setTxStatus('Failed: ' + (e.message || 'Transaction rejected'), 'error');
      } finally {
        addBtn.disabled = false;
        addBtn.textContent = 'Add Liquidity';
      }
    };

    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    // Create Position Modal Functions
    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

    // Wallet tokens cache
    let walletTokensCache = null;
    let walletTokensCacheTime = 0;
    const WALLET_TOKENS_CACHE_TTL = 60000; // 60 seconds

    // Load wallet tokens from backend
    async function loadWalletTokens() {
      if (!connectedWallet) return [];

      // Check cache
      const now = Date.now();
      if (walletTokensCache && (now - walletTokensCacheTime) < WALLET_TOKENS_CACHE_TTL) {
        console.log('[ArbMe] Using cached wallet tokens');
        return walletTokensCache;
      }

      try {
        console.log('[ArbMe] Fetching wallet tokens for', connectedWallet);
        const res = await fetch('/test/rpc?action=walletTokens&wallet=' + connectedWallet);
        const data = await res.json();
        if (data.tokens) {
          walletTokensCache = data.tokens;
          walletTokensCacheTime = now;
          console.log('[ArbMe] Got', data.tokens.length, 'wallet tokens');
          return data.tokens;
        }
      } catch (e) {
        console.error('[ArbMe] Failed to load wallet tokens:', e);
      }
      return [];
    }

    // Store tokens for each dropdown for filtering
    let dropdownTokensA = [];
    let dropdownTokensB = [];

    // Populate dropdown with tokens
    function populateTokenDropdown(tokens, which) {
      const listEl = document.getElementById('token' + which + '-dropdown-list');
      if (!listEl) return;

      // Sort tokens by USD value of holdings (highest first), then alphabetically
      const sortedTokens = [...tokens].sort((a, b) => {
        const aValue = a.valueUsd || 0;
        const bValue = b.valueUsd || 0;
        // Sort by USD value descending
        if (bValue !== aValue) return bValue - aValue;
        // Then alphabetically by symbol (with null safety)
        return (a.symbol || '').localeCompare(b.symbol || '');
      });

      // Store for filtering
      if (which === 'A') dropdownTokensA = sortedTokens;
      else dropdownTokensB = sortedTokens;

      listEl.innerHTML = '';

      // Add search input
      const searchDiv = document.createElement('div');
      searchDiv.className = 'token-dropdown-search';
      searchDiv.innerHTML = '<input type="text" id="token' + which + '-search" placeholder="Search by symbol or name..." autocomplete="off">';
      listEl.appendChild(searchDiv);

      // Add items container
      const itemsContainer = document.createElement('div');
      itemsContainer.className = 'token-dropdown-items';
      itemsContainer.id = 'token' + which + '-items';
      listEl.appendChild(itemsContainer);

      // Render tokens
      renderFilteredTokens(sortedTokens, which, '');

      // Setup search listener
      const searchInput = document.getElementById('token' + which + '-search');
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase().trim();
        const allTokens = which === 'A' ? dropdownTokensA : dropdownTokensB;
        renderFilteredTokens(allTokens, which, query);
      });

      // Prevent dropdown close when clicking search
      searchInput.addEventListener('click', (e) => {
        e.stopPropagation();
      });
    }

    // Escape HTML to prevent XSS and display issues
    function escapeHtml(str) {
      if (!str) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Render filtered token list
    function renderFilteredTokens(tokens, which, query) {
      const itemsContainer = document.getElementById('token' + which + '-items');
      if (!itemsContainer) return;

      itemsContainer.innerHTML = '';

      // Filter tokens (with null safety)
      const filtered = query ? tokens.filter(t =>
        (t.symbol || '').toLowerCase().includes(query) ||
        (t.name || '').toLowerCase().includes(query) ||
        (t.address || '').toLowerCase().includes(query)
      ) : tokens;

      if (filtered.length === 0 && query) {
        itemsContainer.innerHTML = '<div class="token-dropdown-empty">No matches for "' + escapeHtml(query) + '"</div>';
      } else if (filtered.length === 0) {
        itemsContainer.innerHTML = '<div class="token-dropdown-empty">No tokens in wallet</div>';
      } else {
        filtered.forEach(token => {
          const item = document.createElement('div');
          item.className = 'token-dropdown-item';
          item.onclick = () => selectTokenFromDropdown(token, which);

          // Safely handle icon - use createElement to avoid HTML injection
          const defaultIcon = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#666"><circle cx="12" cy="12" r="10"/></svg>');
          const balanceStr = token.balance > 1000000 ? (token.balance / 1000000).toFixed(2) + 'M' :
                            token.balance > 1000 ? (token.balance / 1000).toFixed(2) + 'K' :
                            token.balance.toFixed(token.balance < 1 ? 6 : 2);
          const valueStr = token.valueUsd > 0 ? '$' + (token.valueUsd > 1000 ? (token.valueUsd / 1000).toFixed(1) + 'K' : token.valueUsd.toFixed(2)) : '';

          // Build item using DOM methods to avoid XSS
          const img = document.createElement('img');
          img.className = 'token-icon';
          img.src = token.icon || getTokenIconByAddress(token.address) || getTokenIcon(token.symbol) || defaultIcon;
          img.onerror = function() { this.style.display = 'none'; };

          const infoDiv = document.createElement('div');
          infoDiv.className = 'token-info';
          const symbolDiv = document.createElement('div');
          symbolDiv.className = 'token-symbol';
          symbolDiv.textContent = token.symbol || '???';
          const nameDiv = document.createElement('div');
          nameDiv.className = 'token-name';
          nameDiv.textContent = token.name || 'Unknown Token';
          infoDiv.appendChild(symbolDiv);
          infoDiv.appendChild(nameDiv);

          const amountsDiv = document.createElement('div');
          amountsDiv.className = 'token-amounts';
          const balanceDiv = document.createElement('div');
          balanceDiv.className = 'token-balance';
          balanceDiv.textContent = balanceStr;
          const valueDiv = document.createElement('div');
          valueDiv.className = 'token-value';
          if (token.priceUsd > 0) {
            valueDiv.textContent = valueStr;
          } else {
            valueDiv.innerHTML = '<span class="no-price">price unknown</span>';
          }
          amountsDiv.appendChild(balanceDiv);
          amountsDiv.appendChild(valueDiv);

          item.appendChild(img);
          item.appendChild(infoDiv);
          item.appendChild(amountsDiv);

          itemsContainer.appendChild(item);
        });
      }

      // Add custom entry option at the end
      const customItem = document.createElement('div');
      customItem.className = 'token-dropdown-item custom-entry';
      customItem.textContent = '+ Enter custom address';
      customItem.onclick = () => {
        toggleCustomAddress(which);
        closeTokenDropdown(which);
      };
      itemsContainer.appendChild(customItem);
    }

    // Toggle dropdown open/closed
    window.toggleTokenDropdown = function(which) {
      const toggleEl = document.getElementById('token' + which + '-dropdown-toggle');
      const listEl = document.getElementById('token' + which + '-dropdown-list');

      const isOpen = listEl.classList.contains('open');

      // Close all dropdowns first
      document.querySelectorAll('.token-dropdown-list').forEach(el => el.classList.remove('open'));
      document.querySelectorAll('.token-dropdown-toggle').forEach(el => el.classList.remove('open'));

      if (!isOpen) {
        toggleEl.classList.add('open');
        listEl.classList.add('open');
        // Auto-focus search input and clear it
        const searchInput = document.getElementById('token' + which + '-search');
        if (searchInput) {
          searchInput.value = '';
          setTimeout(() => searchInput.focus(), 50);
          // Reset to show all tokens
          const allTokens = which === 'A' ? dropdownTokensA : dropdownTokensB;
          renderFilteredTokens(allTokens, which, '');
        }
      }
    };

    // Close dropdown
    function closeTokenDropdown(which) {
      const toggleEl = document.getElementById('token' + which + '-dropdown-toggle');
      const listEl = document.getElementById('token' + which + '-dropdown-list');
      if (toggleEl) toggleEl.classList.remove('open');
      if (listEl) listEl.classList.remove('open');
    }

    // Toggle between dropdown and custom address input
    window.toggleCustomAddress = function(which) {
      const dropdownContainer = document.getElementById('token' + which + '-dropdown-container');
      const addressRow = document.getElementById('token' + which + '-address-row');
      const toggleText = document.getElementById('token' + which + '-custom-toggle');

      const isCustomMode = addressRow.style.display !== 'none';

      if (isCustomMode) {
        // Switch to dropdown mode
        dropdownContainer.style.display = 'block';
        addressRow.style.display = 'none';
        toggleText.textContent = 'or enter address manually';
      } else {
        // Switch to custom address mode
        dropdownContainer.style.display = 'none';
        addressRow.style.display = 'flex';
        toggleText.textContent = 'or select from wallet';
        // Focus the input
        document.getElementById('token' + which + '-address').focus();
      }
    };

    // Select token from dropdown
    async function selectTokenFromDropdown(token, which) {
      console.log('[ArbMe] Selected token from dropdown:', token.symbol, which);

      // Close dropdown
      closeTokenDropdown(which);

      // Update dropdown toggle to show selected token using safe DOM methods
      const toggleEl = document.getElementById('token' + which + '-dropdown-toggle');
      const balanceStr = token.balance > 1000000 ? (token.balance / 1000000).toFixed(2) + 'M' :
                        token.balance > 1000 ? (token.balance / 1000).toFixed(2) + 'K' :
                        token.balance.toFixed(token.balance < 1 ? 6 : 2);

      // Clear and rebuild toggle content safely
      toggleEl.innerHTML = '';
      const previewDiv = document.createElement('div');
      previewDiv.className = 'token-preview';

      if (token.icon) {
        const img = document.createElement('img');
        img.className = 'token-icon';
        img.src = token.icon;
        img.onerror = function() { this.style.display = 'none'; };
        previewDiv.appendChild(img);
      }

      const symbolSpan = document.createElement('span');
      symbolSpan.className = 'token-symbol';
      symbolSpan.textContent = token.symbol || '???';
      previewDiv.appendChild(symbolSpan);

      const balanceSpan = document.createElement('span');
      balanceSpan.className = 'token-balance';
      balanceSpan.textContent = balanceStr;
      previewDiv.appendChild(balanceSpan);

      toggleEl.appendChild(previewDiv);

      // Add chevron
      const chevron = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      chevron.setAttribute('class', 'chevron');
      chevron.setAttribute('viewBox', '0 0 24 24');
      chevron.setAttribute('fill', 'none');
      chevron.setAttribute('stroke', 'currentColor');
      chevron.setAttribute('stroke-width', '2');
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', 'M6 9l6 6 6-6');
      chevron.appendChild(path);
      toggleEl.appendChild(chevron);

      // Build token object for internal use
      // CRITICAL: Verify decimals via direct on-chain RPC call
      // Do NOT trust Alchemy metadata - it can be wrong or default to 18
      console.log('[ArbMe] selectTokenFromDropdown - RAW TOKEN DATA:', JSON.stringify(token));
      console.log('[ArbMe] selectTokenFromDropdown - Alchemy decimals:', token.decimals, 'typeof:', typeof token.decimals);

      // Verify decimals on-chain before trusting them - uses cache
      let verifiedDecimals = null;
      let decimalsVerified = false;
      try {
        const infoData = await fetchTokenInfoCached(token.address);
        if (infoData && infoData.decimalsVerified && infoData.decimals !== null) {
          verifiedDecimals = infoData.decimals;
          decimalsVerified = true;
          console.log('[ArbMe] selectTokenFromDropdown - VERIFIED decimals via RPC:', verifiedDecimals);

          // Warn if Alchemy's decimals were wrong
          const parsedAlchemyDecimals = toSafeDecimals(token.decimals);
          if (parsedAlchemyDecimals !== null && parsedAlchemyDecimals !== verifiedDecimals) {
            console.warn('[ArbMe] WARNING: Alchemy decimals', token.decimals, 'differ from on-chain', verifiedDecimals);
          }
        } else {
          console.error('[ArbMe] selectTokenFromDropdown - Failed to verify decimals:', infoData.error);
        }
      } catch (e) {
        console.error('[ArbMe] selectTokenFromDropdown - RPC call failed:', e);
      }

      const tokenObj = {
        address: token.address,
        symbol: token.symbol,
        decimals: verifiedDecimals, // Use verified decimals or null if verification failed
        decimalsVerified: decimalsVerified,
        priceUsd: token.priceUsd,
        priceSource: token.priceSource,
        icon: token.icon,
        balance: token.balance,
        balanceRaw: token.balanceRaw
      };

      console.log('[ArbMe] selectTokenFromDropdown - FINAL tokenObj.decimals:', tokenObj.decimals, 'verified:', tokenObj.decimalsVerified);

      // Update global state
      if (which === 'A') {
        createTokenA = tokenObj;
        createTokenABalance = token.balance;
        document.getElementById('tokenA-symbol-display').textContent = token.symbol;
        document.getElementById('create-tokenA-label').textContent = token.symbol + ' Amount';
        document.getElementById('create-tokenA-symbol').textContent = token.symbol;
        document.getElementById('create-tokenA-balance').textContent = balanceStr;
        const icon = token.icon || getTokenIcon(token.symbol);
        if (icon) document.getElementById('create-tokenA-icon').src = icon;

        // Handle price badge
        const priceBadge = document.getElementById('tokenA-price-badge');
        const manualPriceDiv = document.getElementById('tokenA-manual-price');
        if (token.priceSource) {
          priceBadge.style.display = 'inline-block';
          priceBadge.className = 'price-source-badge verified';
          priceBadge.textContent = token.priceSource === 'alchemy' ? 'Alchemy' : 'GeckoTerminal';
          manualPriceDiv.style.display = 'none';
        } else {
          priceBadge.style.display = 'none';
          manualPriceDiv.style.display = 'block';
          document.getElementById('tokenA-manual-symbol').textContent = token.symbol;
        }
      } else {
        createTokenB = tokenObj;
        createTokenBBalance = token.balance;
        document.getElementById('tokenB-symbol-display').textContent = token.symbol;
        document.getElementById('create-tokenB-label').textContent = token.symbol + ' Amount';
        document.getElementById('create-tokenB-symbol').textContent = token.symbol;
        document.getElementById('create-tokenB-balance').textContent = balanceStr;
        const icon = token.icon || getTokenIcon(token.symbol);
        if (icon) document.getElementById('create-tokenB-icon').src = icon;

        // Handle price badge
        const priceBadge = document.getElementById('tokenB-price-badge');
        const manualPriceDiv = document.getElementById('tokenB-manual-price');
        if (token.priceSource) {
          priceBadge.style.display = 'inline-block';
          priceBadge.className = 'price-source-badge verified';
          priceBadge.textContent = token.priceSource === 'alchemy' ? 'Alchemy' : 'GeckoTerminal';
          manualPriceDiv.style.display = 'none';
        } else {
          priceBadge.style.display = 'none';
          manualPriceDiv.style.display = 'block';
          document.getElementById('tokenB-manual-symbol').textContent = token.symbol;
        }
      }

      // Update preview
      updateCreatePreview();
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.token-dropdown-container')) {
        document.querySelectorAll('.token-dropdown-list').forEach(el => el.classList.remove('open'));
        document.querySelectorAll('.token-dropdown-toggle').forEach(el => el.classList.remove('open'));
      }
    });

    window.openCreatePositionModal = async function() {
      if (!connectedWallet) {
        await connectWallet();
        if (!connectedWallet) return;
      }

      const modal = document.getElementById('create-position-modal');
      modal.classList.add('visible');
      document.getElementById('create-tx-status').className = 'tx-status';
      document.getElementById('create-tx-status').textContent = '';
      document.getElementById('create-success-tip').style.display = 'none';

      // Reset amount inputs and hide preview
      document.getElementById('create-tokenA-input').value = '';
      document.getElementById('create-tokenB-input').value = '';
      document.getElementById('create-tx-preview').style.display = 'none';

      // Reset token state
      createTokenA = null;
      createTokenB = null;
      createTokenABalance = 0;
      createTokenBBalance = 0;

      // Reset dropdown UI - show dropdowns, hide custom address inputs
      document.getElementById('tokenA-dropdown-container').style.display = 'block';
      document.getElementById('tokenA-address-row').style.display = 'none';
      document.getElementById('tokenA-custom-toggle').textContent = 'or enter address manually';
      document.getElementById('tokenA-dropdown-toggle').innerHTML = \`
        <div class="token-preview">
          <span style="color: var(--text-secondary);">Select from wallet...</span>
        </div>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
      \`;
      document.getElementById('tokenA-price-badge').style.display = 'none';
      document.getElementById('tokenA-manual-price').style.display = 'none';

      document.getElementById('tokenB-dropdown-container').style.display = 'block';
      document.getElementById('tokenB-address-row').style.display = 'none';
      document.getElementById('tokenB-custom-toggle').textContent = 'or enter address manually';
      document.getElementById('tokenB-dropdown-toggle').innerHTML = \`
        <div class="token-preview">
          <span style="color: var(--text-secondary);">Select from wallet...</span>
        </div>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
      \`;
      document.getElementById('tokenB-price-badge').style.display = 'none';
      document.getElementById('tokenB-manual-price').style.display = 'none';

      // Reset labels
      document.getElementById('create-tokenA-label').textContent = 'Token A Amount';
      document.getElementById('create-tokenB-label').textContent = 'Token B Amount';
      document.getElementById('create-tokenA-symbol').textContent = '';
      document.getElementById('create-tokenB-symbol').textContent = '';
      document.getElementById('create-tokenA-balance').textContent = '0';
      document.getElementById('create-tokenB-balance').textContent = '0';

      // Load wallet tokens and populate dropdowns
      const walletTokens = await loadWalletTokens();
      populateTokenDropdown(walletTokens, 'A');
      populateTokenDropdown(walletTokens, 'B');

      // Setup address input listeners (debounced) for custom address mode
      let tokenATimeout, tokenBTimeout;

      document.getElementById('tokenA-address').oninput = function() {
        clearTimeout(tokenATimeout);
        const validation = validateTokenAddress(this.value);
        if (validation.valid) {
          document.getElementById('tokenA-resolved').className = 'token-resolved loading';
          document.getElementById('tokenA-symbol-display').textContent = '...';
          tokenATimeout = setTimeout(() => resolveTokenA(validation.normalized), 500);
        } else if (this.value.trim().length > 0) {
          // Show validation error for non-empty invalid input
          document.getElementById('tokenA-resolved').className = 'token-resolved error';
          document.getElementById('tokenA-symbol-display').textContent = validation.error || 'Invalid';
        }
      };

      document.getElementById('tokenB-address').oninput = function() {
        clearTimeout(tokenBTimeout);
        const validation = validateTokenAddress(this.value);
        if (validation.valid) {
          document.getElementById('tokenB-resolved').className = 'token-resolved loading';
          document.getElementById('tokenB-symbol-display').textContent = '...';
          tokenBTimeout = setTimeout(() => resolveTokenB(validation.normalized), 500);
        } else if (this.value.trim().length > 0) {
          // Show validation error for non-empty invalid input
          document.getElementById('tokenB-resolved').className = 'token-resolved error';
          document.getElementById('tokenB-symbol-display').textContent = validation.error || 'Invalid';
        }
      };

      // Setup version selector listeners
      document.querySelectorAll('#version-selector .selector-option').forEach(opt => {
        opt.onclick = function() {
          document.querySelectorAll('#version-selector .selector-option').forEach(o => o.classList.remove('selected'));
          this.classList.add('selected');
          createSelectedVersion = this.dataset.version;
          // Show/hide fee selector based on version (V2 doesn't have fee tiers)
          const feeGroup = document.getElementById('create-fee-group');
          feeGroup.style.display = (createSelectedVersion === 'v3' || createSelectedVersion === 'v4') ? 'block' : 'none';
          // Update preview to show/hide price section for V4
          updateCreatePreview();
        };
      });

      // Setup fee selector listeners
      document.querySelectorAll('#create-fee-selector .selector-option').forEach(opt => {
        opt.onclick = function() {
          document.querySelectorAll('#create-fee-selector .selector-option').forEach(o => o.classList.remove('selected'));
          this.classList.add('selected');
          createSelectedFee = parseInt(this.dataset.fee);
        };
      });

      // Setup auto-balance for equal USD value
      setupAutoBalance();
    };

    async function resolveTokenA(address) {
      const token = await resolveToken(address);
      createTokenA = token;
      document.getElementById('tokenA-symbol-display').textContent = token.symbol;
      document.getElementById('tokenA-resolved').className = token.symbol === 'ERROR' ? 'token-resolved error' : 'token-resolved';
      document.getElementById('create-tokenA-label').textContent = token.symbol + ' Amount';
      document.getElementById('create-tokenA-symbol').textContent = token.symbol;
      const icon = getTokenIcon(token.symbol);
      if (icon) document.getElementById('create-tokenA-icon').src = icon;

      // Handle price source display
      const priceBadge = document.getElementById('tokenA-price-badge');
      const manualPriceDiv = document.getElementById('tokenA-manual-price');
      const manualSymbol = document.getElementById('tokenA-manual-symbol');
      manualSymbol.textContent = token.symbol;

      if (token.priceSource) {
        // Price was found - show badge, hide manual input
        priceBadge.style.display = 'inline-block';
        priceBadge.className = 'price-source-badge verified';
        priceBadge.textContent = token.priceSource === 'dexscreener' ? 'DexScreener' : 'GeckoTerminal';
        manualPriceDiv.style.display = 'none';
      } else if (token.decimalsVerified) {
        // Token valid but no price - show manual input
        priceBadge.style.display = 'none';
        manualPriceDiv.style.display = 'block';
        // Clear any previous manual price
        document.getElementById('tokenA-price-input').value = '';
      } else {
        // Token invalid - hide both
        priceBadge.style.display = 'none';
        manualPriceDiv.style.display = 'none';
      }

      await loadCreateBalances();
      updateCreatePreview();
    }

    async function resolveTokenB(address) {
      const token = await resolveToken(address);
      createTokenB = token;
      document.getElementById('tokenB-symbol-display').textContent = token.symbol;
      document.getElementById('tokenB-resolved').className = token.symbol === 'ERROR' ? 'token-resolved error' : 'token-resolved';
      document.getElementById('create-tokenB-label').textContent = token.symbol + ' Amount';
      document.getElementById('create-tokenB-symbol').textContent = token.symbol;
      const icon = getTokenIcon(token.symbol);
      if (icon) document.getElementById('create-tokenB-icon').src = icon;

      // Handle price source display
      const priceBadge = document.getElementById('tokenB-price-badge');
      const manualPriceDiv = document.getElementById('tokenB-manual-price');
      const manualSymbol = document.getElementById('tokenB-manual-symbol');
      manualSymbol.textContent = token.symbol;

      if (token.priceSource) {
        // Price was found - show badge, hide manual input
        priceBadge.style.display = 'inline-block';
        priceBadge.className = 'price-source-badge verified';
        priceBadge.textContent = token.priceSource === 'dexscreener' ? 'DexScreener' : 'GeckoTerminal';
        manualPriceDiv.style.display = 'none';
      } else if (token.decimalsVerified) {
        // Token valid but no price - show manual input
        priceBadge.style.display = 'none';
        manualPriceDiv.style.display = 'block';
        // Clear any previous manual price
        document.getElementById('tokenB-price-input').value = '';
      } else {
        // Token invalid - hide both
        priceBadge.style.display = 'none';
        manualPriceDiv.style.display = 'none';
      }

      await loadCreateBalances();
      updateCreatePreview();
    }

    // Resolve token address to get symbol/decimals/price
    // CRITICAL: Never defaults decimals - must be verified on-chain
    async function resolveToken(address) {
      try {
        // Fetch token info (cached) and price in parallel
        const [infoData, priceRes] = await Promise.all([
          fetchTokenInfoCached(address),
          fetch(\`https://api.dexscreener.com/latest/dex/tokens/\${address}\`)
        ]);

        // CRITICAL: Check if decimals were verified
        if (!infoData || infoData.error || !infoData.decimalsVerified) {
          console.error('[ArbMe] Token decimals not verified:', address, infoData?.error);
          return {
            address: address,
            symbol: infoData?.symbol || 'UNVERIFIED',
            decimals: null, // NULL signals unsafe - do not allow transactions
            decimalsVerified: false,
            error: infoData?.error || 'Could not verify token decimals',
            icon: '',
            priceUsd: 0
          };
        }

        let priceUsd = 0;
        let priceSource = null; // 'dexscreener', 'geckoterminal', or null (requires manual)
        try {
          const priceData = await priceRes.json();
          if (priceData.pairs && priceData.pairs.length > 0) {
            // Get price from highest liquidity pair
            const sortedPairs = priceData.pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0));
            priceUsd = parseFloat(sortedPairs[0].priceUsd) || 0;
            if (priceUsd > 0) priceSource = 'dexscreener';
          }
        } catch (e) {
          console.log('[ArbMe] DexScreener price fetch failed for', address);
        }

        // Fallback to GeckoTerminal via backend if DexScreener has no price
        if (priceUsd === 0) {
          try {
            const geckoRes = await fetch(\`/test/rpc?action=tokenPrices&tokens=\${address}\`);
            const geckoData = await geckoRes.json();
            priceUsd = geckoData.prices?.[address.toLowerCase()] || 0;
            if (priceUsd > 0) {
              priceSource = 'geckoterminal';
              console.log('[ArbMe] Got price from GeckoTerminal fallback:', priceUsd);
            } else {
              console.log('[ArbMe] No price found on DexScreener or GeckoTerminal for', address);
            }
          } catch (e) {
            console.log('[ArbMe] GeckoTerminal fallback failed for', address);
          }
        }
        return {
          address: address,
          symbol: infoData.symbol || address.slice(0, 6) + '...',
          decimals: infoData.decimals,
          decimalsVerified: true,
          icon: getTokenIcon(infoData.symbol) || '',
          priceUsd: priceUsd,
          priceSource: priceSource // null means manual entry required
        };
      } catch (e) {
        console.error('[ArbMe] Failed to resolve token:', e);
        return {
          address: address,
          symbol: 'ERROR',
          decimals: null, // NULL signals unsafe
          decimalsVerified: false,
          error: 'Failed to fetch token info',
          icon: '',
          priceUsd: 0,
          priceSource: null
        };
      }
    }

    // Auto-balance: when user changes one input, calculate the other for equal USD value
    // Update the transaction preview with USD values
    function updateCreatePreview() {
      const previewEl = document.getElementById('create-tx-preview');
      const amountA = parseFloat(document.getElementById('create-tokenA-input').value) || 0;
      const amountB = parseFloat(document.getElementById('create-tokenB-input').value) || 0;

      // Hide preview if no amounts
      if (amountA <= 0 && amountB <= 0) {
        previewEl.style.display = 'none';
        return;
      }

      // Show the preview
      previewEl.style.display = 'block';

      // Update labels
      document.getElementById('preview-tokenA-label').textContent = createTokenA.symbol + ':';
      document.getElementById('preview-tokenB-label').textContent = createTokenB.symbol + ':';

      // Calculate USD values
      const valueA = amountA * (createTokenA.priceUsd || 0);
      const valueB = amountB * (createTokenB.priceUsd || 0);
      const totalValue = valueA + valueB;

      // Format amounts
      document.getElementById('preview-tokenA-amount').textContent = formatNumber(amountA);
      document.getElementById('preview-tokenB-amount').textContent = formatNumber(amountB);

      // Format USD values
      const usdA = document.getElementById('preview-tokenA-usd');
      const usdB = document.getElementById('preview-tokenB-usd');
      if (createTokenA.priceUsd > 0) {
        usdA.textContent = '(~$' + formatNumber(valueA) + ')';
      } else {
        usdA.textContent = '(price unknown)';
      }
      if (createTokenB.priceUsd > 0) {
        usdB.textContent = '(~$' + formatNumber(valueB) + ')';
      } else {
        usdB.textContent = '(price unknown)';
      }

      // Total value
      if (createTokenA.priceUsd > 0 || createTokenB.priceUsd > 0) {
        document.getElementById('preview-total-value').textContent = '~$' + formatNumber(totalValue);
      } else {
        document.getElementById('preview-total-value').textContent = 'Unknown';
      }

      // Calculate and show initial price for new pools (V4 only)
      const priceSection = document.getElementById('preview-price-section');
      const warningEl = document.getElementById('preview-warning');

      if (createSelectedVersion === 'v4' && amountA > 0 && amountB > 0) {
        // Calculate price ratio (how many TokenB per TokenA)
        const priceRatio = amountB / amountA;
        priceSection.style.display = 'block';
        document.getElementById('preview-initial-price').textContent =
          '1 ' + createTokenA.symbol + ' = ' + formatNumber(priceRatio) + ' ' + createTokenB.symbol;

        // Check if price seems reasonable based on market prices
        if (createTokenA.priceUsd > 0 && createTokenB.priceUsd > 0) {
          const marketPrice = createTokenA.priceUsd / createTokenB.priceUsd;
          const deviation = Math.abs((priceRatio - marketPrice) / marketPrice);

          // Build warning messages
          let warnings = [];

          // Check for manual prices
          if (createTokenA.priceSource === 'manual' || createTokenB.priceSource === 'manual') {
            const manualTokens = [];
            if (createTokenA.priceSource === 'manual') manualTokens.push(createTokenA.symbol);
            if (createTokenB.priceSource === 'manual') manualTokens.push(createTokenB.symbol);
            warnings.push('Using manually entered price for ' + manualTokens.join(' and ') + '. Verify carefully before proceeding.');
          }

          // Check for price deviation
          if (deviation > 0.1) { // More than 10% deviation
            warnings.push('Your ratio differs from market price by ' + (deviation * 100).toFixed(1) + '%. This may create arbitrage opportunity.');
          }

          if (warnings.length > 0) {
            warningEl.style.display = 'block';
            warningEl.innerHTML = warnings.map(w => '<div>' + w + '</div>').join('');
          } else {
            warningEl.style.display = 'none';
          }
        } else {
          // At least one price is missing
          if (createTokenA.priceUsd === 0 || createTokenB.priceUsd === 0) {
            warningEl.style.display = 'block';
            const missing = [];
            if (createTokenA.priceUsd === 0) missing.push(createTokenA.symbol);
            if (createTokenB.priceUsd === 0) missing.push(createTokenB.symbol);
            warningEl.textContent = 'Enter price for ' + missing.join(' and ') + ' above to enable position creation.';
          } else {
            warningEl.style.display = 'none';
          }
        }
      } else {
        priceSection.style.display = 'none';
        // Still show warning if prices are missing (for V2/V3)
        if ((createTokenA.priceUsd === 0 || createTokenB.priceUsd === 0) && (amountA > 0 || amountB > 0)) {
          warningEl.style.display = 'block';
          const missing = [];
          if (createTokenA.priceUsd === 0) missing.push(createTokenA.symbol);
          if (createTokenB.priceUsd === 0) missing.push(createTokenB.symbol);
          warningEl.textContent = 'Enter price for ' + missing.join(' and ') + ' above to see USD values.';
        } else {
          warningEl.style.display = 'none';
        }
      }
    }

    function setupAutoBalance() {
      const inputA = document.getElementById('create-tokenA-input');
      const inputB = document.getElementById('create-tokenB-input');

      // Helper to show auto-balance hint
      function showAutoBalanceHint(missingToken) {
        const hintEl = document.getElementById('auto-balance-hint');
        if (hintEl) {
          hintEl.textContent = 'Auto-balance unavailable: ' + missingToken + ' price unknown';
          hintEl.style.display = 'block';
        }
        console.log('[ArbMe] Auto-balance unavailable - ' + missingToken + ' price unknown');
      }

      function hideAutoBalanceHint() {
        const hintEl = document.getElementById('auto-balance-hint');
        if (hintEl) {
          hintEl.style.display = 'none';
        }
      }

      inputA.oninput = function() {
        if (isAutoBalancing) return;
        const amountA = parseFloat(this.value) || 0;
        if (amountA > 0 && createTokenA.priceUsd > 0 && createTokenB.priceUsd > 0) {
          isAutoBalancing = true;
          const valueUsd = amountA * createTokenA.priceUsd;
          const amountB = valueUsd / createTokenB.priceUsd;
          inputB.value = amountB.toFixed(6);
          isAutoBalancing = false;
          hideAutoBalanceHint();
        } else if (amountA > 0) {
          // Show hint about why auto-balance doesn't work
          if (createTokenA.priceUsd === 0 && createTokenB.priceUsd === 0) {
            showAutoBalanceHint('both tokens');
          } else if (createTokenA.priceUsd === 0) {
            showAutoBalanceHint(createTokenA.symbol);
          } else if (createTokenB.priceUsd === 0) {
            showAutoBalanceHint(createTokenB.symbol);
          }
        }
        updateCreatePreview();
      };

      inputB.oninput = function() {
        if (isAutoBalancing) return;
        const amountB = parseFloat(this.value) || 0;
        if (amountB > 0 && createTokenA.priceUsd > 0 && createTokenB.priceUsd > 0) {
          isAutoBalancing = true;
          const valueUsd = amountB * createTokenB.priceUsd;
          const amountA = valueUsd / createTokenA.priceUsd;
          inputA.value = amountA.toFixed(6);
          isAutoBalancing = false;
          hideAutoBalanceHint();
        } else if (amountB > 0) {
          // Show hint about why auto-balance doesn't work
          if (createTokenA.priceUsd === 0 && createTokenB.priceUsd === 0) {
            showAutoBalanceHint('both tokens');
          } else if (createTokenA.priceUsd === 0) {
            showAutoBalanceHint(createTokenA.symbol);
          } else if (createTokenB.priceUsd === 0) {
            showAutoBalanceHint(createTokenB.symbol);
          }
        }
        updateCreatePreview();
      };

      // Manual price input handlers
      const priceInputA = document.getElementById('tokenA-price-input');
      const priceInputB = document.getElementById('tokenB-price-input');

      priceInputA.oninput = function() {
        const manualPrice = parseFloat(this.value) || 0;
        if (manualPrice > 0) {
          createTokenA.priceUsd = manualPrice;
          createTokenA.priceSource = 'manual';
          // Update badge to show manual
          const badge = document.getElementById('tokenA-price-badge');
          badge.style.display = 'inline-block';
          badge.className = 'price-source-badge manual';
          badge.textContent = 'Manual';
          hideAutoBalanceHint();
        } else {
          createTokenA.priceUsd = 0;
          createTokenA.priceSource = null;
          document.getElementById('tokenA-price-badge').style.display = 'none';
        }
        updateCreatePreview();
        // Trigger auto-balance if both prices now available
        const amountA = parseFloat(inputA.value) || 0;
        if (amountA > 0 && createTokenA.priceUsd > 0 && createTokenB.priceUsd > 0 && !isAutoBalancing) {
          isAutoBalancing = true;
          const valueUsd = amountA * createTokenA.priceUsd;
          const amountB = valueUsd / createTokenB.priceUsd;
          inputB.value = amountB.toFixed(6);
          isAutoBalancing = false;
          updateCreatePreview();
        }
      };

      priceInputB.oninput = function() {
        const manualPrice = parseFloat(this.value) || 0;
        if (manualPrice > 0) {
          createTokenB.priceUsd = manualPrice;
          createTokenB.priceSource = 'manual';
          // Update badge to show manual
          const badge = document.getElementById('tokenB-price-badge');
          badge.style.display = 'inline-block';
          badge.className = 'price-source-badge manual';
          badge.textContent = 'Manual';
          hideAutoBalanceHint();
        } else {
          createTokenB.priceUsd = 0;
          createTokenB.priceSource = null;
          document.getElementById('tokenB-price-badge').style.display = 'none';
        }
        updateCreatePreview();
        // Trigger auto-balance if both prices now available
        const amountB = parseFloat(inputB.value) || 0;
        if (amountB > 0 && createTokenA.priceUsd > 0 && createTokenB.priceUsd > 0 && !isAutoBalancing) {
          isAutoBalancing = true;
          const valueUsd = amountB * createTokenB.priceUsd;
          const amountA = valueUsd / createTokenA.priceUsd;
          inputA.value = amountA.toFixed(6);
          isAutoBalancing = false;
          updateCreatePreview();
        }
      };
    }

    window.closeCreateModal = function() {
      document.getElementById('create-position-modal').classList.remove('visible');
    };

    async function loadCreateBalances() {
      if (!connectedWallet) return;

      try {
        const [tokenARes, tokenBRes] = await Promise.all([
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${createTokenA.address}\`),
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${createTokenB.address}\`)
        ]);
        const tokenAData = await tokenARes.json();
        const tokenBData = await tokenBRes.json();

        createTokenABalance = tokenAData.balanceFormatted || 0;
        createTokenBBalance = tokenBData.balanceFormatted || 0;

        document.getElementById('create-tokenA-balance').textContent = \`Balance: \${formatNumber(createTokenABalance)}\`;
        document.getElementById('create-tokenB-balance').textContent = \`Balance: \${formatNumber(createTokenBBalance)}\`;
      } catch (e) {
        console.error('[ArbMe] Failed to load create balances:', e);
      }
    }

    function setCreateTxStatus(message, type) {
      const el = document.getElementById('create-tx-status');
      el.textContent = message;
      el.className = 'tx-status ' + type;
      // Show tip jar on success
      const tipEl = document.getElementById('create-success-tip');
      if (tipEl) tipEl.style.display = type === 'success' ? 'flex' : 'none';
    }

    // Confirmation Modal Functions
    let pendingCreateData = null; // Store data for pending pool creation

    function showCreateConfirmationModal(tokenA, tokenB, amountA, amountB) {
      console.log('[ArbMe] Showing confirmation modal');
      console.log('[ArbMe] CONFIRMATION MODAL - TokenA:', tokenA.symbol, 'decimals:', tokenA.decimals);
      console.log('[ArbMe] CONFIRMATION MODAL - TokenB:', tokenB.symbol, 'decimals:', tokenB.decimals);

      // CRITICAL: Verify decimals look reasonable
      if (tokenA.decimals === tokenB.decimals && tokenA.decimals === 6) {
        console.warn('[ArbMe] WARNING: Both tokens have 6 decimals - verify this is correct!');
      }

      // Store the pending creation data
      pendingCreateData = { tokenA, tokenB, amountA, amountB };

      // Format amounts with commas
      const formatAmount = (num) => {
        if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
        if (num >= 1000) return num.toLocaleString('en-US', { maximumFractionDigits: 4 });
        return num.toFixed(6);
      };

      // Calculate USD values
      const valueA = amountA * (tokenA.priceUsd || 0);
      const valueB = amountB * (tokenB.priceUsd || 0);

      // Calculate raw amounts for display (what will actually be sent)
      const rawA = BigInt(Math.floor(amountA * Math.pow(10, tokenA.decimals)));
      const rawB = BigInt(Math.floor(amountB * Math.pow(10, tokenB.decimals)));
      console.log('[ArbMe] CONFIRMATION MODAL - Raw amounts:', rawA.toString(), rawB.toString());

      // Update modal content
      document.getElementById('confirm-tokenA-amount').textContent = formatAmount(amountA) + ' ' + tokenA.symbol;
      document.getElementById('confirm-tokenB-amount').textContent = formatAmount(amountB) + ' ' + tokenB.symbol;
      document.getElementById('confirm-tokenA-value').textContent = valueA > 0 ? '(~$' + valueA.toFixed(2) + ')' : '(price unknown)';
      document.getElementById('confirm-tokenB-value').textContent = valueB > 0 ? '(~$' + valueB.toFixed(2) + ')' : '(price unknown)';

      // Calculate and display price ratio
      let priceInfo = '';
      if (amountA > 0 && amountB > 0) {
        const ratio = amountB / amountA;
        priceInfo = 'Initial price: 1 ' + tokenA.symbol + ' = ' + formatAmount(ratio) + ' ' + tokenB.symbol;
      }
      document.getElementById('confirm-price-info').textContent = priceInfo;

      // Display decimals for verification
      document.getElementById('confirm-decimals-info').textContent =
        'Decimals: ' + tokenA.symbol + '=' + tokenA.decimals + ' / ' + tokenB.symbol + '=' + tokenB.decimals;

      // Reset checkbox and button
      const checkbox = document.getElementById('confirm-risk-checkbox');
      const confirmBtn = document.getElementById('confirm-create-btn');
      checkbox.checked = false;
      confirmBtn.disabled = true;

      // Add checkbox listener
      checkbox.onchange = function() {
        confirmBtn.disabled = !this.checked;
      };

      // Show modal
      document.getElementById('create-confirm-modal').classList.add('visible');
    }

    window.closeCreateConfirmationModal = function() {
      document.getElementById('create-confirm-modal').classList.remove('visible');
      pendingCreateData = null;
      // Reset the create button
      const submitBtn = document.getElementById('create-position-submit');
      submitBtn.disabled = false;
      submitBtn.textContent = 'Create Position';
      setCreateTxStatus('', '');
    };

    window.proceedWithPoolCreation = async function() {
      console.log('[ArbMe] User confirmed, proceeding with pool creation');

      // Close confirmation modal
      document.getElementById('create-confirm-modal').classList.remove('visible');

      if (!pendingCreateData) {
        setCreateTxStatus('Error: No pending creation data', 'error');
        return;
      }

      const { tokenA, tokenB, amountA, amountB } = pendingCreateData;
      pendingCreateData = null;

      // Continue with actual pool creation
      await executePoolCreation(tokenA, tokenB, amountA, amountB);
    };

    // V4 Pool Creation execution (called after user confirmation)
    async function executePoolCreation(tokenA, tokenB, amountA, amountB) {
      console.log('[ArbMe] executePoolCreation called with:', tokenA.symbol, tokenB.symbol, amountA, amountB);
      console.log('[ArbMe] FULL TOKEN A:', JSON.stringify(tokenA));
      console.log('[ArbMe] FULL TOKEN B:', JSON.stringify(tokenB));

      const submitBtn = document.getElementById('create-position-submit');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Creating...';

      try {
        const provider = sdk.wallet.ethProvider;
        if (!provider) throw new Error('No wallet provider');

        // CRITICAL SAFETY CHECK: Verify decimals on-chain before proceeding
        // This prevents any cached/stale decimal values from causing fund loss
        // Note: fetchTokenInfoCached has 2min TTL, so data is recent
        setCreateTxStatus('Verifying token decimals...', 'pending');
        const [infoA, infoB] = await Promise.all([
          fetchTokenInfoCached(tokenA.address),
          fetchTokenInfoCached(tokenB.address)
        ]);

        // Validate token info was fetched
        if (!infoA) {
          throw new Error(\`Could not fetch token info for \${tokenA.symbol}\`);
        }
        if (!infoB) {
          throw new Error(\`Could not fetch token info for \${tokenB.symbol}\`);
        }

        console.log('[ArbMe] ON-CHAIN VERIFICATION - Token A:', infoA.symbol, 'decimals:', infoA.decimals);
        console.log('[ArbMe] ON-CHAIN VERIFICATION - Token B:', infoB.symbol, 'decimals:', infoB.decimals);

        // Use on-chain decimals, not cached values - safely parse to handle hex/null/invalid
        const decimalA = toSafeDecimals(infoA.decimals);
        const decimalB = toSafeDecimals(infoB.decimals);

        // Validate decimals could be parsed
        if (decimalA === null) {
          throw new Error(\`Could not parse decimals for \${tokenA.symbol} (received: \${infoA.decimals}). Cannot proceed.\`);
        }
        if (decimalB === null) {
          throw new Error(\`Could not parse decimals for \${tokenB.symbol} (received: \${infoB.decimals}). Cannot proceed.\`);
        }

        // Also safely parse UI-stored decimals for comparison
        const uiDecimalA = toSafeDecimals(tokenA.decimals);
        const uiDecimalB = toSafeDecimals(tokenB.decimals);

        // Verify decimals match what we expected
        if (uiDecimalA !== null && decimalA !== uiDecimalA) {
          console.error('[ArbMe] DECIMAL MISMATCH for', tokenA.symbol, '- expected:', tokenA.decimals, 'on-chain:', decimalA);
          throw new Error(\`Decimal mismatch for \${tokenA.symbol}: UI shows \${tokenA.decimals} but on-chain is \${decimalA}. Please refresh and try again.\`);
        }
        if (uiDecimalB !== null && decimalB !== uiDecimalB) {
          console.error('[ArbMe] DECIMAL MISMATCH for', tokenB.symbol, '- expected:', tokenB.decimals, 'on-chain:', decimalB);
          throw new Error(\`Decimal mismatch for \${tokenB.symbol}: UI shows \${tokenB.decimals} but on-chain is \${decimalB}. Please refresh and try again.\`);
        }

        console.log('[ArbMe] Parsed decimals - A:', decimalA, '(raw:', tokenA.decimals, ') B:', decimalB, '(raw:', tokenB.decimals, ')');

        // Sort tokens (currency0 < currency1) for V4
        const addrA = tokenA.address.toLowerCase();
        const addrB = tokenB.address.toLowerCase();
        let currency0, currency1, amount0, amount1, dec0, dec1, sym0, sym1;

        if (addrA < addrB) {
          currency0 = tokenA.address;
          currency1 = tokenB.address;
          amount0 = amountA;
          amount1 = amountB;
          dec0 = decimalA;
          dec1 = decimalB;
          sym0 = tokenA.symbol;
          sym1 = tokenB.symbol;
        } else {
          currency0 = tokenB.address;
          currency1 = tokenA.address;
          amount0 = amountB;
          amount1 = amountA;
          dec0 = decimalB;
          dec1 = decimalA;
          sym0 = tokenB.symbol;
          sym1 = tokenA.symbol;
        }

        const fee = createSelectedFee;
        const tickSpacing = getV4TickSpacing(fee);

        // CRITICAL: Log sorted values for debugging
        console.log('[ArbMe] SORTED - currency0:', sym0, '(', currency0, ') dec0:', dec0, 'amount0:', amount0);
        console.log('[ArbMe] SORTED - currency1:', sym1, '(', currency1, ') dec1:', dec1, 'amount1:', amount1);

        // Calculate raw amounts using VALIDATED decimals
        const amount0Raw = BigInt(Math.floor(amount0 * Math.pow(10, dec0)));
        const amount1Raw = BigInt(Math.floor(amount1 * Math.pow(10, dec1)));

        console.log('[ArbMe] RAW AMOUNTS - amount0Raw:', amount0Raw.toString(), '(', sym0, ') amount1Raw:', amount1Raw.toString(), '(', sym1, ')');

        if (amount0Raw === BigInt(0) || amount1Raw === BigInt(0)) {
          throw new Error('Both token amounts must be greater than 0 for full-range positions');
        }

        const approve0Amount = (amount0Raw * BigInt(110)) / BigInt(100);
        const approve1Amount = (amount1Raw * BigInt(110)) / BigInt(100);

        // Check both ERC20 approvals to Permit2 AND Permit2 allowances to PositionManager
        setCreateTxStatus('Checking approvals...', 'pending');
        const [app0Res, app1Res, p2app0Res, p2app1Res] = await Promise.all([
          fetch(\`/test/rpc?action=checkAllowance&wallet=\${connectedWallet}&token=\${currency0}&spender=\${PERMIT2_ADDRESS}\`),
          fetch(\`/test/rpc?action=checkAllowance&wallet=\${connectedWallet}&token=\${currency1}&spender=\${PERMIT2_ADDRESS}\`),
          fetch(\`/test/rpc?action=checkPermit2Allowance&wallet=\${connectedWallet}&token=\${currency0}&spender=\${V4_POSITION_MANAGER_JS}\`),
          fetch(\`/test/rpc?action=checkPermit2Allowance&wallet=\${connectedWallet}&token=\${currency1}&spender=\${V4_POSITION_MANAGER_JS}\`)
        ]);
        const app0 = await app0Res.json();
        const app1 = await app1Res.json();
        const p2app0 = await p2app0Res.json();
        const p2app1 = await p2app1Res.json();

        console.log('[ArbMe] ERC20 approval to Permit2:', app0, app1);
        console.log('[ArbMe] Permit2 allowance to PositionManager:', p2app0, p2app1);

        // Check if existing allowance is sufficient
        const app0Sufficient = app0.allowanceRaw && BigInt(app0.allowanceRaw) >= approve0Amount;
        const app1Sufficient = app1.allowanceRaw && BigInt(app1.allowanceRaw) >= approve1Amount;
        const p2app0Sufficient = p2app0.allowanceRaw && BigInt(p2app0.allowanceRaw) >= approve0Amount;
        const p2app1Sufficient = p2app1.allowanceRaw && BigInt(p2app1.allowanceRaw) >= approve1Amount;

        console.log('[ArbMe] Approval sufficiency:', { app0Sufficient, app1Sufficient, p2app0Sufficient, p2app1Sufficient });

        // Permit2.approve selector: approve(address token, address spender, uint160 amount, uint48 expiration)
        const permit2ApproveSelector = '0x87517c45';
        const maxUint160 = (BigInt(2) ** BigInt(160) - BigInt(1)).toString(16).padStart(40, '0');
        const farFutureExpiration = '0000000000000000000000000000000000000000000000000000ffffffffffff';

        // Token symbols already set during sorting as sym0 and sym1
        const token0Symbol = sym0;
        const token1Symbol = sym1;

        // Step 1: ERC20 approve token0 to Permit2 (if insufficient)
        if (!app0Sufficient) {
          setCreateTxStatus('Approving ' + token0Symbol + ' to Permit2...', 'pending');
          const approve0Hex = approve0Amount.toString(16).padStart(64, '0');
          await sdk.wallet.ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: connectedWallet,
              to: currency0,
              data: '0x095ea7b3' + PERMIT2_ADDRESS.slice(2).toLowerCase().padStart(64, '0') + approve0Hex,
              gas: '0x15F90',
              value: '0x0',
            }]
          });
          await new Promise(r => setTimeout(r, 3000));
        }

        // Step 2: Grant Permit2 allowance to PositionManager for token0 (if insufficient)
        if (!p2app0Sufficient) {
          setCreateTxStatus('Granting Permit2 allowance for ' + token0Symbol + '...', 'pending');
          const permit2Approve0Data = permit2ApproveSelector +
            currency0.slice(2).toLowerCase().padStart(64, '0') +
            V4_POSITION_MANAGER_JS.slice(2).toLowerCase().padStart(64, '0') +
            maxUint160.padStart(64, '0') +
            farFutureExpiration;
          await sdk.wallet.ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: connectedWallet,
              to: PERMIT2_ADDRESS,
              data: permit2Approve0Data,
              gas: '0x15F90',
              value: '0x0',
            }]
          });
          await new Promise(r => setTimeout(r, 3000));
        }

        // Step 3: ERC20 approve token1 to Permit2 (if insufficient)
        if (!app1Sufficient) {
          setCreateTxStatus('Approving ' + token1Symbol + ' to Permit2...', 'pending');
          const approve1Hex = approve1Amount.toString(16).padStart(64, '0');
          await sdk.wallet.ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: connectedWallet,
              to: currency1,
              data: '0x095ea7b3' + PERMIT2_ADDRESS.slice(2).toLowerCase().padStart(64, '0') + approve1Hex,
              gas: '0x15F90',
              value: '0x0',
            }]
          });
          await new Promise(r => setTimeout(r, 3000));
        }

        // Step 4: Grant Permit2 allowance to PositionManager for token1 (if insufficient)
        if (!p2app1Sufficient) {
          setCreateTxStatus('Granting Permit2 allowance for ' + token1Symbol + '...', 'pending');
          const permit2Approve1Data = permit2ApproveSelector +
            currency1.slice(2).toLowerCase().padStart(64, '0') +
            V4_POSITION_MANAGER_JS.slice(2).toLowerCase().padStart(64, '0') +
            maxUint160.padStart(64, '0') +
            farFutureExpiration;
          await sdk.wallet.ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: connectedWallet,
              to: PERMIT2_ADDRESS,
              data: permit2Approve1Data,
              gas: '0x15F90',
              value: '0x0',
            }]
          });
          await new Promise(r => setTimeout(r, 3000));
        }

        // Step 5: Check if pool exists and build transaction
        setCreateTxStatus('Checking pool state...', 'pending');

        const computeRes = await fetch(\`/test/rpc?action=computePoolId&currency0=\${currency0}&currency1=\${currency1}&fee=\${fee}&tickSpacing=\${tickSpacing}&hooks=0x0000000000000000000000000000000000000000\`);
        const computeData = await computeRes.json();
        const poolId = computeData.poolId;

        const slot0Res = await fetch(\`/test/rpc?action=v4_getSlot0&poolId=\${poolId}\`);
        const slot0Data = await slot0Res.json();

        // Check for RPC errors - don't proceed if we couldn't verify pool state
        if (slot0Data.error || slot0Data.rpcError) {
          throw new Error('Could not verify pool state. Please try again. ' + (slot0Data.error || ''));
        }

        let sqrtPriceX96 = slot0Data.sqrtPriceX96;

        // Use the explicit 'exists' flag from backend to determine if pool exists
        let isNewPool = slot0Data.exists === false;
        let initialSqrtPriceX96 = null;
        if (isNewPool) {
          const decimalAdjustment = Math.pow(10, dec0 - dec1);
          const priceRatio = (Number(amount1Raw) / Number(amount0Raw)) * decimalAdjustment;
          const sqrtPrice = Math.sqrt(priceRatio);
          initialSqrtPriceX96 = BigInt(Math.floor(sqrtPrice * Math.pow(2, 96)));
          sqrtPriceX96 = '0x' + initialSqrtPriceX96.toString(16);
        }

        // Calculate liquidity for full range position
        const maxTick = Math.floor(887272 / tickSpacing) * tickSpacing;
        const tickLower = -maxTick;
        const tickUpper = maxTick;
        const sqrtPriceLower = getSqrtPriceAtTick(tickLower);
        const sqrtPriceUpper = getSqrtPriceAtTick(tickUpper);
        const liquidity = calculateLiquidityFromAmounts(sqrtPriceX96, sqrtPriceLower, sqrtPriceUpper, amount0Raw, amount1Raw);

        if (liquidity <= BigInt(0)) {
          throw new Error('Could not calculate valid liquidity');
        }

        console.log('[ArbMe] executePoolCreation - isNewPool:', isNewPool, 'liquidity:', liquidity.toString());

        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        // BUILD TRANSACTION USING UNISWAP SDK (with decimal validation)
        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

        const deadline = Math.floor(Date.now() / 1000) + 1200;

        // STEP 1: Validate token pair using SDK safety rails
        console.log('[ArbMe SDK] Validating token pair before encoding...');
        const token0Info = {
          address: currency0,
          symbol: sym0,
          decimals: dec0,
        };
        const token1Info = {
          address: currency1,
          symbol: sym1,
          decimals: dec1,
        };

        const pairValidation = validateTokenPair(token0Info, token1Info);

        if (!pairValidation.valid) {
          console.error('[ArbMe SDK] Token validation FAILED:', pairValidation.error);
          throw new Error('Token validation failed: ' + pairValidation.error);
        }

        // Log any warnings (e.g., non-18 decimal whitelisted tokens)
        if (pairValidation.warnings) {
          pairValidation.warnings.forEach(warning => {
            console.warn('[ArbMe SDK]', warning);
          });
        }

        console.log('[ArbMe SDK] â Token pair validated - safe to proceed');

        // STEP 2: Build mint position using SDK
        console.log('[ArbMe SDK] Encoding V4 mint position with official Uniswap SDK...');

        const mintPositionParams: V4MintPositionParams = {
          token0: token0Info,
          token1: token1Info,
          fee,
          tickSpacing,
          tickLower,
          tickUpper,
          liquidity,
          amount0Max: amount0Raw,
          amount1Max: amount1Raw,
          amount0Min: BigInt(0), // Could add slippage here
          amount1Min: BigInt(0),
          recipient: connectedWallet,
        };

        const encoded = encodeV4MintPosition(mintPositionParams);

        if (!encoded.validation.valid) {
          console.error('[ArbMe SDK] Encoding validation FAILED:', encoded.validation.error);
          throw new Error('SDK encoding failed: ' + encoded.validation.error);
        }

        console.log('[ArbMe SDK] â V4 actions encoded successfully');
        console.log('[ArbMe SDK]   Actions:', encoded.actions);
        console.log('[ArbMe SDK]   Params:', encoded.params.length, 'items');

        // STEP 3: Build modifyLiquidities calldata from SDK output
        // The SDK gives us actions (hex string) and params (array of hex strings)
        // We need to encode this as unlockData for modifyLiquidities(bytes unlockData, uint256 deadline)

        const actionsHex = encoded.actions.startsWith('0x') ? encoded.actions.slice(2) : encoded.actions;
        const paramsArray = encoded.params.map(p => p.startsWith('0x') ? p.slice(2) : p);

        // Encode as per V4Planner's unlockData structure
        const actionsLength = actionsHex.length / 2;
        const actionsLengthPadded = actionsLength.toString(16).padStart(64, '0');
        const actionsPadded = actionsHex.padEnd(Math.ceil(actionsHex.length / 2) * 2, '0');
        const offsetActions = (64).toString(16).padStart(64, '0');
        const offsetParams = (64 + 32 + 32).toString(16).padStart(64, '0');
        const numParams = paramsArray.length;
        const paramsArrayLength = numParams.toString(16).padStart(64, '0');

        let paramOffsets = [];
        let currentOffset = numParams * 32;
        for (let i = 0; i < numParams; i++) {
          paramOffsets.push(currentOffset.toString(16).padStart(64, '0'));
          const paddedLen = Math.ceil(paramsArray[i].length / 64) * 32;
          currentOffset += 32 + paddedLen;
        }

        let paramsData = '';
        for (let i = 0; i < numParams; i++) {
          const paramBytes = paramsArray[i];
          const paramLength = paramBytes.length / 2;
          const paramLengthPadded = paramLength.toString(16).padStart(64, '0');
          const paramPaddedData = paramBytes.padEnd(Math.ceil(paramBytes.length / 64) * 64, '0');
          paramsData += paramLengthPadded + paramPaddedData;
        }

        const paramsArrayEncoded = paramsArrayLength + paramOffsets.join('') + paramsData;
        const unlockData = offsetActions + offsetParams + actionsLengthPadded + actionsPadded + paramsArrayEncoded;
        const modifyLiqSelector = '0xdd46508f';
        const unlockDataOffset = (64).toString(16).padStart(64, '0');
        const deadlinePadded = deadline.toString(16).padStart(64, '0');
        const unlockDataLength = (unlockData.length / 2).toString(16).padStart(64, '0');
        const unlockDataPadded = unlockData.padEnd(Math.ceil(unlockData.length / 64) * 64, '0');
        const callData = modifyLiqSelector + unlockDataOffset + deadlinePadded + unlockDataLength + unlockDataPadded;
        const modifyLiqCallData = '0x' + callData.slice(2);

        console.log('[ArbMe SDK] â modifyLiquidities calldata built');

        let finalCallData;
        if (isNewPool) {
          console.log('[ArbMe] Creating new pool - using multicall');
          const initPoolCallData = encodeInitializePool(
            currency0,
            currency1,
            fee,
            tickSpacing,
            '0x0000000000000000000000000000000000000000',
            initialSqrtPriceX96
          );
          finalCallData = encodeMulticall([initPoolCallData, modifyLiqCallData]);
          setCreateTxStatus('Creating pool & adding liquidity...', 'pending');
        } else {
          finalCallData = modifyLiqCallData;
          setCreateTxStatus('Adding liquidity to V4 pool...', 'pending');
        }

        const gasLimit = isNewPool ? TX_CONSTANTS.GAS_LIMITS.CREATE_POOL_V4 : TX_CONSTANTS.GAS_LIMITS.ADD_LIQUIDITY_V4;
        console.log('[ArbMe] Sending tx with gas:', gasLimit);
        setCreateTxStatus('Confirm in wallet...', 'pending');

        const txHash = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V4_POSITION_MANAGER_JS,
            data: finalCallData,
            gas: gasLimit,
            value: '0x0',
          }]
        });

        console.log('[ArbMe] V4 pool creation tx:', txHash);
        setCreateTxStatus('Position created!', 'success');
        showToast('success', 'Position Created!', 'View on <a href="https://basescan.org/tx/' + txHash + '" target="_blank">Basescan</a>');

        submitBtn.disabled = false;
        submitBtn.textContent = 'Create Position';
        setTimeout(() => {
          closeCreateModal();
          loadPositions();
        }, 1500)

      } catch (err) {
        console.error('[ArbMe] executePoolCreation error:', err);
        setCreateTxStatus('Error: ' + err.message, 'error');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Create Position';
      }
    }

    window.createNewPosition = async function() {
      console.log('[ArbMe] createNewPosition called');
      setCreateTxStatus('Starting...', 'pending');

      try {
        // Check if tokens are selected
        if (!createTokenA || !createTokenA.address) {
          setCreateTxStatus('Please select Token A from the dropdown or enter an address', 'error');
          return;
        }
        if (!createTokenB || !createTokenB.address) {
          setCreateTxStatus('Please select Token B from the dropdown or enter an address', 'error');
          return;
        }

        const amountA = parseFloat(document.getElementById('create-tokenA-input').value) || 0;
        const amountB = parseFloat(document.getElementById('create-tokenB-input').value) || 0;

        console.log('[ArbMe] Amounts:', amountA, amountB);
        console.log('[ArbMe] Version:', createSelectedVersion, 'Fee:', createSelectedFee);
        console.log('[ArbMe] TokenA:', createTokenA, 'TokenB:', createTokenB);

        if (amountA <= 0 || amountB <= 0) {
          setCreateTxStatus('Enter amounts for both tokens', 'error');
          return;
        }

        // CRITICAL: Verify both tokens have confirmed decimals
        // This prevents catastrophic fund loss from incorrect decimal assumptions
        if (createTokenA.decimals === null || !createTokenA.decimalsVerified) {
          setCreateTxStatus(\`Cannot verify decimals for \${createTokenA.symbol}. Transaction blocked for safety.\`, 'error');
          console.error('[ArbMe] BLOCKED: Token A decimals not verified', createTokenA);
          return;
        }
        if (createTokenB.decimals === null || !createTokenB.decimalsVerified) {
          setCreateTxStatus(\`Cannot verify decimals for \${createTokenB.symbol}. Transaction blocked for safety.\`, 'error');
          console.error('[ArbMe] BLOCKED: Token B decimals not verified', createTokenB);
          return;
        }

        // Validate tokens are different
        if (createTokenA.address.toLowerCase() === createTokenB.address.toLowerCase()) {
          setCreateTxStatus('Token A and Token B must be different', 'error');
          return;
        }

        // For V4: Require prices to be known (prevents accidental bad initial price)
        // User sets the initial pool price through their deposit ratio
        if (createSelectedVersion === 'v4') {
          if (createTokenA.priceUsd <= 0) {
            setCreateTxStatus(\`Enter a price for \${createTokenA.symbol} above to continue. This prevents setting an incorrect pool price.\`, 'error');
            console.error('[ArbMe] BLOCKED: Token A price unknown for V4 pool creation');
            return;
          }
          if (createTokenB.priceUsd <= 0) {
            setCreateTxStatus(\`Enter a price for \${createTokenB.symbol} above to continue. This prevents setting an incorrect pool price.\`, 'error');
            console.error('[ArbMe] BLOCKED: Token B price unknown for V4 pool creation');
            return;
          }

          // Show confirmation modal for V4 pool creation
          // This is a critical safety checkpoint to prevent accidental fund loss
          showCreateConfirmationModal(createTokenA, createTokenB, amountA, amountB);
          setCreateTxStatus('Please review and confirm the pool creation details.', 'pending');
          return; // Wait for user to confirm via modal
        }

        const submitBtn = document.getElementById('create-position-submit');
        submitBtn.disabled = true;
        submitBtn.textContent = 'Creating...';

        const provider = sdk.wallet.ethProvider;
        if (!provider) throw new Error('No wallet provider');

        // For V3: Use in-app full range add liquidity
        if (createSelectedVersion === 'v3') {
          closeCreateModal();
          submitBtn.disabled = false;
          submitBtn.textContent = 'Create Position';
          // Find V3 pool or create new position
          const pair = createTokenA.symbol + ' / ' + createTokenB.symbol;
          const reversePair = createTokenB.symbol + ' / ' + createTokenA.symbol;
          // Look for existing V3 pool
          let poolAddress = null;
          if (poolsData && poolsData.pools) {
            const matchingPool = poolsData.pools.find(p =>
              (p.pair === pair || p.pair === reversePair) && p.dex.includes('V3')
            );
            if (matchingPool) {
              poolAddress = matchingPool.pairAddress;
            }
          }
          if (poolAddress) {
            await openV3AddLiquidityModal(poolAddress, pair);
          } else {
            // No existing V3 pool found - show message
            setCreateTxStatus('No V3 pool found for ' + pair + '. Try V4.', 'error');
          }
          return;
        }

        // Note: V4 pool creation now uses confirmation modal flow
        // See showCreateConfirmationModal() and executePoolCreation()
        // V4 returns early above after showing the confirmation modal

        // For V2: Approve tokens then add liquidity
        // Convert amounts to raw values first
        const amountARaw = BigInt(Math.floor(amountA * Math.pow(10, createTokenA.decimals)));
        const amountBRaw = BigInt(Math.floor(amountB * Math.pow(10, createTokenB.decimals)));

        // Approve exact amounts + 10% buffer
        const approveAmountA = (amountARaw * BigInt(110)) / BigInt(100);
        const approveAmountB = (amountBRaw * BigInt(110)) / BigInt(100);

        setCreateTxStatus('Approving ' + createTokenA.symbol + '...', 'pending');

        // Approve Token A - exact amount
        const approveAmountAHex = approveAmountA.toString(16).padStart(64, '0');
        const approveTx0 = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: createTokenA.address,
            data: '0x095ea7b3' + V2_ROUTER.slice(2).padStart(64, '0') + approveAmountAHex,
            gas: '0x15F90', // 90000
            value: '0x0',
          }]
        });
        console.log('[ArbMe] Approve tokenA tx:', approveTx0);

        setCreateTxStatus('Approving ' + createTokenB.symbol + '...', 'pending');

        // Approve Token B - exact amount
        const approveAmountBHex = approveAmountB.toString(16).padStart(64, '0');
        const approveTx1 = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: createTokenB.address,
            data: '0x095ea7b3' + V2_ROUTER.slice(2).padStart(64, '0') + approveAmountBHex,
            gas: '0x15F90', // 90000
            value: '0x0',
          }]
        });
        console.log('[ArbMe] Approve tokenB tx:', approveTx1);

        setCreateTxStatus('Adding liquidity...', 'pending');

        // Calculate min amounts (5% slippage)
        const amountAMin = amountARaw * BigInt(95) / BigInt(100);
        const amountBMin = amountBRaw * BigInt(95) / BigInt(100);

        // Deadline: 20 minutes from now
        const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

        // Encode addLiquidity call
        const calldata = '0xe8e33700' +
          createTokenA.address.slice(2).toLowerCase().padStart(64, '0') +
          createTokenB.address.slice(2).toLowerCase().padStart(64, '0') +
          amountARaw.toString(16).padStart(64, '0') +
          amountBRaw.toString(16).padStart(64, '0') +
          amountAMin.toString(16).padStart(64, '0') +
          amountBMin.toString(16).padStart(64, '0') +
          connectedWallet.slice(2).toLowerCase().padStart(64, '0') +
          deadline.toString(16).padStart(64, '0');

        setCreateTxStatus('Confirm in your wallet...', 'pending');

        const tx = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V2_ROUTER,
            data: calldata,
            gas: '0x7A120', // 500000
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Create position tx:', tx);
        setCreateTxStatus('Waiting for confirmation...', 'pending');

        // Wait for transaction receipt
        let receipt = null;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          try {
            receipt = await provider.request({
              method: 'eth_getTransactionReceipt',
              params: [tx]
            });
            if (receipt) break;
          } catch (e) {
            console.log('[ArbMe] Waiting for receipt...', i);
          }
        }

        if (!receipt || receipt.status === '0x0') {
          setCreateTxStatus('Transaction failed', 'error');
          return;
        }

        console.log('[ArbMe] Receipt:', receipt);
        setCreateTxStatus('Position created! Verifying...', 'success');
        showToast('success', 'Position Created!', 'View on <a href="https://basescan.org/tx/' + tx + '" target="_blank">Basescan</a>');

        // Find the LP pair address from logs (Mint event comes from the pair)
        const mintEventTopic = '0x4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f';
        const mintLog = receipt.logs?.find(l => l.topics?.[0] === mintEventTopic);
        const pairAddress = mintLog?.address;

        if (pairAddress) {
          // Add to custom pools
          const newPool = {
            pair: \`\${getTokenSymbol(createTokenA.address)} / \${getTokenSymbol(createTokenB.address)}\`,
            pairAddress: pairAddress,
            dex: 'Uniswap V2',
            tvl: 0,
            volume24h: 0,
            priceUsd: '0',
            priceChange24h: 0,
            url: \`https://dexscreener.com/base/\${pairAddress}\`,
            source: 'custom',
            token0: createTokenA.address,
            token1: createTokenB.address,
          };

          // Check if not already in customPools
          if (!customPools.find(p => p.pairAddress?.toLowerCase() === pairAddress.toLowerCase())) {
            customPools.push(newPool);
            console.log('[ArbMe] Added new pool:', newPool);
          }

          setCreateTxStatus(\`Pool created: \${newPool.pair}\`, 'success');
        }

        // Refresh positions and pools, then close modal
        setTimeout(() => {
          loadPositions();
          loadPools();
          closeCreateModal();
        }, 2000);

      } catch (e) {
        console.error('[ArbMe] Create position failed:', e);
        setCreateTxStatus('Failed: ' + (e.message || 'Transaction rejected'), 'error');
        showToast('error', 'Transaction Failed', e.message || 'Unknown error');
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Create Position';
      }
    };

    window.addToPosition = async function(poolAddress) {
      // Use in-app modal for all V2 pools
      // Find the pool in poolsData to get the pair name
      let pairName = 'V2 Pool';
      if (poolsData && poolsData.pools) {
        const matchingPool = poolsData.pools.find(p =>
          p.pairAddress.toLowerCase() === poolAddress.toLowerCase() && p.dex.includes('V2')
        );
        if (matchingPool) {
          pairName = matchingPool.pair;
        }
      }
      // Handle known pools
      if (poolAddress.toLowerCase() === PAGE_ARBME_POOL.toLowerCase()) {
        pairName = 'PAGE / ARBME';
      }
      await addLiquidityToPool(poolAddress, 'v2', pairName);
    };

    window.removeFromPosition = async function(poolAddress, token0Symbol, token1Symbol, token0Addr, token1Addr, token0Dec, token1Dec) {
      console.log('[ArbMe] Remove liquidity from:', poolAddress, token0Symbol, token1Symbol, 'decimals:', token0Dec, token1Dec);

      if (!connectedWallet) {
        await connectWallet();
        if (!connectedWallet) return;
      }

      // Open the remove liquidity modal for V2 pools
      removePool = {
        address: poolAddress,
        token0: token0Addr || (poolAddress.toLowerCase() === PAGE_ARBME_POOL.toLowerCase() ? PAGE_ADDRESS : null),
        token1: token1Addr || (poolAddress.toLowerCase() === PAGE_ARBME_POOL.toLowerCase() ? ARBME_ADDRESS : null),
        token0Symbol: token0Symbol || 'PAGE',
        token1Symbol: token1Symbol || 'ARBME',
        token0Decimals: parseInt(token0Dec) || 18,
        token1Decimals: parseInt(token1Dec) || 18,
      };

      await openRemoveLiquidityModal();
    };

    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    // Remove Liquidity Modal Functions
    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

    function setRemoveTxStatus(message, type) {
      const el = document.getElementById('remove-tx-status');
      el.textContent = message;
      el.className = 'tx-status ' + type;
    }

    async function openRemoveLiquidityModal() {
      const modal = document.getElementById('remove-liquidity-modal');
      modal.classList.add('visible');
      setRemoveTxStatus('', '');

      // Update pool info display
      document.getElementById('remove-pool-pair').textContent = \`\${removePool.token0Symbol} / \${removePool.token1Symbol}\`;

      // Reset state
      removePercentage = 100;
      removeLpApproved = false;
      document.getElementById('remove-percentage-slider').value = 100;
      document.getElementById('remove-percentage-value').textContent = '100%';
      document.querySelectorAll('.percentage-btn').forEach(btn => btn.classList.remove('selected'));
      document.querySelector('.percentage-btn:last-child').classList.add('selected');

      // Reset approval UI
      document.getElementById('remove-lp-approval-check').className = 'approval-check pending';
      document.getElementById('remove-lp-approval-check').textContent = '?';
      document.getElementById('remove-lp-approval-text').textContent = 'Checking...';
      document.getElementById('remove-approve-btn').style.display = 'none';

      // Load LP balance and check approval (using settleAll for graceful partial failure)
      await settleAll(
        [loadRemoveLpBalance(), checkRemoveLpApproval()],
        ['loadRemoveLpBalance', 'checkRemoveLpApproval']
      );
    }

    window.closeRemoveModal = function() {
      document.getElementById('remove-liquidity-modal').classList.remove('visible');
      removePool = null;
      setRemoveTxStatus('', '');
    };

    async function loadRemoveLpBalance() {
      if (!connectedWallet || !removePool) return;

      try {
        document.getElementById('remove-lp-balance').textContent = 'Loading...';

        // Fetch LP token balance
        const balRes = await fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${removePool.address}\`);
        const balData = await balRes.json();

        removeLpBalance = balData.balanceFormatted || 0;
        removeLpBalanceRaw = BigInt(balData.balanceRaw || '0');

        document.getElementById('remove-lp-balance').textContent = formatNumber(removeLpBalance) + ' LP';

        // Now fetch pool reserves to estimate output
        await updateRemoveEstimates();
      } catch (e) {
        console.error('[ArbMe] Failed to load LP balance:', e);
        document.getElementById('remove-lp-balance').textContent = 'Error loading';
      }
    }

    async function updateRemoveEstimates() {
      if (!removePool || removeLpBalance <= 0) {
        document.getElementById('remove-output-token0').textContent = \`-- \${removePool?.token0Symbol || ''}\`;
        document.getElementById('remove-output-token1').textContent = \`-- \${removePool?.token1Symbol || ''}\`;
        return;
      }

      try {
        // Fetch pool reserves
        const reservesRes = await fetch(\`/test/rpc?action=getReserves&pool=\${removePool.address}\`);
        const reservesData = await reservesRes.json();

        if (reservesData.error) {
          console.error('[ArbMe] Failed to get reserves:', reservesData.error);
          return;
        }

        // Fetch total supply of LP tokens
        const supplyRes = await fetch(\`/test/rpc?action=totalSupply&token=\${removePool.address}\`);
        const supplyData = await supplyRes.json();

        if (supplyData.totalSupply) {
          const totalSupply = BigInt(supplyData.totalSupply);
          const reserve0 = BigInt(reservesData.reserve0Raw || '0');
          const reserve1 = BigInt(reservesData.reserve1Raw || '0');

          // Calculate how much LP we're removing
          const lpToRemove = removeLpBalanceRaw * BigInt(removePercentage) / BigInt(100);

          // Calculate estimated output: (lpToRemove / totalSupply) * reserves
          if (totalSupply > BigInt(0)) {
            const amount0 = (lpToRemove * reserve0) / totalSupply;
            const amount1 = (lpToRemove * reserve1) / totalSupply;

            // Format with actual token decimals
            const dec0 = removePool.token0Decimals || 18;
            const dec1 = removePool.token1Decimals || 18;
            removeEstimatedToken0 = Number(amount0) / Math.pow(10, dec0);
            removeEstimatedToken1 = Number(amount1) / Math.pow(10, dec1);

            document.getElementById('remove-output-token0').textContent = \`\${formatNumber(removeEstimatedToken0)} \${removePool.token0Symbol}\`;
            document.getElementById('remove-output-token1').textContent = \`\${formatNumber(removeEstimatedToken1)} \${removePool.token1Symbol}\`;
          }
        }
      } catch (e) {
        console.error('[ArbMe] Failed to update estimates:', e);
      }
    }

    window.setRemovePercentage = function(pct) {
      removePercentage = pct;
      document.getElementById('remove-percentage-slider').value = pct;
      document.getElementById('remove-percentage-value').textContent = pct + '%';

      // Update button states
      document.querySelectorAll('.percentage-btn').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.textContent) === pct);
      });

      updateRemoveEstimates();
    };

    window.onRemoveSliderChange = function(value) {
      removePercentage = parseInt(value);
      document.getElementById('remove-percentage-value').textContent = removePercentage + '%';

      // Update button states
      document.querySelectorAll('.percentage-btn').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.textContent) === removePercentage);
      });

      updateRemoveEstimates();
    };

    async function checkRemoveLpApproval() {
      if (!connectedWallet || !removePool) return;

      try {
        const appRes = await fetch(\`/test/rpc?action=checkAllowance&wallet=\${connectedWallet}&token=\${removePool.address}&spender=\${V2_ROUTER}\`);
        const appData = await appRes.json();

        removeLpApproved = appData.isApproved || false;
        updateRemoveApprovalUI();
      } catch (e) {
        console.error('[ArbMe] Failed to check LP approval:', e);
        document.getElementById('remove-lp-approval-text').textContent = 'Error checking';
      }
    }

    function updateRemoveApprovalUI() {
      const check = document.getElementById('remove-lp-approval-check');
      const text = document.getElementById('remove-lp-approval-text');
      const approveBtn = document.getElementById('remove-approve-btn');

      if (removeLpApproved) {
        check.className = 'approval-check approved';
        check.textContent = 'â';
        text.textContent = 'Approved';
        approveBtn.style.display = 'none';
      } else {
        check.className = 'approval-check pending';
        check.textContent = 'â';
        text.textContent = 'Needs approval';
        approveBtn.style.display = 'block';
      }
    }

    window.approveRemoveLiquidity = async function() {
      if (!connectedWallet || !removePool) return;

      const approveBtn = document.getElementById('remove-approve-btn');
      approveBtn.disabled = true;
      approveBtn.textContent = 'Approving...';

      try {
        const provider = sdk.wallet.ethProvider;
        if (!provider) throw new Error('No wallet provider');

        // Calculate exact LP amount to approve based on percentage
        const lpAmountToRemove = (removeLpBalanceRaw * BigInt(removePercentage)) / BigInt(100);
        // Add 10% buffer for safety
        const lpApprovalAmount = (lpAmountToRemove * BigInt(110)) / BigInt(100);
        const lpApprovalHex = lpApprovalAmount.toString(16).padStart(64, '0');

        setRemoveTxStatus('Approving LP token...', 'pending');

        const approveTxResult = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: removePool.address,
            data: '0x095ea7b3' + V2_ROUTER.slice(2).padStart(64, '0') + lpApprovalHex,
            gas: '0x15F90', // 90000
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Approve LP tx:', approveTxResult);
        removeLpApproved = true;
        setRemoveTxStatus('LP token approved!', 'success');
        updateRemoveApprovalUI();
      } catch (e) {
        console.error('[ArbMe] LP approval failed:', e);
        setRemoveTxStatus('Approval failed: ' + (e.message || 'Unknown error'), 'error');
      } finally {
        approveBtn.disabled = false;
        approveBtn.textContent = 'Approve LP Token';
      }
    };

    window.executeRemoveLiquidity = async function() {
      if (!connectedWallet || !removePool) return;

      if (removeLpBalance <= 0) {
        setRemoveTxStatus('No LP tokens to remove', 'error');
        return;
      }

      if (!removeLpApproved) {
        setRemoveTxStatus('Please approve LP token first', 'error');
        return;
      }

      const removeBtn = document.getElementById('remove-liquidity-btn');
      removeBtn.disabled = true;
      removeBtn.textContent = 'Removing...';

      try {
        const provider = sdk.wallet.ethProvider;
        if (!provider) throw new Error('No wallet provider');

        setRemoveTxStatus('Preparing transaction...', 'pending');

        // Calculate LP amount to remove
        const lpToRemove = removeLpBalanceRaw * BigInt(removePercentage) / BigInt(100);

        // Calculate minimum amounts (5% slippage) using actual token decimals
        const dec0 = removePool.token0Decimals || 18;
        const dec1 = removePool.token1Decimals || 18;
        const amount0Min = BigInt(Math.floor(removeEstimatedToken0 * Math.pow(10, dec0) * 0.95));
        const amount1Min = BigInt(Math.floor(removeEstimatedToken1 * Math.pow(10, dec1) * 0.95));

        // Deadline: 20 minutes from now
        const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

        // Encode removeLiquidity call
        // removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline)
        const calldata = '0xbaa2abde' +
          removePool.token0.slice(2).padStart(64, '0') +
          removePool.token1.slice(2).padStart(64, '0') +
          lpToRemove.toString(16).padStart(64, '0') +
          amount0Min.toString(16).padStart(64, '0') +
          amount1Min.toString(16).padStart(64, '0') +
          connectedWallet.slice(2).toLowerCase().padStart(64, '0') +
          deadline.toString(16).padStart(64, '0');

        setRemoveTxStatus('Confirm in your wallet...', 'pending');

        const tx = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V2_ROUTER,
            data: calldata,
            gas: TX_CONSTANTS.GAS_LIMITS.REMOVE_LIQUIDITY_V2,
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Remove liquidity tx:', tx);
        setRemoveTxStatus('Transaction submitted! Waiting for confirmation...', 'pending');

        // Wait for transaction confirmation
        let confirmed = false;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          const receipt = await provider.request({
            method: 'eth_getTransactionReceipt',
            params: [tx]
          });
          if (receipt) {
            if (receipt.status === '0x1') {
              confirmed = true;
              break;
            } else {
              throw new Error('Transaction reverted');
            }
          }
        }

        if (confirmed) {
          setRemoveTxStatus('Liquidity removed successfully!', 'success');
          showToast('success', 'Liquidity Removed!', 'View on <a href="https://basescan.org/tx/' + tx + '" target="_blank">Basescan</a>');
          setTimeout(() => {
            loadPositions();
            closeRemoveModal();
          }, 2000);
        } else {
          setRemoveTxStatus('Transaction not confirmed yet. Check your wallet.', 'error');
        }

      } catch (e) {
        console.error('[ArbMe] Remove liquidity failed:', e);
        setRemoveTxStatus('Failed: ' + (e.message || 'Transaction rejected'), 'error');
        showToast('error', 'Transaction Failed', e.message || 'Unknown error');
      } finally {
        removeBtn.disabled = false;
        removeBtn.textContent = 'Remove Liquidity';
      }
    };

    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    // V3 Remove Liquidity Modal Functions
    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

    const V3_POSITION_MANAGER = '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1';

    function setV3RemoveTxStatus(message, type) {
      const el = document.getElementById('v3-remove-tx-status');
      el.textContent = message;
      el.className = 'tx-status ' + type;
    }

    window.openV3RemoveModal = async function(tokenId, token0Symbol, token1Symbol, token0Addr, token1Addr, liquidity, fee) {
      console.log('[ArbMe] Opening V3 remove modal for tokenId:', tokenId);

      if (!connectedWallet) {
        await connectWallet();
        if (!connectedWallet) return;
      }

      v3RemovePosition = {
        tokenId: tokenId,
        token0Symbol: token0Symbol,
        token1Symbol: token1Symbol,
        token0: token0Addr,
        token1: token1Addr,
        liquidity: liquidity,
        fee: fee,
      };

      const modal = document.getElementById('v3-remove-modal');
      modal.classList.add('visible');
      setV3RemoveTxStatus('', '');

      // Update display
      document.getElementById('v3-remove-pair').textContent = \`\${token0Symbol} / \${token1Symbol}\`;
      document.getElementById('v3-remove-token-id').textContent = '#' + tokenId;
      document.getElementById('v3-remove-fee').textContent = fee;

      // Reset percentage
      v3RemovePercentage = 100;
      document.getElementById('v3-remove-percentage-slider').value = 100;
      document.getElementById('v3-remove-percentage-value').textContent = '100%';
      document.querySelectorAll('.percentage-btn.v3-pct').forEach(btn => btn.classList.remove('selected'));
      document.querySelector('.percentage-btn.v3-pct:last-child').classList.add('selected');

      // Set token labels
      document.getElementById('v3-remove-token0-label').textContent = token0Symbol;
      document.getElementById('v3-remove-token1-label').textContent = token1Symbol;

      // Fetch position details from chain
      await loadV3PositionDetails();
    };

    async function loadV3PositionDetails() {
      if (!v3RemovePosition) return;

      try {
        // Fetch position details from API
        const res = await fetch(\`/test/rpc?action=v3_positions&tokenId=\${v3RemovePosition.tokenId}\`);
        const data = await res.json();

        if (data.position) {
          const pos = data.position;
          // Store actual liquidity from chain
          v3RemovePosition.liquidity = pos.liquidity;
          v3RemovePosition.tickLower = pos.tickLower;
          v3RemovePosition.tickUpper = pos.tickUpper;
          v3RemovePosition.tokensOwed0 = pos.tokensOwed0;
          v3RemovePosition.tokensOwed1 = pos.tokensOwed1;

          // For now show placeholder amounts - getting exact amounts requires sqrtPriceX96 calculation
          document.getElementById('v3-remove-token0-amount').textContent = pos.tokensOwed0 > 0 ? formatNumber(pos.tokensOwed0 / 1e18) : 'In range';
          document.getElementById('v3-remove-token1-amount').textContent = pos.tokensOwed1 > 0 ? formatNumber(pos.tokensOwed1 / 1e18) : 'In range';
        }

        updateV3RemoveEstimates();
      } catch (e) {
        console.error('[ArbMe] Failed to load V3 position details:', e);
      }
    }

    function updateV3RemoveEstimates() {
      if (!v3RemovePosition) return;

      const pct = v3RemovePercentage;
      document.getElementById('v3-remove-output-token0').textContent = \`\${pct}% of \${v3RemovePosition.token0Symbol}\`;
      document.getElementById('v3-remove-output-token1').textContent = \`\${pct}% of \${v3RemovePosition.token1Symbol}\`;
    }

    window.closeV3RemoveModal = function() {
      document.getElementById('v3-remove-modal').classList.remove('visible');
      v3RemovePosition = null;
      setV3RemoveTxStatus('', '');
    };

    window.setV3RemovePercentage = function(pct) {
      v3RemovePercentage = pct;
      document.getElementById('v3-remove-percentage-slider').value = pct;
      document.getElementById('v3-remove-percentage-value').textContent = pct + '%';

      document.querySelectorAll('.percentage-btn.v3-pct').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.textContent) === pct);
      });

      updateV3RemoveEstimates();
    };

    window.onV3RemoveSliderChange = function(value) {
      v3RemovePercentage = parseInt(value);
      document.getElementById('v3-remove-percentage-value').textContent = v3RemovePercentage + '%';

      document.querySelectorAll('.percentage-btn.v3-pct').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.textContent) === v3RemovePercentage);
      });

      updateV3RemoveEstimates();
    };

    window.executeV3RemoveLiquidity = async function() {
      if (!connectedWallet || !v3RemovePosition) return;

      const removeBtn = document.getElementById('v3-remove-btn');
      removeBtn.disabled = true;
      removeBtn.textContent = 'Removing...';

      try {
        const provider = sdk.wallet.ethProvider;
        if (!provider) throw new Error('No wallet provider');

        setV3RemoveTxStatus('Preparing transaction...', 'pending');

        // Calculate liquidity to remove based on percentage
        const fullLiquidity = BigInt(v3RemovePosition.liquidity || '0');
        const liquidityToRemove = fullLiquidity * BigInt(v3RemovePercentage) / BigInt(100);

        if (liquidityToRemove <= BigInt(0)) {
          setV3RemoveTxStatus('No liquidity to remove', 'error');
          removeBtn.disabled = false;
          removeBtn.textContent = 'Remove Liquidity';
          return;
        }

        // Deadline: 20 minutes from now
        const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

        // Build decreaseLiquidity calldata
        // decreaseLiquidity((uint256 tokenId, uint128 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 deadline))
        // Selector: 0x0c49ccbe
        const tokenId = BigInt(v3RemovePosition.tokenId);
        const amount0Min = BigInt(0); // Set to 0 for now, could calculate proper min
        const amount1Min = BigInt(0);

        const decreaseCalldata = '0x0c49ccbe' +
          tokenId.toString(16).padStart(64, '0') +
          liquidityToRemove.toString(16).padStart(64, '0') +
          amount0Min.toString(16).padStart(64, '0') +
          amount1Min.toString(16).padStart(64, '0') +
          deadline.toString(16).padStart(64, '0');

        setV3RemoveTxStatus('Confirm decrease liquidity...', 'pending');

        const decreaseTxResult = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V3_POSITION_MANAGER,
            data: decreaseCalldata,
            gas: TX_CONSTANTS.GAS_LIMITS.REMOVE_LIQUIDITY_V3,
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Decrease liquidity tx:', decreaseTxResult);
        setV3RemoveTxStatus('Waiting for confirmation...', 'pending');

        // Wait a bit for the transaction to be included
        await new Promise(r => setTimeout(r, 3000));

        // Now collect the tokens
        // collect((uint256 tokenId, address recipient, uint128 amount0Max, uint128 amount1Max))
        // Selector: 0xfc6f7865
        const amount0Max = BigInt('0xffffffffffffffffffffffffffffffff'); // uint128 max
        const amount1Max = BigInt('0xffffffffffffffffffffffffffffffff');

        const collectCalldata = '0xfc6f7865' +
          tokenId.toString(16).padStart(64, '0') +
          connectedWallet.slice(2).toLowerCase().padStart(64, '0') +
          amount0Max.toString(16).padStart(64, '0') +
          amount1Max.toString(16).padStart(64, '0');

        setV3RemoveTxStatus('Confirm collect tokens...', 'pending');

        const collectTx = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V3_POSITION_MANAGER,
            data: collectCalldata,
            gas: TX_CONSTANTS.GAS_LIMITS.COLLECT_FEES,
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Collect tx:', collectTx);
        setV3RemoveTxStatus('Liquidity removed successfully!', 'success');
        showToast('success', 'Liquidity Removed!', 'View on <a href="https://basescan.org/tx/' + collectTx + '" target="_blank">Basescan</a>');

        // Refresh positions after a delay
        setTimeout(() => {
          loadPositions();
          closeV3RemoveModal();
        }, 3000);

      } catch (e) {
        console.error('[ArbMe] V3 remove liquidity failed:', e);
        setV3RemoveTxStatus('Failed: ' + (e.message || 'Transaction rejected'), 'error');
        showToast('error', 'Transaction Failed', e.message || 'Unknown error');
      } finally {
        removeBtn.disabled = false;
        removeBtn.textContent = 'Remove Liquidity';
      }
    };

    window.addToExistingPosition = async function(version, poolId, token0Symbol, token1Symbol, token0Address, token1Address, feeRaw, tickSpacing) {
      console.log('[ArbMe] Add to existing position:', version, poolId, token0Symbol, token1Symbol, token0Address, token1Address, feeRaw, tickSpacing);

      if (!connectedWallet) {
        await connectWallet();
        if (!connectedWallet) return;
      }

      // For V3/V4, we'll open the add liquidity modal for the pool
      // This creates a NEW position in the same pool (not increasing existing position)
      const pair = token0Symbol + ' / ' + token1Symbol;
      const reversePair = token1Symbol + ' / ' + token0Symbol;

      if (version === 'v4') {
        // If we have token addresses from the position, use them directly
        if (token0Address && token1Address && token0Address !== 'unknown') {
          console.log('[ArbMe] Using token addresses from position:', token0Address, token1Address);
          await openV4AddLiquidityModalWithAddresses(pair, token0Symbol, token1Symbol, token0Address, token1Address, parseInt(feeRaw) || 10000, parseInt(tickSpacing) || 200);
          return;
        }

        // Otherwise try to find the poolId from loaded pools
        let actualPoolId = poolId;
        if (!actualPoolId && poolsData && poolsData.pools) {
          const matchingPool = poolsData.pools.find(p =>
            (p.pair === pair || p.pair === reversePair) && p.dex.includes('V4')
          );
          if (matchingPool) {
            actualPoolId = matchingPool.pairAddress;
            console.log('[ArbMe] Found poolId from pools data:', actualPoolId);
          }
        }

        if (!actualPoolId) {
          setTxStatus('Could not find pool data. Try from Pools list.', 'error');
          return;
        }

        await openV4AddLiquidityModal(actualPoolId, pair);
      } else if (version === 'v3') {
        // For V3, use our own modal if we have the pool address
        if (poolId && poolId.startsWith('0x') && poolId.length === 42) {
          const pair = token0Symbol + ' / ' + token1Symbol;
          await openV3AddLiquidityModal(poolId, pair);
        } else {
          // Fallback to Uniswap if no pool address
          const url = \`https://app.uniswap.org/positions/create/v3?chain=base\`;
          try {
            await sdk.actions.openUrl({ url });
          } catch (e) {
            window.open(url, '_blank');
          }
        }
      }
    };

    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
    // V4 Remove Liquidity Modal Functions
    // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

    const V4_POSITION_MANAGER = '0x7c5f5a4bbd8fd63184577525326123b519429bdc';

    function setV4RemoveTxStatus(message, type) {
      const el = document.getElementById('v4-remove-tx-status');
      el.textContent = message;
      el.className = 'tx-status ' + type;
    }

    window.openV4RemoveModal = async function(tokenId, token0Symbol, token1Symbol, token0Addr, token1Addr, liquidity, fee) {
      console.log('[ArbMe] Opening V4 remove modal for tokenId:', tokenId);

      if (!connectedWallet) {
        await connectWallet();
        if (!connectedWallet) return;
      }

      v4RemovePosition = {
        tokenId: tokenId,
        token0Symbol: token0Symbol,
        token1Symbol: token1Symbol,
        token0: token0Addr,
        token1: token1Addr,
        liquidity: liquidity,
        fee: fee,
      };

      const modal = document.getElementById('v4-remove-modal');
      modal.classList.add('visible');
      setV4RemoveTxStatus('', '');

      // Update display
      document.getElementById('v4-remove-pair').textContent = \`\${token0Symbol} / \${token1Symbol}\`;
      document.getElementById('v4-remove-token-id').textContent = '#' + tokenId;
      document.getElementById('v4-remove-fee').textContent = fee;

      // Reset percentage
      v4RemovePercentage = 100;
      document.getElementById('v4-remove-percentage-slider').value = 100;
      document.getElementById('v4-remove-percentage-value').textContent = '100%';
      document.querySelectorAll('.percentage-btn.v4-pct').forEach(btn => btn.classList.remove('selected'));
      document.querySelector('.percentage-btn.v4-pct:last-child').classList.add('selected');

      // Set token labels
      document.getElementById('v4-remove-token0-label').textContent = token0Symbol;
      document.getElementById('v4-remove-token1-label').textContent = token1Symbol;

      // Fetch position details from chain
      await loadV4PositionDetails();
    };

    async function loadV4PositionDetails() {
      if (!v4RemovePosition) return;

      try {
        // Fetch position liquidity from API
        const res = await fetch(\`/test/rpc?action=v4_getPositionLiquidity&tokenId=\${v4RemovePosition.tokenId}\`);
        const data = await res.json();

        if (data.liquidity) {
          v4RemovePosition.liquidity = data.liquidity;
          document.getElementById('v4-remove-token0-amount').textContent = 'In position';
          document.getElementById('v4-remove-token1-amount').textContent = 'In position';
        }

        updateV4RemoveEstimates();
      } catch (e) {
        console.error('[ArbMe] Failed to load V4 position details:', e);
      }
    }

    function updateV4RemoveEstimates() {
      if (!v4RemovePosition) return;

      const pct = v4RemovePercentage;
      document.getElementById('v4-remove-output-token0').textContent = \`\${pct}% of \${v4RemovePosition.token0Symbol}\`;
      document.getElementById('v4-remove-output-token1').textContent = \`\${pct}% of \${v4RemovePosition.token1Symbol}\`;
    }

    window.closeV4RemoveModal = function() {
      document.getElementById('v4-remove-modal').classList.remove('visible');
      v4RemovePosition = null;
      setV4RemoveTxStatus('', '');
    };

    window.setV4RemovePercentage = function(pct) {
      v4RemovePercentage = pct;
      document.getElementById('v4-remove-percentage-slider').value = pct;
      document.getElementById('v4-remove-percentage-value').textContent = pct + '%';

      document.querySelectorAll('.percentage-btn.v4-pct').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.textContent) === pct);
      });

      updateV4RemoveEstimates();
    };

    window.onV4RemoveSliderChange = function(value) {
      v4RemovePercentage = parseInt(value);
      document.getElementById('v4-remove-percentage-value').textContent = v4RemovePercentage + '%';

      document.querySelectorAll('.percentage-btn.v4-pct').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.textContent) === v4RemovePercentage);
      });

      updateV4RemoveEstimates();
    };

    // Collect fees from V4 position (DECREASE_LIQUIDITY with 0 liquidity)
    window.collectV4Fees = async function(tokenId, token0Address, token1Address) {
      if (!connectedWallet) {
        await connectWallet();
        if (!connectedWallet) return;
      }

      // Validate inputs
      if (!tokenId || !token0Address || !token1Address ||
          token0Address === '' || token1Address === '' ||
          token0Address === 'unknown' || token1Address === 'unknown') {
        showToast('error', 'Invalid Position', 'Token addresses not available for this position');
        return;
      }

      // Validate addresses are proper hex
      if (!token0Address.startsWith('0x') || token0Address.length !== 42 ||
          !token1Address.startsWith('0x') || token1Address.length !== 42) {
        showToast('error', 'Invalid Addresses', 'Token addresses are malformed');
        return;
      }

      // Sort tokens for currency0/currency1
      const [currency0, currency1] = sortAddresses(token0Address, token1Address);

      // Find the button and show loading state
      const btn = event.target;
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Collecting...';

      try {
        console.log('[ArbMe] Collecting V4 fees - tokenId:', tokenId, 'currency0:', currency0, 'currency1:', currency1);

        const deadline = Math.floor(Date.now() / 1000) + 1200;

        // Helper: pad hex to 32 bytes (64 chars)
        const pad32 = (hex) => hex.replace('0x', '').padStart(64, '0');

        // Helper: pad bytes to 32-byte boundary
        const padBytes = (hex) => {
          const clean = hex.replace('0x', '');
          const padLen = Math.ceil(clean.length / 64) * 64;
          return clean.padEnd(padLen, '0');
        };

        // Actions: DECREASE_LIQUIDITY (0x01) + TAKE_PAIR (0x11)
        const actionsHex = '0111'; // 2 bytes

        // DECREASE_LIQUIDITY params: abi.encode(uint256 tokenId, uint256 liquidity, uint128 amount0Min, uint128 amount1Min, bytes hookData)
        // This is: tokenId + liquidity + amount0Min + amount1Min + offset(hookData) + length(hookData)
        const decreaseParams =
          pad32(BigInt(tokenId).toString(16)) +  // tokenId
          pad32('0') +                            // liquidity = 0 (just collect fees)
          pad32('0') +                            // amount0Min = 0
          pad32('0') +                            // amount1Min = 0
          pad32((5 * 32).toString(16)) +          // offset to hookData (after 5 slots)
          pad32('0');                             // hookData length = 0

        // TAKE_PAIR params: abi.encode(address currency0, address currency1, address recipient)
        const takeParams =
          pad32(currency0.slice(2).toLowerCase()) +
          pad32(currency1.slice(2).toLowerCase()) +
          pad32(connectedWallet.slice(2).toLowerCase());

        // Now encode: abi.encode(bytes actions, bytes[] params)
        // Structure:
        // [0x00] offset to actions (0x40 = 64)
        // [0x20] offset to params array (dynamic, after actions)
        // [0x40] actions length
        // [0x60] actions data (padded)
        // [...] params array: length, offsets, then each param's length + data

        const actionsLen = actionsHex.length / 2; // 2 bytes
        const actionsPadded = padBytes(actionsHex);
        const actionsDataSlots = actionsPadded.length / 64;

        // Offset to params array = 0x40 (head) + 0x20 (actions length) + actions data
        const paramsOffset = 64 + 32 + actionsDataSlots * 32;

        // Params array encoding
        const numParams = 2;
        // Each param is dynamic bytes, so we have: length + offsets + data
        // Offset to param0 data = 2 * 32 (for the two offset slots)
        const param0Offset = numParams * 32;
        // param0 data: length (32) + padded data
        const param0Padded = padBytes(decreaseParams);
        const param0DataSize = 32 + param0Padded.length / 2;
        const param1Offset = param0Offset + param0DataSize;
        const param1Padded = padBytes(takeParams);

        const paramsArray =
          pad32(numParams.toString(16)) +                     // array length = 2
          pad32(param0Offset.toString(16)) +                  // offset to param[0]
          pad32(param1Offset.toString(16)) +                  // offset to param[1]
          pad32((decreaseParams.length / 2).toString(16)) +   // param[0] length
          param0Padded +                                       // param[0] data
          pad32((takeParams.length / 2).toString(16)) +       // param[1] length
          param1Padded;                                        // param[1] data

        // Full unlockData
        const unlockData =
          pad32('40') +                          // offset to actions = 64
          pad32(paramsOffset.toString(16)) +     // offset to params array
          pad32(actionsLen.toString(16)) +       // actions length
          actionsPadded +                        // actions data
          paramsArray;                           // params array

        // modifyLiquidities(bytes calldata unlockData, uint256 deadline)
        // Selector: 0xdd46508f
        const modifyLiqSelector = 'dd46508f';
        const callData = '0x' + modifyLiqSelector +
          pad32('40') +                                  // offset to unlockData = 64
          pad32(deadline.toString(16)) +                 // deadline
          pad32((unlockData.length / 2).toString(16)) +  // unlockData length
          padBytes(unlockData);                          // unlockData (padded)

        console.log('[ArbMe] Collecting fees for tokenId:', tokenId, 'callData length:', callData.length);
        console.log('[ArbMe] V4 collect callData:', callData.slice(0, 100) + '...');

        const txHash = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V4_POSITION_MANAGER_JS,
            data: callData,
            gas: TX_CONSTANTS.GAS_LIMITS.REMOVE_LIQUIDITY_V4,
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Collect fees tx:', txHash);

        // Show success immediately since tx was submitted
        btn.textContent = 'Collected!';
        btn.style.background = '#10b981';
        showToast('success', 'Fees Collected!', 'View on <a href="https://basescan.org/tx/' + txHash + '" target="_blank">Basescan</a>');

        // Wait a moment then check confirmation in background
        setTimeout(async () => {
          try {
            const receiptRes = await fetch('/test/rpc?action=getTransactionReceipt&txHash=' + txHash);
            const receiptData = await receiptRes.json();
            console.log('[ArbMe] Receipt check result:', receiptData.receipt?.status);
            if (receiptData.receipt && receiptData.receipt.status !== '0x1') {
              showToast('error', 'Transaction Failed', 'The transaction may have reverted');
            }
          } catch (e) {
            console.log('[ArbMe] Receipt check error:', e);
          }

          // Reset button and refresh
          btn.textContent = originalText;
          btn.style.background = '';
          btn.disabled = false;
          loadPositions();
        }, 3000);

      } catch (e) {
        console.error('[ArbMe] Collect fees failed:', e);
        btn.textContent = 'Failed';
        btn.style.background = '#ef4444';
        const errorMsg = e.message || e.toString() || 'Unknown error';
        // Check if it's a user rejection
        if (errorMsg.includes('reject') || errorMsg.includes('denied') || errorMsg.includes('cancel')) {
          showToast('error', 'Cancelled', 'Transaction was cancelled');
        } else if (errorMsg.includes('fail') || errorMsg.includes('revert')) {
          showToast('error', 'Transaction Failed', 'No fees to collect or position issue');
        } else {
          showToast('error', 'Collection Failed', errorMsg.slice(0, 100));
        }
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '';
          btn.disabled = false;
        }, 2000);
      }
    };

    // Collect V3 fees function
    window.collectV3Fees = async function(tokenId, token0Address, token1Address) {
      if (!connectedWallet) {
        showToast('error', 'Wallet Not Connected', 'Please connect your wallet first');
        return;
      }

      const btn = event.target;
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Collecting...';

      try {
        const V3_POSITION_MANAGER_JS = '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1';

        // V3 collect function: collect((uint256 tokenId, address recipient, uint128 amount0Max, uint128 amount1Max))
        const collectSelector = '0xfc6f7865';
        const tokenIdPadded = BigInt(tokenId).toString(16).padStart(64, '0');
        const recipientPadded = connectedWallet.slice(2).toLowerCase().padStart(64, '0');
        const amount0Max = 'ffffffffffffffffffffffffffffffff'.padStart(64, '0'); // uint128 max
        const amount1Max = 'ffffffffffffffffffffffffffffffff'.padStart(64, '0'); // uint128 max

        const collectCalldata = collectSelector + tokenIdPadded + recipientPadded + amount0Max + amount1Max;

        console.log('[ArbMe] Collecting V3 fees for tokenId:', tokenId);

        const txHash = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V3_POSITION_MANAGER_JS,
            data: collectCalldata,
            gas: TX_CONSTANTS.GAS_LIMITS.COLLECT_FEES,
            value: '0x0',
          }]
        });

        console.log('[ArbMe] V3 collect fees tx:', txHash);
        btn.textContent = 'Confirming...';

        // Wait for confirmation
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          const receipt = await sdk.wallet.ethProvider.request({
            method: 'eth_getTransactionReceipt',
            params: [txHash]
          });
          if (receipt) {
            if (receipt.status === '0x1') {
              btn.textContent = 'Collected!';
              btn.style.background = '#10b981';
              showToast('success', 'Fees Collected!', 'View on <a href="https://basescan.org/tx/' + txHash + '" target="_blank">Basescan</a>');
              setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
                btn.disabled = false;
                loadPositions(); // Refresh positions
              }, 2000);
              return;
            } else {
              throw new Error('Transaction reverted');
            }
          }
        }

        btn.textContent = 'Pending...';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.disabled = false;
        }, 3000);

      } catch (e) {
        console.error('[ArbMe] V3 collect fees failed:', e);
        btn.textContent = 'Failed';
        btn.style.background = '#ef4444';
        showToast('error', 'Collection Failed', e.message || 'Unknown error');
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '';
          btn.disabled = false;
        }, 2000);
      }
    };

    window.executeV4RemoveLiquidity = async function() {
      if (!connectedWallet || !v4RemovePosition) return;

      const removeBtn = document.getElementById('v4-remove-btn');
      removeBtn.disabled = true;
      removeBtn.textContent = 'Removing...';

      try {
        setV4RemoveTxStatus('Preparing transaction...', 'pending');

        // Get the token addresses (need to resolve from symbols if not set)
        let token0Addr = v4RemovePosition.token0;
        let token1Addr = v4RemovePosition.token1;

        if (!token0Addr || token0Addr === '' || token0Addr === 'unknown') {
          token0Addr = getTokenAddressFromSymbol(v4RemovePosition.token0Symbol);
        }
        if (!token1Addr || token1Addr === '' || token1Addr === 'unknown') {
          token1Addr = getTokenAddressFromSymbol(v4RemovePosition.token1Symbol);
        }

        if (!token0Addr || !token1Addr) {
          throw new Error('Could not resolve token addresses');
        }

        // Ensure currency0 < currency1
        const [currency0, currency1] = sortAddresses(token0Addr, token1Addr);

        // Calculate liquidity to remove based on percentage
        const totalLiquidity = BigInt(v4RemovePosition.liquidity || '0');
        const liquidityToRemove = (totalLiquidity * BigInt(v4RemovePercentage)) / BigInt(100);

        if (liquidityToRemove <= BigInt(0)) {
          throw new Error('No liquidity to remove');
        }

        // Deadline: 20 minutes from now
        const deadline = Math.floor(Date.now() / 1000) + 1200;

        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        // ENCODE modifyLiquidities for DECREASE_LIQUIDITY + TAKE_PAIR
        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

        // Actions: DECREASE_LIQUIDITY (0x01), TAKE_PAIR (0x11)
        const actions = '0111';

        // DECREASE_LIQUIDITY params: (tokenId, liquidity, amount0Min, amount1Min, hookData)
        const tokenIdPadded = BigInt(v4RemovePosition.tokenId).toString(16).padStart(64, '0');
        const liquidityPadded = liquidityToRemove.toString(16).padStart(64, '0');
        const amount0MinPadded = '0'.padStart(64, '0'); // 0 slippage protection for now
        const amount1MinPadded = '0'.padStart(64, '0');
        const hookDataOffset = (5 * 32).toString(16).padStart(64, '0'); // Offset to hookData
        const hookDataLength = '0'.padStart(64, '0'); // Empty hookData

        const decreaseParams = tokenIdPadded + liquidityPadded + amount0MinPadded + amount1MinPadded + hookDataOffset + hookDataLength;

        // TAKE_PAIR params: (currency0, currency1, recipient)
        const currency0Padded = currency0.slice(2).toLowerCase().padStart(64, '0');
        const currency1Padded = currency1.slice(2).toLowerCase().padStart(64, '0');
        const recipientPadded = connectedWallet.slice(2).toLowerCase().padStart(64, '0');

        const takeParams = currency0Padded + currency1Padded + recipientPadded;

        // Encode unlockData: abi.encode(bytes actions, bytes[] params)
        const actionsLength = (2).toString(16).padStart(64, '0');
        const actionsPadded = actions.padEnd(64, '0');

        const param0Bytes = decreaseParams;
        const param1Bytes = takeParams;

        // Offsets for unlockData encoding
        const offsetActions = (64).toString(16).padStart(64, '0');
        const offsetParams = (64 + 32 + 32).toString(16).padStart(64, '0');

        const paramsArrayLength = (2).toString(16).padStart(64, '0');
        const param0Length = (param0Bytes.length / 2).toString(16).padStart(64, '0');
        const param0PaddedData = param0Bytes.padEnd(Math.ceil(param0Bytes.length / 64) * 64, '0');
        const param1Length = (param1Bytes.length / 2).toString(16).padStart(64, '0');
        const param1PaddedData = param1Bytes.padEnd(Math.ceil(param1Bytes.length / 64) * 64, '0');

        const param0Offset = (64).toString(16).padStart(64, '0');
        const param1DataSize = 32 + Math.ceil(param0Bytes.length / 64) * 32;
        const param1Offset = (64 + param1DataSize).toString(16).padStart(64, '0');

        const paramsArrayEncoded = paramsArrayLength + param0Offset + param1Offset +
          param0Length + param0PaddedData + param1Length + param1PaddedData;

        const unlockData = offsetActions + offsetParams + actionsLength + actionsPadded + paramsArrayEncoded;

        // modifyLiquidities(bytes unlockData, uint256 deadline) selector: 0xdd46508f
        const modifyLiqSelector = '0xdd46508f';
        const unlockDataOffset2 = (64).toString(16).padStart(64, '0');
        const deadlinePadded = deadline.toString(16).padStart(64, '0');
        const unlockDataLength2 = (unlockData.length / 2).toString(16).padStart(64, '0');
        const unlockDataPadded = unlockData.padEnd(Math.ceil(unlockData.length / 64) * 64, '0');

        const callData = modifyLiqSelector + unlockDataOffset2 + deadlinePadded + unlockDataLength2 + unlockDataPadded;

        console.log('[ArbMe] V4 remove liquidity callData:', callData);

        setV4RemoveTxStatus('Confirm transaction...', 'pending');

        const txHash = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V4_POSITION_MANAGER,
            data: callData,
            gas: '0x7A120', // 500000
            value: '0x0',
          }]
        });

        console.log('[ArbMe] V4 remove liquidity tx:', txHash);

        setV4RemoveTxStatus('Waiting for confirmation...', 'pending');

        // Wait for confirmation
        let confirmed = false;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          const receipt = await sdk.wallet.ethProvider.request({
            method: 'eth_getTransactionReceipt',
            params: [txHash]
          });
          if (receipt) {
            if (receipt.status === '0x1') {
              confirmed = true;
              break;
            } else {
              throw new Error('Transaction reverted');
            }
          }
        }

        if (confirmed) {
          setV4RemoveTxStatus('Liquidity removed!', 'success');
          showToast('success', 'Liquidity Removed!', 'View on <a href="https://basescan.org/tx/' + txHash + '" target="_blank">Basescan</a>');
          setTimeout(() => {
            closeV4RemoveModal();
            loadPositions();
          }, 2000);
        } else {
          setV4RemoveTxStatus('Transaction not confirmed', 'error');
        }

      } catch (e) {
        console.error('[ArbMe] V4 remove liquidity failed:', e);
        setV4RemoveTxStatus('Failed: ' + (e.message || 'Unknown error'), 'error');
        showToast('error', 'Transaction Failed', e.message || 'Unknown error');
      } finally {
        removeBtn.disabled = false;
        removeBtn.textContent = 'Remove Liquidity';
      }
    };

    // V3 Add Liquidity Functions
    // Use consolidated status utility (P2.15)
    const setV3AddTxStatus = createTxStatusUpdater('v3-add-tx-status');

    window.openV3AddLiquidityModal = async function(poolAddress, pair) {
      console.log('[ArbMe] Opening V3 add liquidity modal for pool:', poolAddress, pair);

      if (!connectedWallet) {
        setTxStatus('Connect wallet first', 'error');
        await connectWallet();
        return;
      }

      try {
        // Parse pair string to get token symbols
        const [symbol0, symbol1] = pair ? pair.split(' / ') : ['TOKEN0', 'TOKEN1'];

        // Fetch pool info to get token addresses
        const poolRes = await fetch(\`/test/rpc?action=v3_pool_info&pool=\${poolAddress}\`);
        const poolData = await poolRes.json();

        if (poolData.error) {
          console.log('[ArbMe] V3 pool info not available, using known token addresses');
          // Fallback: use known token addresses based on symbols
          let token0Addr = getTokenAddressFromSymbol(symbol0);
          let token1Addr = getTokenAddressFromSymbol(symbol1);

          if (!token0Addr || !token1Addr) {
            const unknownToken = !token0Addr ? symbol0 : symbol1;
            console.error('[ArbMe] Unknown token:', unknownToken);
            setTxStatus('Unknown token: ' + unknownToken + '. Cannot add liquidity.', 'error');
            return;
          }

          // V3 requires token0 < token1 by address - sort if needed
          let sym0 = symbol0, sym1 = symbol1;
          if (!isAddressLessThan(token0Addr, token1Addr)) {
            [token0Addr, token1Addr] = [token1Addr, token0Addr];
            [sym0, sym1] = [sym1, sym0];
          }

          // Validate decimals from known tokens - NEVER default to 18
          const dec0 = getTokenDecimalsFromSymbol(sym0);
          const dec1 = getTokenDecimalsFromSymbol(sym1);
          if (dec0 === null) {
            throw new Error(\`Unknown token decimals for \${sym0}. Cannot proceed safely.\`);
          }
          if (dec1 === null) {
            throw new Error(\`Unknown token decimals for \${sym1}. Cannot proceed safely.\`);
          }

          v3AddPool = {
            address: poolAddress,
            token0: token0Addr,
            token1: token1Addr,
            token0Symbol: sym0,
            token1Symbol: sym1,
            token0Decimals: dec0,
            token1Decimals: dec1,
            fee: v3AddSelectedFee,
          };
        } else {
          // Get token info for both tokens
          const [info0Res, info1Res] = await Promise.all([
            fetch(\`/test/rpc?action=tokenInfo&token=\${poolData.token0}\`),
            fetch(\`/test/rpc?action=tokenInfo&token=\${poolData.token1}\`)
          ]);
          const info0 = await info0Res.json();
          const info1 = await info1Res.json();

          // Validate decimals - NEVER default to 18
          const dec0 = toSafeDecimals(info0.decimals);
          const dec1 = toSafeDecimals(info1.decimals);
          if (dec0 === null) {
            throw new Error(\`Could not verify decimals for \${info0.symbol || poolData.token0}\`);
          }
          if (dec1 === null) {
            throw new Error(\`Could not verify decimals for \${info1.symbol || poolData.token1}\`);
          }

          v3AddPool = {
            address: poolAddress,
            token0: poolData.token0,
            token1: poolData.token1,
            token0Symbol: info0.symbol || symbol0,
            token1Symbol: info1.symbol || symbol1,
            token0Decimals: dec0,
            token1Decimals: dec1,
            fee: poolData.fee || v3AddSelectedFee,
          };

          // Update fee selector to match pool fee
          v3AddSelectedFee = parseInt(poolData.fee) || 3000;
        }

        const modal = document.getElementById('v3-add-modal');
        modal.classList.add('visible');
        setV3AddTxStatus('', '');

        // Update modal title and labels
        document.getElementById('v3-add-title').textContent = \`Add V3 Liquidity: \${v3AddPool.token0Symbol}/\${v3AddPool.token1Symbol}\`;
        document.getElementById('v3-add-token0-label').textContent = \`\${v3AddPool.token0Symbol} Amount\`;
        document.getElementById('v3-add-token1-label').textContent = \`\${v3AddPool.token1Symbol} Amount\`;
        document.getElementById('v3-add-token0-symbol').textContent = v3AddPool.token0Symbol;
        document.getElementById('v3-add-token1-symbol').textContent = v3AddPool.token1Symbol;
        document.getElementById('v3-add-token0-symbol-approval').textContent = v3AddPool.token0Symbol;
        document.getElementById('v3-add-token1-symbol-approval').textContent = v3AddPool.token1Symbol;

        // Update token icons
        const icon0 = getTokenIcon(v3AddPool.token0Symbol);
        const icon1 = getTokenIcon(v3AddPool.token1Symbol);
        if (icon0) document.getElementById('v3-add-token0-icon').src = icon0;
        if (icon1) document.getElementById('v3-add-token1-icon').src = icon1;

        // Hide fee selector and show locked fee display (fee is set by pool)
        document.getElementById('v3-fee-selector-group').style.display = 'none';
        document.getElementById('v3-fee-display').style.display = 'block';
        const feePercent = (v3AddSelectedFee / 10000).toFixed(v3AddSelectedFee < 1000 ? 2 : 1) + '%';
        document.getElementById('v3-fee-display-value').textContent = feePercent;

        // Reset inputs
        document.getElementById('v3-add-token0-input').value = '';
        document.getElementById('v3-add-token1-input').value = '';

        // Load balances, check approvals, fetch prices (using settleAll for graceful partial failure)
        await settleAll(
          [loadV3AddBalances(), checkV3AddApprovals(), loadV3AddPrices()],
          ['loadV3AddBalances', 'checkV3AddApprovals', 'loadV3AddPrices']
        );

        // Set up auto-balance input listeners
        setupV3AutoBalance();

      } catch (e) {
        console.error('[ArbMe] Failed to open V3 add liquidity modal:', e);
        setTxStatus('Failed: ' + (e.message || 'Unknown error'), 'error');
      }
    };

    async function loadV3AddBalances() {
      if (!connectedWallet || !v3AddPool) return;

      try {
        const [bal0Res, bal1Res] = await Promise.all([
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${v3AddPool.token0}\`),
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${v3AddPool.token1}\`)
        ]);
        const bal0 = await bal0Res.json();
        const bal1 = await bal1Res.json();

        v3AddToken0Balance = bal0.balanceFormatted || 0;
        v3AddToken1Balance = bal1.balanceFormatted || 0;

        document.getElementById('v3-add-token0-balance').textContent = \`Balance: \${formatNumber(v3AddToken0Balance)}\`;
        document.getElementById('v3-add-token1-balance').textContent = \`Balance: \${formatNumber(v3AddToken1Balance)}\`;
      } catch (e) {
        console.error('[ArbMe] Failed to load V3 balances:', e);
      }
    }

    async function checkV3AddApprovals() {
      if (!connectedWallet || !v3AddPool) return;

      // Use consolidated utility (P2.12)
      const result = await checkPairAllowances(
        connectedWallet,
        v3AddPool.token0,
        v3AddPool.token1,
        V3_POSITION_MANAGER_JS
      );

      v3AddToken0Approved = result.token0Approved;
      v3AddToken1Approved = result.token1Approved;

      if (result.error) {
        console.error('[ArbMe] V3 approval check error:', result.error);
      }

      updateV3AddApprovalUI();
    }

    function updateV3AddApprovalUI() {
      const check0 = document.getElementById('v3-add-token0-approval-check');
      const text0 = document.getElementById('v3-add-token0-approval-text');
      const check1 = document.getElementById('v3-add-token1-approval-check');
      const text1 = document.getElementById('v3-add-token1-approval-text');
      const approveBtn = document.getElementById('v3-add-approve-btn');

      // Use consolidated utility (P2.12)
      updateApprovalElement(check0, text0, v3AddToken0Approved);
      updateApprovalElement(check1, text1, v3AddToken1Approved);

      approveBtn.style.display = (!v3AddToken0Approved || !v3AddToken1Approved) ? 'block' : 'none';
    }

    async function loadV3AddPrices() {
      if (!v3AddPool) return;
      try {
        // Fetch USD prices (for display purposes)
        const tokens = \`\${v3AddPool.token0},\${v3AddPool.token1}\`;
        const pricesRes = await fetch(\`/test/rpc?action=tokenPrices&tokens=\${tokens}\`);
        const pricesData = await pricesRes.json();
        if (pricesData.prices) {
          v3AddToken0Price = pricesData.prices[v3AddPool.token0.toLowerCase()] || 0;
          v3AddToken1Price = pricesData.prices[v3AddPool.token1.toLowerCase()] || 0;
        }
        console.log('[ArbMe] V3 add USD prices loaded:', v3AddToken0Price, v3AddToken1Price);

        // Fetch pool's actual price ratio from sqrtPriceX96
        if (v3AddPool.address) {
          const slot0Res = await fetch(\`/test/rpc?action=v3_slot0&poolAddress=\${v3AddPool.address}\`);
          const slot0Data = await slot0Res.json();
          if (slot0Data.sqrtPriceX96 && slot0Data.sqrtPriceX96 !== '0x') {
            // Use consolidated price utility (P2.11)
            const dec0 = v3AddPool.token0Decimals || 18;
            const dec1 = v3AddPool.token1Decimals || 18;
            v3AddPoolPriceRatio = sqrtPriceX96ToPrice(slot0Data.sqrtPriceX96, dec0, dec1);
            console.log('[ArbMe] V3 pool price ratio (token1 per token0):', v3AddPoolPriceRatio);
          }
        }
      } catch (e) {
        console.error('[ArbMe] Failed to load V3 add prices:', e);
      }
    }

    function setupV3AutoBalance() {
      // Use consolidated auto-balance utility (P2.14)
      setupAutoBalanceInputs({
        input0Id: 'v3-add-token0-input',
        input1Id: 'v3-add-token1-input',
        priceRatioGetter: () => v3AddPoolPriceRatio
      });
    }

    window.setV3MaxToken0 = function() {
      document.getElementById('v3-add-token0-input').value = v3AddToken0Balance.toString();
      // Trigger auto-balance
      document.getElementById('v3-add-token0-input').dispatchEvent(new Event('input'));
    };

    window.setV3MaxToken1 = function() {
      document.getElementById('v3-add-token1-input').value = v3AddToken1Balance.toString();
      // Trigger auto-balance
      document.getElementById('v3-add-token1-input').dispatchEvent(new Event('input'));
    };

    window.closeV3AddModal = function() {
      document.getElementById('v3-add-modal').classList.remove('visible');
      v3AddPool = null;
      setV3AddTxStatus('', '');
    };

    window.approveV3Tokens = async function() {
      if (!connectedWallet || !v3AddPool) return;

      // Get amounts from input fields
      const amount0Input = parseFloat(document.getElementById('v3-add-token0-input').value) || 0;
      const amount1Input = parseFloat(document.getElementById('v3-add-token1-input').value) || 0;

      if (amount0Input <= 0 && amount1Input <= 0) {
        setV3AddTxStatus('Enter amounts first', 'error');
        return;
      }

      const approveBtn = document.getElementById('v3-add-approve-btn');
      approveBtn.disabled = true;
      approveBtn.textContent = 'Approving...';

      try {
        // Calculate raw amounts with some buffer (10% extra for slippage)
        const amount0Raw = BigInt(Math.floor(amount0Input * 1.1 * (10 ** (v3AddPool.token0Decimals || 18))));
        const amount1Raw = BigInt(Math.floor(amount1Input * 1.1 * (10 ** (v3AddPool.token1Decimals || 18))));

        const tokensToApprove = [];
        if (!v3AddToken0Approved && amount0Input > 0) {
          tokensToApprove.push({ token: v3AddPool.token0, symbol: v3AddPool.token0Symbol, amount: amount0Raw });
        }
        if (!v3AddToken1Approved && amount1Input > 0) {
          tokensToApprove.push({ token: v3AddPool.token1, symbol: v3AddPool.token1Symbol, amount: amount1Raw });
        }

        for (const { token, symbol, amount } of tokensToApprove) {
          setV3AddTxStatus(\`Approving \${symbol}...\`, 'pending');

          // Approve exact amount to V3 Position Manager
          const amountHex = amount.toString(16).padStart(64, '0');
          const approvalData = '0x095ea7b3' +
            V3_POSITION_MANAGER_JS.slice(2).toLowerCase().padStart(64, '0') +
            amountHex;

          const txHash = await sdk.wallet.ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: connectedWallet,
              to: token,
              data: approvalData,
              gas: '0x15F90', // 90000
              value: '0x0',
            }]
          });

          setV3AddTxStatus(\`Waiting for \${symbol} approval...\`, 'pending');

          let confirmed = false;
          for (let i = 0; i < 30; i++) {
            await new Promise(r => setTimeout(r, 2000));
            const receipt = await sdk.wallet.ethProvider.request({
              method: 'eth_getTransactionReceipt',
              params: [txHash]
            });
            if (receipt && receipt.status === '0x1') {
              confirmed = true;
              break;
            }
          }

          if (!confirmed) {
            setV3AddTxStatus(\`\${symbol} approval not confirmed\`, 'error');
            return;
          }

          if (token === v3AddPool.token0) v3AddToken0Approved = true;
          if (token === v3AddPool.token1) v3AddToken1Approved = true;
        }

        setV3AddTxStatus('Tokens approved!', 'success');
        updateV3AddApprovalUI();

      } catch (e) {
        console.error('[ArbMe] V3 approval failed:', e);
        setV3AddTxStatus('Approval failed: ' + (e.message || 'Unknown error'), 'error');
      } finally {
        approveBtn.disabled = false;
        approveBtn.textContent = 'Approve Tokens';
      }
    };

    window.selectV3Fee = function(fee) {
      v3AddSelectedFee = fee;
      document.querySelectorAll('#v3-fee-selector .selector-option').forEach(opt => {
        opt.classList.toggle('selected', parseInt(opt.dataset.fee) === fee);
      });
    };

    // Helper to get full range ticks for V3 based on fee tier
    function getV3FullRangeTicks(fee) {
      // Tick spacing varies by fee tier
      const tickSpacing = {
        100: 1,       // 0.01%
        500: 10,      // 0.05%
        3000: 60,     // 0.3%
        10000: 200,   // 1%
        30000: 200,   // 3%
        50000: 200,   // 5%
        100000: 200,  // 10%
        250000: 200,  // 25%
        500000: 200,  // 50%
      }[fee] || 60;

      // Max tick must be divisible by tick spacing
      const maxTick = Math.floor(887272 / tickSpacing) * tickSpacing;
      return { tickLower: -maxTick, tickUpper: maxTick };
    }

    // Helper to encode int24 as hex (two's complement for negative)
    function encodeInt24(value) {
      // For ABI encoding, int24 needs to be sign-extended to 32 bytes (256 bits)
      if (value < 0) {
        // Two's complement for negative values - sign extend to 256 bits
        // First get 24-bit two's complement
        const twosComp24 = (1 << 24) + value;
        // Sign extend: pad with 'f' for negative, convert to 64 hex chars
        return 'f'.repeat(58) + twosComp24.toString(16).padStart(6, '0');
      }
      // For positive values, pad with zeros
      return value.toString(16).padStart(64, '0');
    }

    window.executeV3AddLiquidity = async function() {
      if (!connectedWallet || !v3AddPool) return;

      const amount0 = parseFloat(document.getElementById('v3-add-token0-input').value) || 0;
      const amount1 = parseFloat(document.getElementById('v3-add-token1-input').value) || 0;

      // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
      // CRITICAL GUARDRAIL: Require BOTH tokens for balanced deposits
      // This prevents catastrophic loss from one-sided liquidity adds
      // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
      if (amount0 <= 0 || amount1 <= 0) {
        setV3AddTxStatus('BOTH token amounts required for balanced deposit', 'error');
        return;
      }

      // Additional check: amounts must be meaningful (not dust)
      if (amount0 < 0.000001 || amount1 < 0.000001) {
        setV3AddTxStatus('Token amounts too small', 'error');
        return;
      }

      if (!v3AddToken0Approved || !v3AddToken1Approved) {
        setV3AddTxStatus('Approve tokens first', 'error');
        return;
      }

      const addBtn = document.getElementById('v3-add-liquidity-btn');
      addBtn.disabled = true;
      addBtn.textContent = 'Adding...';

      try {
        setV3AddTxStatus('Verifying token decimals...', 'pending');

        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        // CRITICAL: Verify decimals on-chain before transaction
        // This prevents catastrophic loss from decimal mismatches
        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        const decimalVerification = await verifyPairDecimalsOnChain(
          v3AddPool.token0,
          v3AddPool.token1,
          v3AddPool.token0Decimals,
          v3AddPool.token1Decimals,
          v3AddPool.token0Symbol,
          v3AddPool.token1Symbol
        );

        if (!decimalVerification.verified) {
          setV3AddTxStatus('BLOCKED: ' + decimalVerification.errors.join('; '), 'error');
          addBtn.disabled = false;
          addBtn.textContent = 'Add Liquidity';
          return;
        }

        setV3AddTxStatus('Creating V3 position...', 'pending');

        // Convert amounts to raw values
        const amount0Raw = BigInt(Math.floor(amount0 * (10 ** v3AddPool.token0Decimals)));
        const amount1Raw = BigInt(Math.floor(amount1 * (10 ** v3AddPool.token1Decimals)));

        // Get full range ticks
        const { tickLower, tickUpper } = getV3FullRangeTicks(v3AddSelectedFee);

        // Deadline: 20 minutes from now
        const deadline = Math.floor(Date.now() / 1000) + 1200;

        // Encode mint parameters
        // mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))
        // Function selector: 0x88316456
        const mintSelector = '0x88316456';

        // Encode the struct - each field padded to 32 bytes
        const token0Padded = v3AddPool.token0.slice(2).toLowerCase().padStart(64, '0');
        const token1Padded = v3AddPool.token1.slice(2).toLowerCase().padStart(64, '0');
        const feePadded = v3AddSelectedFee.toString(16).padStart(64, '0');
        const tickLowerPadded = encodeInt24(tickLower);
        const tickUpperPadded = encodeInt24(tickUpper);
        const amount0DesiredPadded = amount0Raw.toString(16).padStart(64, '0');
        const amount1DesiredPadded = amount1Raw.toString(16).padStart(64, '0');
        const amount0MinPadded = '0'.padStart(64, '0'); // 0 for simplicity (slippage not protected)
        const amount1MinPadded = '0'.padStart(64, '0');
        const recipientPadded = connectedWallet.slice(2).toLowerCase().padStart(64, '0');
        const deadlinePadded = deadline.toString(16).padStart(64, '0');

        const mintData = mintSelector +
          token0Padded +
          token1Padded +
          feePadded +
          tickLowerPadded +
          tickUpperPadded +
          amount0DesiredPadded +
          amount1DesiredPadded +
          amount0MinPadded +
          amount1MinPadded +
          recipientPadded +
          deadlinePadded;

        console.log('[ArbMe] V3 mint data:', mintData);

        const txHash = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V3_POSITION_MANAGER_JS,
            data: mintData,
            gas: '0x7A120', // 500000
            value: '0x0',
          }]
        });

        console.log('[ArbMe] V3 add liquidity txHash:', txHash);

        setV3AddTxStatus('Waiting for confirmation...', 'pending');

        // Wait for confirmation
        let confirmed = false;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          const receipt = await sdk.wallet.ethProvider.request({
            method: 'eth_getTransactionReceipt',
            params: [txHash]
          });
          if (receipt) {
            if (receipt.status === '0x1') {
              confirmed = true;
              break;
            } else {
              throw new Error('Transaction reverted');
            }
          }
        }

        if (confirmed) {
          setV3AddTxStatus('Position created!', 'success');
          showToast('success', 'Liquidity Added!', 'View on <a href="https://basescan.org/tx/' + txHash + '" target="_blank">Basescan</a>');
          setTimeout(() => {
            closeV3AddModal();
            loadPositions(); // Refresh positions
          }, 2000);
        } else {
          setV3AddTxStatus('Transaction not confirmed', 'error');
        }

      } catch (e) {
        console.error('[ArbMe] V3 add liquidity failed:', e);
        setV3AddTxStatus('Failed: ' + (e.message || 'Unknown error'), 'error');
        showToast('error', 'Transaction Failed', e.message || 'Unknown error');
      } finally {
        addBtn.disabled = false;
        addBtn.textContent = 'Add Liquidity';
      }
    };

    // Initialize V3 fee selector click handlers
    document.querySelectorAll('#v3-fee-selector .selector-option').forEach(opt => {
      opt.addEventListener('click', () => {
        const fee = parseInt(opt.dataset.fee);
        selectV3Fee(fee);
      });
    });

    // V4 Add Liquidity Functions
    // Use consolidated status utility (P2.15)
    const setV4AddTxStatus = createTxStatusUpdater('v4-add-tx-status');

    // Helper to get V4 tick spacing based on fee tier
    function getV4TickSpacing(fee) {
      // V4 tick spacing varies by fee tier
      const tickSpacing = {
        100: 1,       // 0.01%
        500: 10,      // 0.05%
        3000: 60,     // 0.3%
        10000: 200,   // 1%
        30000: 200,   // 3%
        50000: 200,   // 5%
        100000: 200,  // 10%
        250000: 200,  // 25%
        500000: 200,  // 50%
      }[fee] || 200; // Default to 200 for unknown fees
      return tickSpacing;
    }

    // Open V4 add liquidity modal with known token addresses (from existing position)
    window.openV4AddLiquidityModalWithAddresses = async function(pair, token0Symbol, token1Symbol, token0Address, token1Address, fee, tickSpacing) {
      console.log('[ArbMe] Opening V4 add liquidity modal with addresses:', pair, token0Address, token1Address, fee, tickSpacing);

      if (!connectedWallet) {
        setTxStatus('Connect wallet first', 'error');
        await connectWallet();
        return;
      }

      try {
        // Ensure correct ordering: currency0 < currency1
        let currency0 = token0Address;
        let currency1 = token1Address;
        let sym0 = token0Symbol;
        let sym1 = token1Symbol;

        if (!isAddressLessThan(token0Address, token1Address)) {
          currency0 = token1Address;
          currency1 = token0Address;
          sym0 = token1Symbol;
          sym1 = token0Symbol;
        }

        // Compute poolId from pool key components
        let poolId = '';
        let currentTick = 0;
        try {
          const computeRes = await fetch(\`/test/rpc?action=computePoolId&currency0=\${currency0}&currency1=\${currency1}&fee=\${fee}&tickSpacing=\${tickSpacing}&hooks=0x0000000000000000000000000000000000000000\`);
          const computeData = await computeRes.json();
          if (computeData.poolId) {
            poolId = computeData.poolId;
            console.log('[ArbMe] Computed poolId:', poolId);
          }
        } catch (e) {
          console.log('[ArbMe] Could not compute poolId:', e);
        }

        v4AddPool = {
          address: poolId, // Computed poolId for fetching slot0
          pair: pair,
          token0: currency0,
          token1: currency1,
          token0Symbol: sym0,
          token1Symbol: sym1,
          token0Decimals: getTokenDecimalsFromSymbol(sym0),
          token1Decimals: getTokenDecimalsFromSymbol(sym1),
          fee: fee,
          tickSpacing: tickSpacing,
          hooks: '0x0000000000000000000000000000000000000000',
          currentTick: currentTick,
        };

        v4AddSelectedFee = fee;

        const modal = document.getElementById('v4-add-modal');
        modal.classList.add('visible');
        setV4AddTxStatus('', '');

        // Update modal title and labels
        document.getElementById('v4-add-title').textContent = \`Add V4 Liquidity: \${sym0}/\${sym1}\`;
        document.getElementById('v4-add-token0-label').textContent = \`\${sym0} Amount\`;
        document.getElementById('v4-add-token1-label').textContent = \`\${sym1} Amount\`;
        document.getElementById('v4-add-token0-symbol').textContent = sym0;
        document.getElementById('v4-add-token1-symbol').textContent = sym1;
        document.getElementById('v4-add-token0-symbol-approval').textContent = sym0;
        document.getElementById('v4-add-token1-symbol-approval').textContent = sym1;

        // Update token icons
        const icon0 = getTokenIcon(sym0);
        const icon1 = getTokenIcon(sym1);
        if (icon0) document.getElementById('v4-add-token0-icon').src = icon0;
        if (icon1) document.getElementById('v4-add-token1-icon').src = icon1;

        // Hide fee selector, show fee display (fee is locked for existing pools)
        document.getElementById('v4-fee-selector-group').style.display = 'none';
        document.getElementById('v4-fee-display').style.display = 'block';
        document.getElementById('v4-fee-display-value').textContent = (fee / 10000).toFixed(2) + '%';

        // Reset inputs
        document.getElementById('v4-add-token0-input').value = '';
        document.getElementById('v4-add-token1-input').value = '';

        // Load balances, check approvals, fetch prices (using settleAll for graceful partial failure)
        await settleAll(
          [loadV4AddBalances(), checkV4AddApprovals(), loadV4AddPrices()],
          ['loadV4AddBalances', 'checkV4AddApprovals', 'loadV4AddPrices']
        );

        // Set up auto-balance input listeners
        setupV4AutoBalance();

      } catch (e) {
        console.error('[ArbMe] Failed to open V4 add liquidity modal:', e);
        setTxStatus('Failed: ' + (e.message || 'Unknown error'), 'error');
      }
    };

    window.openV4AddLiquidityModal = async function(poolAddress, pair) {
      console.log('[ArbMe] Opening V4 add liquidity modal for pool:', poolAddress, pair);

      if (!connectedWallet) {
        setTxStatus('Connect wallet first', 'error');
        await connectWallet();
        return;
      }

      try {
        // Parse pair string to get token symbols
        const [symbol0, symbol1] = pair ? pair.split(' / ') : ['TOKEN0', 'TOKEN1'];

        // Fetch V4 pool info
        const poolRes = await fetch(\`/test/rpc?action=v4_pool_info&pool=\${poolAddress}\`);
        const poolData = await poolRes.json();

        if (poolData.error) {
          console.log('[ArbMe] V4 pool info not available, using known token addresses');
          // Fallback: use known token addresses based on symbols
          const token0Addr = getTokenAddressFromSymbol(symbol0);
          const token1Addr = getTokenAddressFromSymbol(symbol1);

          if (!token0Addr || !token1Addr) {
            const unknownToken = !token0Addr ? symbol0 : symbol1;
            console.error('[ArbMe] Unknown token:', unknownToken);
            setTxStatus('Unknown token: ' + unknownToken + '. Cannot add liquidity.', 'error');
            return;
          }

          // For V4, currency0 must be < currency1 (by address comparison)
          // Re-sort tokens if needed
          let currency0, currency1, sym0, sym1;
          if (isAddressLessThan(token0Addr, token1Addr)) {
            currency0 = token0Addr;
            currency1 = token1Addr;
            sym0 = symbol0;
            sym1 = symbol1;
          } else {
            currency0 = token1Addr;
            currency1 = token0Addr;
            sym0 = symbol1;
            sym1 = symbol0;
          }

          // If no poolAddress provided, search for matching pool in poolsData
          let actualPoolId = poolAddress;
          let currentTick = 0;
          let lpFee = 10000; // Default 1%

          if (!poolAddress || poolAddress === '') {
            // Try to find the pool from the loaded pools list
            const searchPair = sym0 + ' / ' + sym1;
            const searchPairReverse = sym1 + ' / ' + sym0;
            console.log('[ArbMe] No poolId provided, searching poolsData for:', searchPair);

            if (poolsData && poolsData.pools) {
              const matchingPool = poolsData.pools.find(p =>
                (p.pair === searchPair || p.pair === searchPairReverse) && p.dex.includes('V4')
              );
              if (matchingPool) {
                actualPoolId = matchingPool.pairAddress;
                console.log('[ArbMe] Found matching V4 pool:', actualPoolId);
              }
            }

            if (!actualPoolId) {
              setTxStatus('No V4 pool found for ' + sym0 + '/' + sym1 + '. Select from Pools list.', 'error');
              return;
            }
          }

          // Fetch slot0 for the pool
          try {
            const slot0Res = await fetch(\`/test/rpc?action=v4_getSlot0&poolId=\${actualPoolId}\`);
            const slot0Data = await slot0Res.json();
            if (slot0Data.tick !== undefined) {
              currentTick = slot0Data.tick;
            }
            if (slot0Data.lpFee) {
              lpFee = slot0Data.lpFee;
            }
          } catch (e) {
            console.log('[ArbMe] Could not fetch slot0:', e);
          }

          // Validate decimals from known tokens - NEVER default to 18
          const dec0 = getTokenDecimalsFromSymbol(sym0);
          const dec1 = getTokenDecimalsFromSymbol(sym1);
          if (dec0 === null) {
            throw new Error(\`Unknown token decimals for \${sym0}. Cannot proceed safely.\`);
          }
          if (dec1 === null) {
            throw new Error(\`Unknown token decimals for \${sym1}. Cannot proceed safely.\`);
          }

          v4AddPool = {
            address: actualPoolId,
            pair: pair,
            token0: currency0,
            token1: currency1,
            token0Symbol: sym0,
            token1Symbol: sym1,
            token0Decimals: dec0,
            token1Decimals: dec1,
            fee: lpFee,
            tickSpacing: getV4TickSpacing(lpFee),
            hooks: '0x0000000000000000000000000000000000000000',
            currentTick: currentTick,
          };

          v4AddSelectedFee = lpFee;
        } else {
          // Get token info
          const [info0Res, info1Res] = await Promise.all([
            fetch(\`/test/rpc?action=tokenInfo&token=\${poolData.currency0 || poolData.token0}\`),
            fetch(\`/test/rpc?action=tokenInfo&token=\${poolData.currency1 || poolData.token1}\`)
          ]);
          const info0 = await info0Res.json();
          const info1 = await info1Res.json();

          // Validate decimals - NEVER default to 18
          const dec0 = toSafeDecimals(info0.decimals);
          const dec1 = toSafeDecimals(info1.decimals);
          if (dec0 === null) {
            throw new Error(\`Could not verify decimals for \${info0.symbol || poolData.token0}\`);
          }
          if (dec1 === null) {
            throw new Error(\`Could not verify decimals for \${info1.symbol || poolData.token1}\`);
          }

          v4AddPool = {
            address: poolAddress,
            token0: poolData.currency0 || poolData.token0,
            token1: poolData.currency1 || poolData.token1,
            token0Symbol: info0.symbol || symbol0,
            token1Symbol: info1.symbol || symbol1,
            token0Decimals: dec0,
            token1Decimals: dec1,
            fee: poolData.fee || v4AddSelectedFee,
            tickSpacing: poolData.tickSpacing || getV4TickSpacing(poolData.fee || v4AddSelectedFee),
            hooks: poolData.hooks || '0x0000000000000000000000000000000000000000',
          };

          v4AddSelectedFee = parseInt(poolData.fee) || 3000;
        }

        const modal = document.getElementById('v4-add-modal');
        modal.classList.add('visible');
        setV4AddTxStatus('', '');

        // Update modal title and labels
        document.getElementById('v4-add-title').textContent = \`Add V4 Liquidity: \${v4AddPool.token0Symbol}/\${v4AddPool.token1Symbol}\`;
        document.getElementById('v4-add-token0-label').textContent = \`\${v4AddPool.token0Symbol} Amount\`;
        document.getElementById('v4-add-token1-label').textContent = \`\${v4AddPool.token1Symbol} Amount\`;
        document.getElementById('v4-add-token0-symbol').textContent = v4AddPool.token0Symbol;
        document.getElementById('v4-add-token1-symbol').textContent = v4AddPool.token1Symbol;
        document.getElementById('v4-add-token0-symbol-approval').textContent = v4AddPool.token0Symbol;
        document.getElementById('v4-add-token1-symbol-approval').textContent = v4AddPool.token1Symbol;

        // Update token icons
        const icon0 = getTokenIcon(v4AddPool.token0Symbol);
        const icon1 = getTokenIcon(v4AddPool.token1Symbol);
        if (icon0) document.getElementById('v4-add-token0-icon').src = icon0;
        if (icon1) document.getElementById('v4-add-token1-icon').src = icon1;

        // Hide fee selector, show fee display (fee is locked for existing pools)
        document.getElementById('v4-fee-selector-group').style.display = 'none';
        document.getElementById('v4-fee-display').style.display = 'block';
        document.getElementById('v4-fee-display-value').textContent = (v4AddSelectedFee / 10000).toFixed(2) + '%';

        // Reset inputs
        document.getElementById('v4-add-token0-input').value = '';
        document.getElementById('v4-add-token1-input').value = '';

        // Load balances, check approvals, fetch prices (using settleAll for graceful partial failure)
        if (v4AddPool.token0 && v4AddPool.token1) {
          await settleAll(
            [loadV4AddBalances(), checkV4AddApprovals(), loadV4AddPrices()],
            ['loadV4AddBalances', 'checkV4AddApprovals', 'loadV4AddPrices']
          );
        }

        // Set up auto-balance input listeners
        setupV4AutoBalance();

      } catch (e) {
        console.error('[ArbMe] Failed to open V4 add liquidity modal:', e);
        setTxStatus('Failed: ' + (e.message || 'Unknown error'), 'error');
      }
    };

    async function loadV4AddBalances() {
      if (!connectedWallet || !v4AddPool || !v4AddPool.token0) return;

      try {
        const [bal0Res, bal1Res] = await Promise.all([
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${v4AddPool.token0}\`),
          fetch(\`/test/rpc?action=tokenBalance&wallet=\${connectedWallet}&token=\${v4AddPool.token1}\`)
        ]);
        const bal0 = await bal0Res.json();
        const bal1 = await bal1Res.json();

        v4AddToken0Balance = bal0.balanceFormatted || 0;
        v4AddToken1Balance = bal1.balanceFormatted || 0;

        document.getElementById('v4-add-token0-balance').textContent = \`Balance: \${formatNumber(v4AddToken0Balance)}\`;
        document.getElementById('v4-add-token1-balance').textContent = \`Balance: \${formatNumber(v4AddToken1Balance)}\`;
      } catch (e) {
        console.error('[ArbMe] Failed to load V4 balances:', e);
      }
    }

    async function checkV4AddApprovals() {
      if (!connectedWallet || !v4AddPool || !v4AddPool.token0) return;

      // V4 uses Permit2 for token approvals - use consolidated utility (P2.12)
      const result = await checkPairAllowances(
        connectedWallet,
        v4AddPool.token0,
        v4AddPool.token1,
        PERMIT2_ADDRESS
      );

      v4AddToken0Approved = result.token0Approved;
      v4AddToken1Approved = result.token1Approved;

      if (result.error) {
        console.error('[ArbMe] V4 approval check error:', result.error);
      }

      updateV4AddApprovalUI();
    }

    function updateV4AddApprovalUI() {
      const check0 = document.getElementById('v4-add-token0-approval-check');
      const text0 = document.getElementById('v4-add-token0-approval-text');
      const check1 = document.getElementById('v4-add-token1-approval-check');
      const text1 = document.getElementById('v4-add-token1-approval-text');
      const approveBtn = document.getElementById('v4-add-approve-btn');

      // Use consolidated utility (P2.12)
      updateApprovalElement(check0, text0, v4AddToken0Approved);
      updateApprovalElement(check1, text1, v4AddToken1Approved);

      approveBtn.style.display = (!v4AddToken0Approved || !v4AddToken1Approved) ? 'block' : 'none';
    }

    async function loadV4AddPrices() {
      if (!v4AddPool || !v4AddPool.token0) return;
      try {
        // Fetch USD prices (for display purposes)
        const tokens = \`\${v4AddPool.token0},\${v4AddPool.token1}\`;
        const pricesRes = await fetch(\`/test/rpc?action=tokenPrices&tokens=\${tokens}\`);
        const pricesData = await pricesRes.json();
        if (pricesData.prices) {
          v4AddToken0Price = pricesData.prices[v4AddPool.token0.toLowerCase()] || 0;
          v4AddToken1Price = pricesData.prices[v4AddPool.token1.toLowerCase()] || 0;
        }
        console.log('[ArbMe] V4 add USD prices loaded:', v4AddToken0Price, v4AddToken1Price);

        // Fetch pool's actual price ratio from sqrtPriceX96
        // This is what we use for auto-balancing deposits
        if (v4AddPool.address) {
          const slot0Res = await fetch(\`/test/rpc?action=v4_getSlot0&poolId=\${v4AddPool.address}\`);
          const slot0Data = await slot0Res.json();
          if (slot0Data.sqrtPriceX96 && slot0Data.sqrtPriceX96 !== '0x' && slot0Data.sqrtPriceX96 !== '0x0') {
            // Use consolidated price utility (P2.11)
            const dec0 = v4AddPool.token0Decimals || 18;
            const dec1 = v4AddPool.token1Decimals || 18;
            v4AddPoolPriceRatio = sqrtPriceX96ToPrice(slot0Data.sqrtPriceX96, dec0, dec1);
            console.log('[ArbMe] V4 pool price ratio (token1 per token0):', v4AddPoolPriceRatio);
          }
        }
      } catch (e) {
        console.error('[ArbMe] Failed to load V4 add prices:', e);
      }
    }

    function setupV4AutoBalance() {
      // Use consolidated auto-balance utility (P2.14)
      setupAutoBalanceInputs({
        input0Id: 'v4-add-token0-input',
        input1Id: 'v4-add-token1-input',
        priceRatioGetter: () => v4AddPoolPriceRatio
      });
    }

    window.setV4MaxToken0 = function() {
      document.getElementById('v4-add-token0-input').value = v4AddToken0Balance.toString();
      // Trigger auto-balance
      document.getElementById('v4-add-token0-input').dispatchEvent(new Event('input'));
    };

    window.setV4MaxToken1 = function() {
      document.getElementById('v4-add-token1-input').value = v4AddToken1Balance.toString();
      // Trigger auto-balance
      document.getElementById('v4-add-token1-input').dispatchEvent(new Event('input'));
    };

    window.closeV4AddModal = function() {
      document.getElementById('v4-add-modal').classList.remove('visible');
      v4AddPool = null;
      setV4AddTxStatus('', '');
    };

    window.selectV4Fee = function(fee) {
      v4AddSelectedFee = fee;
      document.querySelectorAll('#v4-fee-selector .selector-option').forEach(opt => {
        opt.classList.toggle('selected', parseInt(opt.dataset.fee) === fee);
      });
    };

    window.approveV4Tokens = async function() {
      if (!connectedWallet || !v4AddPool || !v4AddPool.token0) return;

      // Get amounts from input fields
      const amount0Input = parseFloat(document.getElementById('v4-add-token0-input').value) || 0;
      const amount1Input = parseFloat(document.getElementById('v4-add-token1-input').value) || 0;

      if (amount0Input <= 0 && amount1Input <= 0) {
        setV4AddTxStatus('Enter amounts first', 'error');
        return;
      }

      const approveBtn = document.getElementById('v4-add-approve-btn');
      approveBtn.disabled = true;

      try {
        // Calculate raw amounts with some buffer (10% extra for slippage)
        const amount0Raw = BigInt(Math.floor(amount0Input * 1.1 * (10 ** (v4AddPool.token0Decimals || 18))));
        const amount1Raw = BigInt(Math.floor(amount1Input * 1.1 * (10 ** (v4AddPool.token1Decimals || 18))));

        // Only approve ONE token at a time - the first unapproved one
        let tokenToApprove = null;
        if (!v4AddToken0Approved && amount0Input > 0) {
          tokenToApprove = { token: v4AddPool.token0, symbol: v4AddPool.token0Symbol, amount: amount0Raw, isToken0: true };
        } else if (!v4AddToken1Approved && amount1Input > 0) {
          tokenToApprove = { token: v4AddPool.token1, symbol: v4AddPool.token1Symbol, amount: amount1Raw, isToken0: false };
        }

        if (!tokenToApprove) {
          setV4AddTxStatus('Tokens already approved', 'success');
          updateV4AddApprovalUI();
          return;
        }

        const { token, symbol, amount, isToken0 } = tokenToApprove;

        approveBtn.textContent = \`Approving \${symbol}...\`;
        setV4AddTxStatus(\`Approving \${symbol}...\`, 'pending');

        // Approve exact amount to Permit2
        const amountHex = amount.toString(16).padStart(64, '0');
        console.log('[ArbMe] Approving', symbol, 'amount:', amount.toString(), 'hex:', amountHex);
        console.log('[ArbMe] Token address:', token, 'Spender (Permit2):', PERMIT2_ADDRESS);

        const approvalData = '0x095ea7b3' +
          PERMIT2_ADDRESS.slice(2).toLowerCase().padStart(64, '0') +
          amountHex;

        console.log('[ArbMe] Approval calldata:', approvalData);

        const txHash = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: token,
            data: approvalData,
            gas: '0x15F90', // 90000
            value: '0x0',
          }]
        });

        console.log('[ArbMe] Approval tx submitted:', txHash);

        setV4AddTxStatus(\`Waiting for \${symbol} approval...\`, 'pending');

        let confirmed = false;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          const receipt = await sdk.wallet.ethProvider.request({
            method: 'eth_getTransactionReceipt',
            params: [txHash]
          });
          if (receipt && receipt.status === '0x1') {
            confirmed = true;
            break;
          }
        }

        if (!confirmed) {
          setV4AddTxStatus(\`\${symbol} approval not confirmed\`, 'error');
          return;
        }

        // Mark this token as approved
        if (isToken0) {
          v4AddToken0Approved = true;
        } else {
          v4AddToken1Approved = true;
        }

        // Check if we need to approve more tokens
        const needsMoreApprovals = (!v4AddToken0Approved && amount0Input > 0) || (!v4AddToken1Approved && amount1Input > 0);

        if (needsMoreApprovals) {
          setV4AddTxStatus(\`\${symbol} approved! Click again to approve next token.\`, 'success');
        } else {
          setV4AddTxStatus('All tokens approved!', 'success');
        }

        updateV4AddApprovalUI();

      } catch (e) {
        console.error('[ArbMe] V4 approval failed:', e);
        setV4AddTxStatus('Approval failed: ' + (e.message || 'Unknown error'), 'error');
      } finally {
        approveBtn.disabled = false;
        approveBtn.textContent = 'Approve Tokens';
      }
    };

    // Initialize V4 fee selector click handlers
    document.querySelectorAll('#v4-fee-selector .selector-option').forEach(opt => {
      opt.addEventListener('click', () => {
        const fee = parseInt(opt.dataset.fee);
        selectV4Fee(fee);
      });
    });

    // V4 Action constants
    const V4_ACTIONS = {
      MINT_POSITION: 0x02,
      SETTLE_PAIR: 0x0d,
    };

    // Helper to calculate sqrtPriceX96 from tick
    // Alias for tickToSqrtPriceX96 (P2.11 consolidation)
    function getSqrtPriceAtTick(tick) {
      return tickToSqrtPriceX96(tick);
    }

    // Helper to calculate liquidity from amounts (simplified for full range)
    // CRITICAL SAFETY: This function properly handles edge cases to prevent fund loss
    // Uses global Q96 constant (P2.11 consolidation)
    function calculateLiquidityFromAmounts(sqrtPriceX96, sqrtPriceLower, sqrtPriceUpper, amount0, amount1) {
      const sqrtP = BigInt(sqrtPriceX96);
      const sqrtPL = sqrtPriceLower;
      const sqrtPU = sqrtPriceUpper;

      // Determine position relative to current price
      const priceInRange = sqrtP > sqrtPL && sqrtP < sqrtPU;
      const priceBelowRange = sqrtP <= sqrtPL;
      const priceAboveRange = sqrtP >= sqrtPU;

      // CRITICAL SAFETY CHECK: For in-range full-range positions, BOTH amounts MUST be provided
      // Allowing one-sided deposits causes catastrophic fund loss to arbitrage!
      if (priceInRange) {
        if (amount0 <= 0 || amount1 <= 0) {
          console.error('[ArbMe] BLOCKED: In-range position requires BOTH tokens!');
          console.error('[ArbMe] amount0:', amount0.toString(), 'amount1:', amount1.toString());
          return BigInt(0); // Return 0 to block transaction
        }
      }

      // Calculate liquidity based on price position (uses global Q96)
      if (priceBelowRange) {
        // Price below range: position is 100% token0
        if (amount0 <= 0) return BigInt(0);
        return (BigInt(amount0) * sqrtPL * sqrtPU) / ((sqrtPU - sqrtPL) * Q96);
      } else if (priceAboveRange) {
        // Price above range: position is 100% token1
        if (amount1 <= 0) return BigInt(0);
        return (BigInt(amount1) * Q96) / (sqrtPU - sqrtPL);
      } else {
        // Price in range: calculate from both, take minimum (already validated both > 0)
        const liq0 = (BigInt(amount0) * sqrtP * sqrtPU) / ((sqrtPU - sqrtP) * Q96);
        const liq1 = (BigInt(amount1) * Q96) / (sqrtP - sqrtPL);
        return liq0 < liq1 ? liq0 : liq1;
      }
    }

    // Helper to calculate token amounts from liquidity (reverse of above)
    // Uses global Q96 constant (P2.11 consolidation)
    function calculateAmountsFromLiquidity(sqrtPriceX96, sqrtPriceLower, sqrtPriceUpper, liquidity) {
      const sqrtP = BigInt(sqrtPriceX96);
      const sqrtPL = BigInt(sqrtPriceLower);
      const sqrtPU = BigInt(sqrtPriceUpper);
      const L = BigInt(liquidity);

      let amount0 = BigInt(0);
      let amount1 = BigInt(0);

      if (sqrtP <= sqrtPL) {
        // Current price below range - all token0
        amount0 = (L * Q96 * (sqrtPU - sqrtPL)) / (sqrtPL * sqrtPU);
      } else if (sqrtP >= sqrtPU) {
        // Current price above range - all token1
        amount1 = (L * (sqrtPU - sqrtPL)) / Q96;
      } else {
        // Current price in range - mix of both
        amount0 = (L * Q96 * (sqrtPU - sqrtP)) / (sqrtP * sqrtPU);
        amount1 = (L * (sqrtP - sqrtPL)) / Q96;
      }

      return { amount0, amount1 };
    }

    // Helper to get tick from sqrtPriceX96
    // Alias for sqrtPriceX96ToTick (P2.11 consolidation)
    function getTickFromSqrtPrice(sqrtPriceX96) {
      return sqrtPriceX96ToTick(sqrtPriceX96);
    }

    // Helper to encode bytes array for ABI
    function encodeBytes(hexString) {
      // Remove 0x prefix if present
      const data = hexString.startsWith('0x') ? hexString.slice(2) : hexString;
      const length = data.length / 2;
      // Encode: offset (32 bytes) + length (32 bytes) + data (padded to 32 bytes)
      const lengthPadded = length.toString(16).padStart(64, '0');
      const dataPadded = data.padEnd(Math.ceil(data.length / 64) * 64, '0');
      return lengthPadded + dataPadded;
    }

    // Helper to encode dynamic array for ABI
    function encodeDynamicArray(items) {
      // Each item is already encoded bytes
      const numItems = items.length;
      let result = numItems.toString(16).padStart(64, '0'); // array length

      // Calculate offsets (each offset is 32 bytes from start of data section)
      let dataSection = '';
      const offsets = [];
      let currentOffset = numItems * 32; // Start after all offset entries

      for (const item of items) {
        offsets.push(currentOffset.toString(16).padStart(64, '0'));
        const itemData = item.startsWith('0x') ? item.slice(2) : item;
        const itemLength = itemData.length / 2;
        // Length (32 bytes) + padded data
        const lengthHex = itemLength.toString(16).padStart(64, '0');
        const paddedData = itemData.padEnd(Math.ceil(itemData.length / 64) * 64, '0');
        dataSection += lengthHex + paddedData;
        currentOffset += 32 + Math.ceil(itemData.length / 64) * 32;
      }

      return result + offsets.join('') + dataSection;
    }

    window.executeV4AddLiquidity = async function() {
      if (!connectedWallet || !v4AddPool) return;

      const amount0Input = parseFloat(document.getElementById('v4-add-token0-input').value) || 0;
      const amount1Input = parseFloat(document.getElementById('v4-add-token1-input').value) || 0;

      // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
      // CRITICAL GUARDRAIL: Require BOTH tokens for balanced deposits
      // This prevents catastrophic loss from one-sided liquidity adds
      // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
      if (amount0Input <= 0 || amount1Input <= 0) {
        setV4AddTxStatus('BOTH token amounts required for balanced deposit', 'error');
        return;
      }

      // Additional check: amounts must be meaningful (not dust)
      const minValue0 = 0.000001; // Minimum meaningful amount
      const minValue1 = 0.000001;
      if (amount0Input < minValue0 || amount1Input < minValue1) {
        setV4AddTxStatus('Token amounts too small', 'error');
        return;
      }

      if (!v4AddToken0Approved || !v4AddToken1Approved) {
        setV4AddTxStatus('Approve tokens first', 'error');
        return;
      }

      if (!v4AddPool.token0 || !v4AddPool.token1) {
        setV4AddTxStatus('Pool info not loaded', 'error');
        return;
      }

      const addBtn = document.getElementById('v4-add-liquidity-btn');
      addBtn.disabled = true;
      addBtn.textContent = 'Adding...';

      try {
        setV4AddTxStatus('Verifying token decimals...', 'pending');

        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        // CRITICAL: Verify decimals on-chain before transaction
        // This prevents catastrophic loss from decimal mismatches
        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        const decimalVerification = await verifyPairDecimalsOnChain(
          v4AddPool.token0,
          v4AddPool.token1,
          v4AddPool.token0Decimals,
          v4AddPool.token1Decimals,
          v4AddPool.token0Symbol,
          v4AddPool.token1Symbol
        );

        if (!decimalVerification.verified) {
          setV4AddTxStatus('BLOCKED: ' + decimalVerification.errors.join('; '), 'error');
          addBtn.disabled = false;
          addBtn.textContent = 'Add Liquidity';
          return;
        }

        setV4AddTxStatus('Fetching pool state...', 'pending');

        // If we don't have a poolId, compute it from pool key components
        let poolId = v4AddPool.address;
        if (!poolId) {
          console.log('[ArbMe] Computing poolId from pool key...');
          const computeRes = await fetch(\`/test/rpc?action=computePoolId&currency0=\${v4AddPool.token0}&currency1=\${v4AddPool.token1}&fee=\${v4AddPool.fee}&tickSpacing=\${v4AddPool.tickSpacing}&hooks=\${v4AddPool.hooks}\`);
          const computeData = await computeRes.json();
          if (computeData.poolId) {
            poolId = computeData.poolId;
            console.log('[ArbMe] Computed poolId:', poolId);
          } else {
            throw new Error('Could not compute poolId');
          }
        }

        // Get pool's current sqrtPriceX96
        const slot0Res = await fetch(\`/test/rpc?action=v4_getSlot0&poolId=\${poolId}\`);
        const slot0Data = await slot0Res.json();

        // Check for RPC errors - don't proceed if we couldn't verify pool state
        if (slot0Data.rpcError) {
          throw new Error('Could not verify pool state. Please try again. ' + (slot0Data.error || ''));
        }
        if (slot0Data.error) {
          throw new Error('Could not fetch pool state: ' + slot0Data.error);
        }

        let sqrtPriceX96 = slot0Data.sqrtPriceX96;
        console.log('[ArbMe] V4 sqrtPriceX96:', sqrtPriceX96, 'exists:', slot0Data.exists);

        // Convert amounts to raw values (decimals already verified above)
        const amount0Raw = BigInt(Math.floor(amount0Input * (10 ** v4AddPool.token0Decimals)));
        const amount1Raw = BigInt(Math.floor(amount1Input * (10 ** v4AddPool.token1Decimals)));

        // Use the explicit 'exists' flag from backend to determine if pool exists
        let isNewPool = slot0Data.exists === false;
        let initialSqrtPriceX96 = null;
        if (isNewPool) {
          console.log('[ArbMe] Pool does not exist - will create new pool');

          // Calculate initial sqrtPriceX96 from the ratio of amounts
          // sqrtPriceX96 = sqrt(amount1Raw/amount0Raw) * 2^96
          // IMPORTANT: Use raw amounts directly - Uniswap expects raw token ratios, NOT decimal-adjusted
          // Need both amounts > 0 to calculate initial price
          if (amount0Raw <= BigInt(0) || amount1Raw <= BigInt(0)) {
            throw new Error('Both token amounts are required to create a new pool');
          }

          // Calculate price ratio using RAW amounts (no decimal adjustment!)
          // The sqrtPriceX96 encodes the raw ratio of token1/token0
          const priceRatio = Number(amount1Raw) / Number(amount0Raw);
          const sqrtPrice = Math.sqrt(priceRatio);
          initialSqrtPriceX96 = BigInt(Math.floor(sqrtPrice * Math.pow(2, 96)));
          sqrtPriceX96 = '0x' + initialSqrtPriceX96.toString(16);

          // Log the expected price for verification
          const dec0 = v4AddPool.token0Decimals || 18;
          const dec1 = v4AddPool.token1Decimals || 18;
          const humanPrice = priceRatio * Math.pow(10, dec0 - dec1);
          console.log('[ArbMe] New pool price: 1', v4AddPool.token0Symbol, '=', humanPrice.toFixed(6), v4AddPool.token1Symbol);

          console.log('[ArbMe] Calculated initial sqrtPriceX96:', sqrtPriceX96);
          setV4AddTxStatus('Creating new pool...', 'pending');
        } else {
          // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
          // CRITICAL GUARDRAIL: Validate deposit ratio matches pool price
          // This prevents users from losing funds to arbitrage
          // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
          setV4AddTxStatus('Validating deposit ratio...', 'pending');

          // Calculate the pool's current price ratio (raw) - uses consolidated utilities (P2.11)
          // price = (sqrtP / Q96)^2 = token1 per token0 in raw units
          // IMPORTANT: Scale up before dividing to preserve precision (sqrtP^2 can exceed JS Number precision)
          const poolPriceRawScaled = sqrtPriceX96ToScaledPrice(sqrtPriceX96);
          const poolPriceRaw = Number(poolPriceRawScaled) / 1e18;

          // Calculate user's input ratio (raw)
          // Also use BigInt division to avoid precision issues with large amounts
          const userRatioRawScaled = (amount1Raw * PRICE_SCALE) / amount0Raw;
          const userRatioRaw = Number(userRatioRawScaled) / 1e18;

          // Calculate how far off the user's ratio is from pool price
          // Allow up to 10% deviation to account for price movement and rounding
          const ratioDiff = Math.abs(userRatioRaw - poolPriceRaw) / poolPriceRaw;
          const maxAllowedDiff = 0.10; // 10% tolerance

          console.log('[ArbMe] Pool price ratio (raw):', poolPriceRaw);
          console.log('[ArbMe] User input ratio (raw):', userRatioRaw);
          console.log('[ArbMe] Ratio difference:', (ratioDiff * 100).toFixed(2) + '%');

          if (ratioDiff > maxAllowedDiff) {
            const dec0 = v4AddPool.token0Decimals || 18;
            const dec1 = v4AddPool.token1Decimals || 18;
            const poolPriceHuman = poolPriceRaw * Math.pow(10, dec0 - dec1);
            const expectedAmount1 = amount0Input * poolPriceHuman;

            setV4AddTxStatus(
              'Deposit ratio does not match pool price! ' +
              'Expected ~' + expectedAmount1.toFixed(2) + ' ' + v4AddPool.token1Symbol +
              ' for ' + amount0Input.toFixed(6) + ' ' + v4AddPool.token0Symbol +
              '. Adjust amounts to avoid loss.',
              'error'
            );
            const addBtn = document.getElementById('v4-add-liquidity-btn');
            addBtn.disabled = false;
            addBtn.textContent = 'Add Liquidity';
            return;
          }

          setV4AddTxStatus('Preparing transaction...', 'pending');
        }

        // Get tick spacing and calculate full range ticks
        const tickSpacing = v4AddPool.tickSpacing || getV4TickSpacing(v4AddSelectedFee);
        const maxTick = Math.floor(887272 / tickSpacing) * tickSpacing;
        const tickLower = -maxTick;
        const tickUpper = maxTick;

        // Calculate sqrtPrice at tick bounds
        const sqrtPriceLower = getSqrtPriceAtTick(tickLower);
        const sqrtPriceUpper = getSqrtPriceAtTick(tickUpper);

        // Calculate liquidity from amounts
        const liquidity = calculateLiquidityFromAmounts(
          sqrtPriceX96,
          sqrtPriceLower,
          sqrtPriceUpper,
          amount0Raw,
          amount1Raw
        );

        if (liquidity <= BigInt(0)) {
          throw new Error('Could not calculate valid liquidity');
        }

        console.log('[ArbMe] Calculated liquidity:', liquidity.toString());

        // Deadline: 20 minutes from now
        const deadline = Math.floor(Date.now() / 1000) + 1200;

        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
        // BUILD TRANSACTION USING UNISWAP SDK (with decimal validation)
        // âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ

        setV4AddTxStatus('Building transaction with SDK...', 'pending');

        // STEP 1: Validate token pair using SDK safety rails
        console.log('[ArbMe SDK] Validating token pair before encoding...');
        const token0Info = {
          address: v4AddPool.token0,
          symbol: v4AddPool.token0Symbol,
          decimals: v4AddPool.token0Decimals,
        };
        const token1Info = {
          address: v4AddPool.token1,
          symbol: v4AddPool.token1Symbol,
          decimals: v4AddPool.token1Decimals,
        };

        const pairValidation = validateTokenPair(token0Info, token1Info);

        if (!pairValidation.valid) {
          console.error('[ArbMe SDK] Token validation FAILED:', pairValidation.error);
          throw new Error('Token validation failed: ' + pairValidation.error);
        }

        // Log any warnings (e.g., non-18 decimal whitelisted tokens)
        if (pairValidation.warnings) {
          pairValidation.warnings.forEach(warning => {
            console.warn('[ArbMe SDK]', warning);
          });
        }

        console.log('[ArbMe SDK] â Token pair validated - safe to proceed');

        // STEP 2: Build mint position using SDK
        console.log('[ArbMe SDK] Encoding V4 mint position with official Uniswap SDK...');

        const mintPositionParams: V4MintPositionParams = {
          token0: token0Info,
          token1: token1Info,
          fee: v4AddSelectedFee,
          tickSpacing,
          tickLower,
          tickUpper,
          liquidity,
          amount0Max: amount0Raw,
          amount1Max: amount1Raw,
          amount0Min: BigInt(0), // Could add slippage here
          amount1Min: BigInt(0),
          recipient: connectedWallet,
        };

        const encoded = encodeV4MintPosition(mintPositionParams);

        if (!encoded.validation.valid) {
          console.error('[ArbMe SDK] Encoding validation FAILED:', encoded.validation.error);
          throw new Error('SDK encoding failed: ' + encoded.validation.error);
        }

        console.log('[ArbMe SDK] â V4 actions encoded successfully');
        console.log('[ArbMe SDK]   Actions:', encoded.actions);
        console.log('[ArbMe SDK]   Params:', encoded.params.length, 'items');

        // STEP 3: Build modifyLiquidities calldata from SDK output
        const actionsHex = encoded.actions.startsWith('0x') ? encoded.actions.slice(2) : encoded.actions;
        const paramsArray = encoded.params.map(p => p.startsWith('0x') ? p.slice(2) : p);

        // Encode as per V4Planner's unlockData structure
        const actionsLength = actionsHex.length / 2;
        const actionsLengthPadded = actionsLength.toString(16).padStart(64, '0');
        const actionsPadded = actionsHex.padEnd(Math.ceil(actionsHex.length / 2) * 2, '0');
        const offsetActions = (64).toString(16).padStart(64, '0');
        const offsetParams = (64 + 32 + 32).toString(16).padStart(64, '0');
        const numParams = paramsArray.length;
        const paramsArrayLength = numParams.toString(16).padStart(64, '0');

        let paramOffsets = [];
        let currentOffset = numParams * 32;
        for (let i = 0; i < numParams; i++) {
          paramOffsets.push(currentOffset.toString(16).padStart(64, '0'));
          const paddedLen = Math.ceil(paramsArray[i].length / 64) * 32;
          currentOffset += 32 + paddedLen;
        }

        let paramsData = '';
        for (let i = 0; i < numParams; i++) {
          const paramBytes = paramsArray[i];
          const paramLength = paramBytes.length / 2;
          const paramLengthPadded = paramLength.toString(16).padStart(64, '0');
          const paramPaddedData = paramBytes.padEnd(Math.ceil(paramBytes.length / 64) * 64, '0');
          paramsData += paramLengthPadded + paramPaddedData;
        }

        const paramsArrayEncoded = paramsArrayLength + paramOffsets.join('') + paramsData;
        const unlockData = offsetActions + offsetParams + actionsLengthPadded + actionsPadded + paramsArrayEncoded;
        const modifyLiqSelector = '0xdd46508f';

        // Encode the final call
        // Offset to unlockData (dynamic): 64 (after offset word + deadline word)
        const unlockDataOffset = (64).toString(16).padStart(64, '0');
        const deadlinePadded = deadline.toString(16).padStart(64, '0');
        const unlockDataLength = (unlockData.length / 2).toString(16).padStart(64, '0');
        const unlockDataPadded = unlockData.padEnd(Math.ceil(unlockData.length / 64) * 64, '0');

        const callData = modifyLiqSelector +
          unlockDataOffset +
          deadlinePadded +
          unlockDataLength +
          unlockDataPadded;

        console.log('[ArbMe] V4 modifyLiquidities callData:', callData);

        const modifyLiqCallData = '0x' + callData.slice(2); // Ensure 0x prefix

        // Build the final transaction calldata
        let finalCallData;

        if (isNewPool) {
          console.log('[ArbMe] Creating new pool - using multicall with ethers.js');

          // Use ethers.js to encode initializePool
          const initPoolCallData = encodeInitializePool(
            v4AddPool.token0,  // currency0
            v4AddPool.token1,  // currency1
            v4AddSelectedFee,  // fee
            tickSpacing,       // tickSpacing
            v4AddPool.hooks || '0x0000000000000000000000000000000000000000', // hooks
            initialSqrtPriceX96 // sqrtPriceX96
          );

          console.log('[ArbMe] initializePool callData (ethers):', initPoolCallData);
          console.log('[ArbMe] modifyLiquidities callData:', modifyLiqCallData);

          // Use ethers.js to encode multicall with both calls
          finalCallData = encodeMulticall([initPoolCallData, modifyLiqCallData]);

          console.log('[ArbMe] multicall callData (ethers):', finalCallData);
          setV4AddTxStatus('Creating pool & adding liquidity...', 'pending');
        } else {
          // Existing pool - just modifyLiquidities
          finalCallData = modifyLiqCallData;
          setV4AddTxStatus('Confirm transaction...', 'pending');
        }

        console.log('[ArbMe] Sending V4 add liquidity transaction...');
        // Use higher gas for new pool (multicall) vs existing pool
        const gasLimit = isNewPool ? TX_CONSTANTS.GAS_LIMITS.CREATE_POOL_V4 : TX_CONSTANTS.GAS_LIMITS.ADD_LIQUIDITY_V4;
        const txHash = await sdk.wallet.ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: connectedWallet,
            to: V4_POSITION_MANAGER_JS,
            data: finalCallData,
            gas: gasLimit,
            value: '0x0',
          }]
        });

        console.log('[ArbMe] V4 add liquidity txHash:', txHash);

        setV4AddTxStatus('Waiting for confirmation...', 'pending');

        // Wait for confirmation
        let confirmed = false;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          const receipt = await sdk.wallet.ethProvider.request({
            method: 'eth_getTransactionReceipt',
            params: [txHash]
          });
          if (receipt) {
            if (receipt.status === '0x1') {
              confirmed = true;
              break;
            } else {
              throw new Error('Transaction reverted');
            }
          }
        }

        if (confirmed) {
          setV4AddTxStatus('Position created!', 'success');
          showToast('success', 'Liquidity Added!', 'View on <a href="https://basescan.org/tx/' + txHash + '" target="_blank">Basescan</a>');
          setTimeout(() => {
            closeV4AddModal();
            loadPositions(); // Refresh positions
          }, 2000);
        } else {
          setV4AddTxStatus('Transaction not confirmed', 'error');
        }

      } catch (e) {
        console.error('[ArbMe] V4 add liquidity failed:', e);
        setV4AddTxStatus('Failed: ' + (e.message || 'Unknown error'), 'error');
        showToast('error', 'Transaction Failed', e.message || 'Unknown error');
      } finally {
        addBtn.disabled = false;
        addBtn.textContent = 'Add Liquidity';
      }
    };

    // Event listeners
    document.getElementById('wallet-btn').addEventListener('click', connectWallet);
    document.getElementById('positions-header').addEventListener('click', togglePositions);

    document.getElementById('buy-btn').addEventListener('click', async () => {
      // CAIP-19 format: eip155:<chainId>/erc20:<contractAddress>
      const arbmeCaip19 = 'eip155:8453/erc20:' + ARBME_ADDRESS;
      console.log('[ArbMe] Buy button clicked, CAIP-19:', arbmeCaip19);
      try {
        // Use Farcaster SDK native swap with ARBME as the buy token (CAIP-19 format)
        const result = await sdk.actions.swapToken({
          buyToken: arbmeCaip19,
        });
        console.log('[ArbMe] Swap result:', result);
        if (result.success) {
          showToast('success', 'Swap Complete!', 'Transaction: ' + result.swap.transactions[0]?.slice(0, 10) + '...');
        }
      } catch (e) {
        console.error('[ArbMe] Swap action failed:', e);
        showToast('error', 'Swap Failed', e.message || 'Unknown error');
      }
    });

    document.getElementById('refresh-btn').addEventListener('click', loadPools);

    document.getElementById('show-more-btn').addEventListener('click', () => {
      showAllPools = !showAllPools;
      if (poolsData) renderPools(poolsData.pools, showAllPools);
    });

    // Init
    async function init() {
      console.log('[ArbMe] Initializing...');

      // CRITICAL: Call ready() ASAP to prevent infinite loading screen
      try {
        await sdk.actions.ready();
        console.log('[ArbMe] SDK ready signal sent');
      } catch (e) {
        console.error('[ArbMe] Failed to send ready signal:', e);
      }

      // Now load pools and connect wallet
      await loadPools();

      // Auto-connect wallet in Farcaster context
      try {
        const context = await sdk.context;
        console.log('[ArbMe] Initial context:', context?.user ? 'has user' : 'no user');
        if (context?.user) {
          await connectWallet();
        }
      } catch (e) {
        console.log('[ArbMe] Not in Farcaster context:', e);
      }

      // Set initial height for collapsible
      const content = document.getElementById('positions-content');
      content.style.maxHeight = content.scrollHeight + 'px';

      console.log('[ArbMe] Initialization complete');
    }
    init();
  </script>
</body>
</html>
